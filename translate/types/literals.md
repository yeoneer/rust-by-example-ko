# 리터럴

숫자 리터럴에는 접미사로 타입 어노테이션을 작성할 수 있습니다.
예를 들어, `42i32`는 `42` 리터럴을 `i32` 타입으로 지정한다는 의미입니다.

접미사가 없는 숫자 리터럴은 어떻게 사용되느냐에 따라서 타입이 달라집니다.
제약 조건이 없을 경우, 컴파일러는 정수에 `i32` 타입을,
부동 소수점에 `f64` 타입을 사용합니다.

```rust,editable
fn main() {
    // 접미사가 있는 리터럴 (초기화 시점에 타입을 알 수 있음)
    let x = 1u8;
    let y = 2u32;
    let z = 3f32;

    // 접미사가 없는 리터럴 (어떻게 사용되느냐에 따라 타입이 달라짐)
    let i = 1;
    let f = 1.0;

    // `size_of_val`는 변수의 크기를 바이트 단위로 반환합니다.
    println!("`x`의 바이트 단위 크기: {}", std::mem::size_of_val(&x));
    println!("`y`의 바이트 단위 크기: {}", std::mem::size_of_val(&y));
    println!("`z`의 바이트 단위 크기: {}", std::mem::size_of_val(&z));
    println!("`i`의 바이트 단위 크기: {}", std::mem::size_of_val(&i));
    println!("`f`의 바이트 단위 크기: {}", std::mem::size_of_val(&f));
}
```

앞선 코드에서는 아직 설명하지 않은 개념이 몇 가지 사용되었습니다.
궁금하신 분을 위해 간단히 설명하겠습니다.

* `std::mem::size_of_val`는 함수이며, **전체 경로**를 통해 호출했습니다.
  코드는 **모듈**이라는 논리적 단위로 분할할 수 있습니다.
  이 경우, `size_of_val` 함수는 `mem` 모듈 내에 정의되어있고,
  `mem` 모듈은 `std` **크레이트** 내에 정의되어있습니다.
  자세한 내용은 [모듈][mod], [크레이트][crate]를 참고해주세요.

[mod]: ../mod.md
[crate]: ../crates.md
