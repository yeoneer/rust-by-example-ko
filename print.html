<!DOCTYPE HTML>
<html lang="ko" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust By Example</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Rust by Example (RBE) is a collection of runnable examples that illustrate various Rust concepts and standard libraries.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/d2coding-font.css">
        <link rel="stylesheet" href="fonts/notosanskr-font.css">
        <link rel="stylesheet" href="fonts/ridibatang-font.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="index.html">서론</a></li><li class="chapter-item "><a href="hello.html"><strong aria-hidden="true">1.</strong> Hello World</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="hello/comment.html"><strong aria-hidden="true">1.1.</strong> 주석</a></li><li class="chapter-item "><a href="hello/print.html"><strong aria-hidden="true">1.2.</strong> 출력 포맷팅</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="hello/print/print_debug.html"><strong aria-hidden="true">1.2.1.</strong> Debug</a></li><li class="chapter-item "><a href="hello/print/print_display.html"><strong aria-hidden="true">1.2.2.</strong> Display</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="hello/print/print_display/testcase_list.html"><strong aria-hidden="true">1.2.2.1.</strong> Testcase: List</a></li></ol></li><li class="chapter-item "><a href="hello/print/fmt.html"><strong aria-hidden="true">1.2.3.</strong> 포맷팅</a></li></ol></li></ol></li><li class="chapter-item "><a href="primitives.html"><strong aria-hidden="true">2.</strong> 기본 요소</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="primitives/literals.html"><strong aria-hidden="true">2.1.</strong> 리터럴, 연산자</a></li><li class="chapter-item "><a href="primitives/tuples.html"><strong aria-hidden="true">2.2.</strong> 튜플</a></li><li class="chapter-item "><a href="primitives/array.html"><strong aria-hidden="true">2.3.</strong> 배열, 슬라이스</a></li></ol></li><li class="chapter-item "><a href="custom_types.html"><strong aria-hidden="true">3.</strong> 커스텀 타입</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="custom_types/structs.html"><strong aria-hidden="true">3.1.</strong> 구조체</a></li><li class="chapter-item "><a href="custom_types/enum.html"><strong aria-hidden="true">3.2.</strong> 열거형</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="custom_types/enum/enum_use.html"><strong aria-hidden="true">3.2.1.</strong> use</a></li><li class="chapter-item "><a href="custom_types/enum/c_like.html"><strong aria-hidden="true">3.2.2.</strong> C-like</a></li><li class="chapter-item "><a href="custom_types/enum/testcase_linked_list.html"><strong aria-hidden="true">3.2.3.</strong> Testcase: 연결 리스트</a></li></ol></li><li class="chapter-item "><a href="custom_types/constants.html"><strong aria-hidden="true">3.3.</strong> 상수</a></li></ol></li><li class="chapter-item "><a href="variable_bindings.html"><strong aria-hidden="true">4.</strong> 변수 바인딩</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="variable_bindings/mut.html"><strong aria-hidden="true">4.1.</strong> 가변성</a></li><li class="chapter-item "><a href="variable_bindings/scope.html"><strong aria-hidden="true">4.2.</strong> 스코프, 변수 가리기</a></li><li class="chapter-item "><a href="variable_bindings/declare.html"><strong aria-hidden="true">4.3.</strong> 조기 선언</a></li><li class="chapter-item "><a href="variable_bindings/freeze.html"><strong aria-hidden="true">4.4.</strong> 변수 동결</a></li></ol></li><li class="chapter-item "><a href="types.html"><strong aria-hidden="true">5.</strong> 타입</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="types/cast.html"><strong aria-hidden="true">5.1.</strong> 형변환</a></li><li class="chapter-item "><a href="types/literals.html"><strong aria-hidden="true">5.2.</strong> 리터럴</a></li><li class="chapter-item "><a href="types/inference.html"><strong aria-hidden="true">5.3.</strong> 타입 추론</a></li><li class="chapter-item "><a href="types/alias.html"><strong aria-hidden="true">5.4.</strong> 타입 별칭</a></li></ol></li><li class="chapter-item "><a href="conversion.html"><strong aria-hidden="true">6.</strong> 형변환</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="conversion/from_into.html"><strong aria-hidden="true">6.1.</strong> From, Into</a></li><li class="chapter-item "><a href="conversion/try_from_try_into.html"><strong aria-hidden="true">6.2.</strong> TryFrom, TryInto</a></li><li class="chapter-item "><a href="conversion/string.html"><strong aria-hidden="true">6.3.</strong> 문자열 변환</a></li></ol></li><li class="chapter-item "><a href="expression.html"><strong aria-hidden="true">7.</strong> 표현식</a></li><li class="chapter-item "><a href="flow_control.html"><strong aria-hidden="true">8.</strong> 흐름 제어</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="flow_control/if_else.html"><strong aria-hidden="true">8.1.</strong> if/else</a></li><li class="chapter-item "><a href="flow_control/loop.html"><strong aria-hidden="true">8.2.</strong> loop</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="flow_control/loop/nested.html"><strong aria-hidden="true">8.2.1.</strong> 중첩, 라벨</a></li><li class="chapter-item "><a href="flow_control/loop/return.html"><strong aria-hidden="true">8.2.2.</strong> 반복문에서 반환하기</a></li></ol></li><li class="chapter-item "><a href="flow_control/while.html"><strong aria-hidden="true">8.3.</strong> while</a></li><li class="chapter-item "><a href="flow_control/for.html"><strong aria-hidden="true">8.4.</strong> for 반복문, 범위</a></li><li class="chapter-item "><a href="flow_control/match.html"><strong aria-hidden="true">8.5.</strong> match</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="flow_control/match/destructuring.html"><strong aria-hidden="true">8.5.1.</strong> 해체</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="flow_control/match/destructuring/destructure_tuple.html"><strong aria-hidden="true">8.5.1.1.</strong> 튜플</a></li><li class="chapter-item "><a href="flow_control/match/destructuring/destructure_enum.html"><strong aria-hidden="true">8.5.1.2.</strong> 열거형</a></li><li class="chapter-item "><a href="flow_control/match/destructuring/destructure_pointers.html"><strong aria-hidden="true">8.5.1.3.</strong> 포인터/참조자</a></li><li class="chapter-item "><a href="flow_control/match/destructuring/destructure_structures.html"><strong aria-hidden="true">8.5.1.4.</strong> 구조체</a></li></ol></li><li class="chapter-item "><a href="flow_control/match/guard.html"><strong aria-hidden="true">8.5.2.</strong> 매치 가드</a></li><li class="chapter-item "><a href="flow_control/match/binding.html"><strong aria-hidden="true">8.5.3.</strong> 바인딩</a></li></ol></li><li class="chapter-item "><a href="flow_control/if_let.html"><strong aria-hidden="true">8.6.</strong> if let</a></li><li class="chapter-item "><a href="flow_control/while_let.html"><strong aria-hidden="true">8.7.</strong> while let</a></li></ol></li><li class="chapter-item "><a href="fn.html"><strong aria-hidden="true">9.</strong> Functions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="fn/methods.html"><strong aria-hidden="true">9.1.</strong> Methods</a></li><li class="chapter-item "><a href="fn/closures.html"><strong aria-hidden="true">9.2.</strong> Closures</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="fn/closures/capture.html"><strong aria-hidden="true">9.2.1.</strong> Capturing</a></li><li class="chapter-item "><a href="fn/closures/input_parameters.html"><strong aria-hidden="true">9.2.2.</strong> As input parameters</a></li><li class="chapter-item "><a href="fn/closures/anonymity.html"><strong aria-hidden="true">9.2.3.</strong> Type anonymity</a></li><li class="chapter-item "><a href="fn/closures/input_functions.html"><strong aria-hidden="true">9.2.4.</strong> Input functions</a></li><li class="chapter-item "><a href="fn/closures/output_parameters.html"><strong aria-hidden="true">9.2.5.</strong> As output parameters</a></li><li class="chapter-item "><a href="fn/closures/closure_examples.html"><strong aria-hidden="true">9.2.6.</strong> Examples in std</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="fn/closures/closure_examples/iter_any.html"><strong aria-hidden="true">9.2.6.1.</strong> Iterator::any</a></li><li class="chapter-item "><a href="fn/closures/closure_examples/iter_find.html"><strong aria-hidden="true">9.2.6.2.</strong> Searching through iterators</a></li></ol></li></ol></li><li class="chapter-item "><a href="fn/hof.html"><strong aria-hidden="true">9.3.</strong> Higher Order Functions</a></li><li class="chapter-item "><a href="fn/diverging.html"><strong aria-hidden="true">9.4.</strong> Diverging functions</a></li></ol></li><li class="chapter-item "><a href="mod.html"><strong aria-hidden="true">10.</strong> Modules</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="mod/visibility.html"><strong aria-hidden="true">10.1.</strong> Visibility</a></li><li class="chapter-item "><a href="mod/struct_visibility.html"><strong aria-hidden="true">10.2.</strong> Struct visibility</a></li><li class="chapter-item "><a href="mod/use.html"><strong aria-hidden="true">10.3.</strong> The use declaration</a></li><li class="chapter-item "><a href="mod/super.html"><strong aria-hidden="true">10.4.</strong> super and self</a></li><li class="chapter-item "><a href="mod/split.html"><strong aria-hidden="true">10.5.</strong> File hierarchy</a></li></ol></li><li class="chapter-item "><a href="crates.html"><strong aria-hidden="true">11.</strong> Crates</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="crates/lib.html"><strong aria-hidden="true">11.1.</strong> Creating a Library</a></li><li class="chapter-item "><a href="crates/using_lib.html"><strong aria-hidden="true">11.2.</strong> Using a Library</a></li></ol></li><li class="chapter-item "><a href="cargo.html"><strong aria-hidden="true">12.</strong> Cargo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="cargo/deps.html"><strong aria-hidden="true">12.1.</strong> Dependencies</a></li><li class="chapter-item "><a href="cargo/conventions.html"><strong aria-hidden="true">12.2.</strong> Conventions</a></li><li class="chapter-item "><a href="cargo/test.html"><strong aria-hidden="true">12.3.</strong> Tests</a></li><li class="chapter-item "><a href="cargo/build_scripts.html"><strong aria-hidden="true">12.4.</strong> Build Scripts</a></li></ol></li><li class="chapter-item "><a href="attribute.html"><strong aria-hidden="true">13.</strong> Attributes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="attribute/unused.html"><strong aria-hidden="true">13.1.</strong> dead_code</a></li><li class="chapter-item "><a href="attribute/crate.html"><strong aria-hidden="true">13.2.</strong> Crates</a></li><li class="chapter-item "><a href="attribute/cfg.html"><strong aria-hidden="true">13.3.</strong> cfg</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="attribute/cfg/custom.html"><strong aria-hidden="true">13.3.1.</strong> Custom</a></li></ol></li></ol></li><li class="chapter-item "><a href="generics.html"><strong aria-hidden="true">14.</strong> Generics</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="generics/gen_fn.html"><strong aria-hidden="true">14.1.</strong> Functions</a></li><li class="chapter-item "><a href="generics/impl.html"><strong aria-hidden="true">14.2.</strong> Implementation</a></li><li class="chapter-item "><a href="generics/gen_trait.html"><strong aria-hidden="true">14.3.</strong> Traits</a></li><li class="chapter-item "><a href="generics/bounds.html"><strong aria-hidden="true">14.4.</strong> Bounds</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="generics/bounds/testcase_empty.html"><strong aria-hidden="true">14.4.1.</strong> Testcase: empty bounds</a></li></ol></li><li class="chapter-item "><a href="generics/multi_bounds.html"><strong aria-hidden="true">14.5.</strong> Multiple bounds</a></li><li class="chapter-item "><a href="generics/where.html"><strong aria-hidden="true">14.6.</strong> Where clauses</a></li><li class="chapter-item "><a href="generics/new_types.html"><strong aria-hidden="true">14.7.</strong> New Type Idiom</a></li><li class="chapter-item "><a href="generics/assoc_items.html"><strong aria-hidden="true">14.8.</strong> Associated items</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="generics/assoc_items/the_problem.html"><strong aria-hidden="true">14.8.1.</strong> The Problem</a></li><li class="chapter-item "><a href="generics/assoc_items/types.html"><strong aria-hidden="true">14.8.2.</strong> Associated types</a></li></ol></li><li class="chapter-item "><a href="generics/phantom.html"><strong aria-hidden="true">14.9.</strong> Phantom type parameters</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="generics/phantom/testcase_units.html"><strong aria-hidden="true">14.9.1.</strong> Testcase: unit clarification</a></li></ol></li></ol></li><li class="chapter-item "><a href="scope.html"><strong aria-hidden="true">15.</strong> Scoping rules</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="scope/raii.html"><strong aria-hidden="true">15.1.</strong> RAII</a></li><li class="chapter-item "><a href="scope/move.html"><strong aria-hidden="true">15.2.</strong> Ownership and moves</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="scope/move/mut.html"><strong aria-hidden="true">15.2.1.</strong> Mutability</a></li><li class="chapter-item "><a href="scope/move/partial_move.html"><strong aria-hidden="true">15.2.2.</strong> Partial moves</a></li></ol></li><li class="chapter-item "><a href="scope/borrow.html"><strong aria-hidden="true">15.3.</strong> Borrowing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="scope/borrow/mut.html"><strong aria-hidden="true">15.3.1.</strong> Mutability</a></li><li class="chapter-item "><a href="scope/borrow/alias.html"><strong aria-hidden="true">15.3.2.</strong> Aliasing</a></li><li class="chapter-item "><a href="scope/borrow/ref.html"><strong aria-hidden="true">15.3.3.</strong> The ref pattern</a></li></ol></li><li class="chapter-item "><a href="scope/lifetime.html"><strong aria-hidden="true">15.4.</strong> Lifetimes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="scope/lifetime/explicit.html"><strong aria-hidden="true">15.4.1.</strong> Explicit annotation</a></li><li class="chapter-item "><a href="scope/lifetime/fn.html"><strong aria-hidden="true">15.4.2.</strong> Functions</a></li><li class="chapter-item "><a href="scope/lifetime/methods.html"><strong aria-hidden="true">15.4.3.</strong> Methods</a></li><li class="chapter-item "><a href="scope/lifetime/struct.html"><strong aria-hidden="true">15.4.4.</strong> Structs</a></li><li class="chapter-item "><a href="scope/lifetime/trait.html"><strong aria-hidden="true">15.4.5.</strong> Traits</a></li><li class="chapter-item "><a href="scope/lifetime/lifetime_bounds.html"><strong aria-hidden="true">15.4.6.</strong> Bounds</a></li><li class="chapter-item "><a href="scope/lifetime/lifetime_coercion.html"><strong aria-hidden="true">15.4.7.</strong> Coercion</a></li><li class="chapter-item "><a href="scope/lifetime/static_lifetime.html"><strong aria-hidden="true">15.4.8.</strong> Static</a></li><li class="chapter-item "><a href="scope/lifetime/elision.html"><strong aria-hidden="true">15.4.9.</strong> Elision</a></li></ol></li></ol></li><li class="chapter-item "><a href="trait.html"><strong aria-hidden="true">16.</strong> Traits</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="trait/derive.html"><strong aria-hidden="true">16.1.</strong> Derive</a></li><li class="chapter-item "><a href="trait/dyn.html"><strong aria-hidden="true">16.2.</strong> Returning Traits with dyn</a></li><li class="chapter-item "><a href="trait/ops.html"><strong aria-hidden="true">16.3.</strong> Operator Overloading</a></li><li class="chapter-item "><a href="trait/drop.html"><strong aria-hidden="true">16.4.</strong> Drop</a></li><li class="chapter-item "><a href="trait/iter.html"><strong aria-hidden="true">16.5.</strong> Iterators</a></li><li class="chapter-item "><a href="trait/impl_trait.html"><strong aria-hidden="true">16.6.</strong> impl Trait</a></li><li class="chapter-item "><a href="trait/clone.html"><strong aria-hidden="true">16.7.</strong> Clone</a></li><li class="chapter-item "><a href="trait/supertraits.html"><strong aria-hidden="true">16.8.</strong> Supertraits</a></li><li class="chapter-item "><a href="trait/disambiguating.html"><strong aria-hidden="true">16.9.</strong> Disambiguating overlapping traits</a></li></ol></li><li class="chapter-item "><a href="macros.html"><strong aria-hidden="true">17.</strong> macro_rules!</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="macros/syntax.html"><strong aria-hidden="true">17.1.</strong> Syntax</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="macros/designators.html"><strong aria-hidden="true">17.1.1.</strong> Designators</a></li><li class="chapter-item "><a href="macros/overload.html"><strong aria-hidden="true">17.1.2.</strong> Overload</a></li><li class="chapter-item "><a href="macros/repeat.html"><strong aria-hidden="true">17.1.3.</strong> Repeat</a></li></ol></li><li class="chapter-item "><a href="macros/dry.html"><strong aria-hidden="true">17.2.</strong> DRY (Don't Repeat Yourself)</a></li><li class="chapter-item "><a href="macros/dsl.html"><strong aria-hidden="true">17.3.</strong> DSL (Domain Specific Languages)</a></li><li class="chapter-item "><a href="macros/variadics.html"><strong aria-hidden="true">17.4.</strong> Variadics</a></li></ol></li><li class="chapter-item "><a href="error.html"><strong aria-hidden="true">18.</strong> Error handling</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="error/panic.html"><strong aria-hidden="true">18.1.</strong> panic</a></li><li class="chapter-item "><a href="error/option_unwrap.html"><strong aria-hidden="true">18.2.</strong> Option &amp; unwrap</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="error/option_unwrap/question_mark.html"><strong aria-hidden="true">18.2.1.</strong> Unpacking options with ?</a></li><li class="chapter-item "><a href="error/option_unwrap/map.html"><strong aria-hidden="true">18.2.2.</strong> Combinators: map</a></li><li class="chapter-item "><a href="error/option_unwrap/and_then.html"><strong aria-hidden="true">18.2.3.</strong> Combinators: and_then</a></li></ol></li><li class="chapter-item "><a href="error/result.html"><strong aria-hidden="true">18.3.</strong> Result</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="error/result/result_map.html"><strong aria-hidden="true">18.3.1.</strong> map for Result</a></li><li class="chapter-item "><a href="error/result/result_alias.html"><strong aria-hidden="true">18.3.2.</strong> aliases for Result</a></li><li class="chapter-item "><a href="error/result/early_returns.html"><strong aria-hidden="true">18.3.3.</strong> Early returns</a></li><li class="chapter-item "><a href="error/result/enter_question_mark.html"><strong aria-hidden="true">18.3.4.</strong> Introducing ?</a></li></ol></li><li class="chapter-item "><a href="error/multiple_error_types.html"><strong aria-hidden="true">18.4.</strong> Multiple error types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="error/multiple_error_types/option_result.html"><strong aria-hidden="true">18.4.1.</strong> Pulling Results out of Options</a></li><li class="chapter-item "><a href="error/multiple_error_types/define_error_type.html"><strong aria-hidden="true">18.4.2.</strong> Defining an error type</a></li><li class="chapter-item "><a href="error/multiple_error_types/boxing_errors.html"><strong aria-hidden="true">18.4.3.</strong> Boxing errors</a></li><li class="chapter-item "><a href="error/multiple_error_types/reenter_question_mark.html"><strong aria-hidden="true">18.4.4.</strong> Other uses of ?</a></li><li class="chapter-item "><a href="error/multiple_error_types/wrap_error.html"><strong aria-hidden="true">18.4.5.</strong> Wrapping errors</a></li></ol></li><li class="chapter-item "><a href="error/iter_result.html"><strong aria-hidden="true">18.5.</strong> Iterating over Results</a></li></ol></li><li class="chapter-item "><a href="std.html"><strong aria-hidden="true">19.</strong> Std library types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std/box.html"><strong aria-hidden="true">19.1.</strong> Box, stack and heap</a></li><li class="chapter-item "><a href="std/vec.html"><strong aria-hidden="true">19.2.</strong> Vectors</a></li><li class="chapter-item "><a href="std/str.html"><strong aria-hidden="true">19.3.</strong> Strings</a></li><li class="chapter-item "><a href="std/option.html"><strong aria-hidden="true">19.4.</strong> Option</a></li><li class="chapter-item "><a href="std/result.html"><strong aria-hidden="true">19.5.</strong> Result</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std/result/question_mark.html"><strong aria-hidden="true">19.5.1.</strong> ?</a></li></ol></li><li class="chapter-item "><a href="std/panic.html"><strong aria-hidden="true">19.6.</strong> panic!</a></li><li class="chapter-item "><a href="std/hash.html"><strong aria-hidden="true">19.7.</strong> HashMap</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std/hash/alt_key_types.html"><strong aria-hidden="true">19.7.1.</strong> Alternate/custom key types</a></li><li class="chapter-item "><a href="std/hash/hashset.html"><strong aria-hidden="true">19.7.2.</strong> HashSet</a></li></ol></li><li class="chapter-item "><a href="std/rc.html"><strong aria-hidden="true">19.8.</strong> Rc</a></li><li class="chapter-item "><a href="std/arc.html"><strong aria-hidden="true">19.9.</strong> Arc</a></li></ol></li><li class="chapter-item "><a href="std_misc.html"><strong aria-hidden="true">20.</strong> Std misc</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std_misc/threads.html"><strong aria-hidden="true">20.1.</strong> Threads</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std_misc/threads/testcase_mapreduce.html"><strong aria-hidden="true">20.1.1.</strong> Testcase: map-reduce</a></li></ol></li><li class="chapter-item "><a href="std_misc/channels.html"><strong aria-hidden="true">20.2.</strong> Channels</a></li><li class="chapter-item "><a href="std_misc/path.html"><strong aria-hidden="true">20.3.</strong> Path</a></li><li class="chapter-item "><a href="std_misc/file.html"><strong aria-hidden="true">20.4.</strong> File I/O</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std_misc/file/open.html"><strong aria-hidden="true">20.4.1.</strong> open</a></li><li class="chapter-item "><a href="std_misc/file/create.html"><strong aria-hidden="true">20.4.2.</strong> create</a></li><li class="chapter-item "><a href="std_misc/file/read_lines.html"><strong aria-hidden="true">20.4.3.</strong> read lines</a></li></ol></li><li class="chapter-item "><a href="std_misc/process.html"><strong aria-hidden="true">20.5.</strong> Child processes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std_misc/process/pipe.html"><strong aria-hidden="true">20.5.1.</strong> Pipes</a></li><li class="chapter-item "><a href="std_misc/process/wait.html"><strong aria-hidden="true">20.5.2.</strong> Wait</a></li></ol></li><li class="chapter-item "><a href="std_misc/fs.html"><strong aria-hidden="true">20.6.</strong> Filesystem Operations</a></li><li class="chapter-item "><a href="std_misc/arg.html"><strong aria-hidden="true">20.7.</strong> Program arguments</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std_misc/arg/matching.html"><strong aria-hidden="true">20.7.1.</strong> Argument parsing</a></li></ol></li><li class="chapter-item "><a href="std_misc/ffi.html"><strong aria-hidden="true">20.8.</strong> Foreign Function Interface</a></li></ol></li><li class="chapter-item "><a href="testing.html"><strong aria-hidden="true">21.</strong> Testing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="testing/unit_testing.html"><strong aria-hidden="true">21.1.</strong> Unit testing</a></li><li class="chapter-item "><a href="testing/doc_testing.html"><strong aria-hidden="true">21.2.</strong> Documentation testing</a></li><li class="chapter-item "><a href="testing/integration_testing.html"><strong aria-hidden="true">21.3.</strong> Integration testing</a></li><li class="chapter-item "><a href="testing/dev_dependencies.html"><strong aria-hidden="true">21.4.</strong> Dev-dependencies</a></li></ol></li><li class="chapter-item "><a href="unsafe.html"><strong aria-hidden="true">22.</strong> Unsafe Operations</a></li><li class="chapter-item "><a href="compatibility.html"><strong aria-hidden="true">23.</strong> Compatibility</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="compatibility/raw_identifiers.html"><strong aria-hidden="true">23.1.</strong> Raw identifiers</a></li></ol></li><li class="chapter-item "><a href="meta.html"><strong aria-hidden="true">24.</strong> Meta</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="meta/doc.html"><strong aria-hidden="true">24.1.</strong> Documentation</a></li><li class="chapter-item "><a href="meta/playpen.html"><strong aria-hidden="true">24.2.</strong> Playpen</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Rust By Example</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="예제로-배우는-rust"><a class="header" href="#예제로-배우는-rust">예제로 배우는 Rust</a></h1>
<p><a href="https://www.rust-lang.org/">Rust</a>는 안정성, 속도, 동시성에 초점을 둔 모던 프로그래밍 언어입니다.
가비지 컬렉션 없이 메모리 안전성을 보장함으로써 이 모든 목표를 달성합니다.</p>
<p>예제로 배우는 Rust(Rust by Example, RBE)는 직접 실행해볼 수 있는 예제들을 모아 러스트의 다양한 개념과 표준 라이브러리를 설명합니다. 더 많은 예제를 원하신다면 <a href="https://www.rust-lang.org/tools/install">직접 러스트를 설치해서</a>, <a href="https://doc.rust-lang.org/std/">공식 문서</a>를 살펴보세요. 궁금한 점이 있다면 <a href="https://github.com/rust-lang/rust-by-example">이 사이트의 소스 코드</a>를 직접 확인하실 수도 있습니다.</p>
<p>이제 시작해봅시다!</p>
<ul>
<li>
<p><a href="hello.html">Hello World</a> - 시작은 언제나의 Hello World 프로그램입니다.</p>
</li>
<li>
<p><a href="primitives.html">기본 요소</a> - 부호 정수, 부호 없는 정수 등의 기본 요소를 배웁니다.</p>
</li>
<li>
<p><a href="custom_types.html">커스텀 타입</a> - <code>struct</code>, <code>enum</code></p>
</li>
<li>
<p><a href="variable_bindings.html">변수 바인딩</a> - 가변 변수 바인딩, 스코프, 변수 가리기</p>
</li>
<li>
<p><a href="types.html">타입</a> - 타입 정의 및 변환을 배웁니다.</p>
</li>
<li>
<p><a href="conversion.html">형변환</a></p>
</li>
<li>
<p><a href="expression.html">표현식</a></p>
</li>
<li>
<p><a href="flow_control.html">흐름 제어</a> - <code>if</code>/<code>else</code>, <code>for</code> 등</p>
</li>
<li>
<p><a href="fn.html">함수</a> - 메소드, 클로저, 고차 함수를 배웁니다.</p>
</li>
<li>
<p><a href="mod.html">모듈</a> - 모듈을 이용한 코드 조직화</p>
</li>
<li>
<p><a href="crates.html">Crate(크레이트)</a> - 크레이트는 러스트의 컴파일 단위입니다. 라이브러리 제작을 배웁니다.</p>
</li>
<li>
<p><a href="cargo.html">Cargo</a> - 러스트 공식 패키지 관리 툴 기본 기능을 살펴봅니다.</p>
</li>
<li>
<p><a href="attribute.html">Attributes</a> - An attribute is metadata applied to some module, crate or item.</p>
</li>
<li>
<p><a href="generics.html">제네릭</a> - 다양한 타입의 인자로 작동하는 함수나 데이터 형식을 작성하는 방법을 배웁니다.</p>
</li>
<li>
<p><a href="scope.html">범위 규칙</a> - 범위는 소유권, borrowing, 라이프타임에서 중요한 역할을 합니다.</p>
</li>
<li>
<p><a href="trait.html">Trait(트레잇)</a> - 트레잇은 <code>Self</code> 라는 알 수 없는 타입에 정의된 메소드의 집합입니다.</p>
</li>
<li>
<p><a href="macros.html">매크로</a></p>
</li>
<li>
<p><a href="error.html">에러 처리</a> - 러스트의 에러 처리 방식을 배웁니다.</p>
</li>
<li>
<p><a href="std.html">표준 라이브러리 타입</a> - <code>std</code> 라이브러리에서 제공하는 커스텀 타입의 일부를 알아봅니다.</p>
</li>
<li>
<p><a href="std_misc.html">Std misc</a> - 파일 처리, 스레드용 커스텀 타입도 있답니다.</p>
</li>
<li>
<p><a href="testing.html">테스트</a> - 러스트의 온갖 종류 테스트</p>
</li>
<li>
<p><a href="unsafe.html">Unsafe 연산</a></p>
</li>
<li>
<p><a href="compatibility.html">호환성</a></p>
</li>
<li>
<p><a href="meta.html">개발 외</a> - 문서화, 벤치마킹</p>
</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h1>
<p>다음은 러스트로 작성한 Hello World 프로그램 소스 코드입니다.</p>
<pre><pre class="playground"><code class="language-rust editable">// 이건 주석입니다. 주석은 프로그램에 영향을 주지 않습니다.
// 우측 상단의 'Run this code' 버튼을 클릭하면 여러분이 직접 이 코드를 실행해볼 수 있습니다.
// 키보드 단축키는 'Ctrl + Enter'입니다.

// 이 코드는 자유롭게 수정할 수 있습니다. 마음대로 가지고 놀아보세요!
// 우측 상단의 'Undo Changes' 버튼을 클릭하면 원래 코드로 되돌릴 수 있습니다.

// 메인 함수입니다.
fn main() {
    // 컴파일된 바이너리가 호출될 때 이곳에 작성된 구문이 실행됩니다.

    // 콘솔에 텍스트를 출력합니다.
    println!(&quot;Hello World!&quot;);
}
</code></pre></pre>
<p><code>println!</code>는 콘솔에 텍스트를 출력하는
<a href="macros.html"><strong>매크로</strong></a>입니다.</p>
<p>프로그램 바이너리는 러스트 컴파일러(<code>rustc</code>)로 생성할 수 있습니다.</p>
<pre><code class="language-bash">$ rustc hello.rs
</code></pre>
<p><code>rustc</code> 명령어는 실행 가능한 <code>hello</code> 바이너리를 생성합니다.</p>
<pre><code class="language-bash">$ ./hello
Hello World!
</code></pre>
<h3 id="실습"><a class="header" href="#실습">실습</a></h3>
<p>실행 버튼을 클릭하면 어떤 결과가 나오는지 살펴보셨나요?
<code>println!</code> 매크로 한 줄을 새로 추가해 다음 결과가 나오도록
만들어보세요!</p>
<pre><code class="language-text">Hello World!
I'm a Rustacean!
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="주석"><a class="header" href="#주석">주석</a></h1>
<p>모든 프로그램에는 주석이 필요합니다.
러스트는 여러 종류 주석을 지원합니다.</p>
<ul>
<li><strong>일반 주석</strong>은 소스 코드를 읽는 사람을 위한 내용입니다. 컴파일러는 일반 주석의 내용을 무시합니다.
<ul>
<li><code>// 한 줄을 주석 처리합니다.</code></li>
<li><code>/* 닫는 기호 전까지의 내용을 블록 주석 처리합니다 */</code></li>
</ul>
</li>
<li><strong>문서화 주석</strong>은 <a href="hello/../meta/doc.html">문서(Docmumentation)</a>라는
HTML 문서로 변환됩니다.
<ul>
<li><code>/// 이 주석에 따라붙는 요소를 문서화합니다.</code></li>
<li><code>//! 이 주석을 포함하는 요소를 문서화합니다.</code></li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    // 한 줄 주석 예시입니다.
    // 각 줄은 슬래시 두 개로 시작합니다.
    // 컴파일러는 여기에 적힌 내용을 처리하지 않습니다.

    // println!(&quot;Hello, world!&quot;);

    // 이 코드를 실행해보세요. Hello, world!가 출력되나요? 아무것도 출력되지 않는다면, 윗 줄의 슬래시 두 개를 지우고 다시 실행해보세요!

    /* 
     * 이건 블록 주석입니다.
     * 일반적으로 주석을 작성할 땐 한 줄 주석을 권장하지만,
     * 블록 주석은 여러 줄의 코드를 임시로 무효화할때 굉장히 유용합니다.
     * /* 블록 주석은 /* 중첩 가능합니다. */ */
     * 현재 main() 함수 내 모든 코드를 주석 처리하는 것도 키보드를 단 몇 번만 타이핑하면 됩니다.
     * /*/*/* 직접 해보세요! */*/*/
     */

    /*
    Note: 윗 문단의 `*`는 양식을 맞추기 위해 넣은 기호입니다.
    실제로는 없어도 됩니다.
    */

    // 표현식을 다룰 때 블록 주석을 응용할 수도 있습니다.
    // 다음 구문에서 주석 기호를
    // 제거해보세요.
    let x = 5 + /* 90 + */ 5;
    println!(&quot;`x`는 10일까요, 100일까요? x = {}&quot;, x);
}

</code></pre></pre>
<h3 id="see-also"><a class="header" href="#see-also">See also:</a></h3>
<p><a href="hello/../meta/doc.html">라이브러리 문서화</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="출력-포맷팅"><a class="header" href="#출력-포맷팅">출력 포맷팅</a></h1>
<p>출력은 <a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a>에 정의된 <a href="hello/../macros.html"><code>매크로</code></a>를 이용합니다.</p>
<ul>
<li><code>format!</code>: 작성한 포맷팅대로 <a href="hello/../std/str.html"><code>String</code></a>을 생성합니다.</li>
<li><code>print!</code>: <code>format!</code>과 동일하지만, 문자열을 콘솔(io::stdout)로 출력합니다.</li>
<li><code>println!</code>: <code>print!</code>와 동일하지만, 줄바꿈이 추가됩니다.</li>
<li><code>eprint!</code>: <code>format!</code>과 동일하지만, 문자열을 표준 에러(io::stderr)로 출력합니다.</li>
<li><code>eprintln!</code>: <code>eprint!</code>와 동일하지만, 줄바꿈이 추가됩니다.</li>
</ul>
<p>문자열을 구문 분석하는 방법은 모두 동일합니다.
여담으로, 러스트는 컴파일타임에 포맷팅이 올바르게 작성됐는지 검사합니다.</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    // `{}`는 문자열화된 인수로 자동 대체됩니다.
    println!(&quot;{}일&quot;, 31);

    // 접미사를 따로 붙이지 않으면 31는 i32 타입으로 지정됩니다.
    // 접미사를 붙이면 원하는 타입으로 변경할 수 있습니다. (31i64는 i64타입이 됩니다.)

    // 필요하다면 다양한 패턴을 사용할 수 있습니다.
    // 위치 지정 인수 사용 예시입니다.
    println!(&quot;{0} 님, 이분은 {1} 님입니다. {1} 님, 이분은 {0} 님입니다.&quot;, &quot;홍길동&quot;, &quot;김철수&quot;);

    // 명명 인수 사용 예시입니다.
    println!(&quot;{subject} {object} {verb}&quot;,
             object=&quot;헌 쳇바퀴에&quot;,
             subject=&quot;다람쥐&quot;,
             verb=&quot;타고파&quot;);

    // 특수 포맷팅은 `:`에 붙여서 명시합니다.
    println!(&quot;사람들 중 {}/{:b} 은 이진법을 알고 있으며, 나머지 절반은 모릅니다.&quot;, 1, 2);

    // 지정한 길이 내 문자열을 우측 정렬합니다.
    // 공백 5칸과 &quot;1&quot; 이 붙은 &quot;     1&quot; 을 출력합니다.
    println!(&quot;{number:&gt;width$}&quot;, number=1, width=6);

    // 0으로 나머지 숫자를 채웁니다. &quot;000001&quot; 을 출력합니다.
    println!(&quot;{number:0&gt;width$}&quot;, number=1, width=6);

    // 러스트는 사용된 인수의 개수가 틀리지 않았는지 검사합니다.
    println!(&quot;제 이름은 {0}, {1} {0}입니다.&quot;, &quot;홍&quot;);
    // 고쳐주세요! ^ 인수에 &quot;길동&quot;을 추가해주세요

    // `i32` 값을 갖는 `Structure` 구조체를 생성합니다.
    #[allow(dead_code)]
    struct Structure(i32);

    // 안타깝게도, 구조체같은 사용자 정의 타입은 다루기 좀 까다롭습니다.
    // 다음 코드는 작동하지 않습니다.
    println!(&quot;이 구조체는 출력할 수 없어요... `{}`&quot;, Structure(3));
    // 고쳐주세요! ^ 이 줄을 주석 처리해주세요
}
</code></pre></pre>
<p><a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a>에는 문자열 출력을 제어하는 여러 <a href="https://doc.rust-lang.org/std/fmt/#formatting-traits"><code>트레잇</code></a>이 있습니다.
두 가지 중요한 트레잇의 기본 형태는 다음과 같습니다.</p>
<ul>
<li><code>fmt::Debug</code>: <code>{:?}</code>로 표시합니다. 문자열을 디버깅하기 좋은 형태로 포맷팅합니다.</li>
<li><code>fmt::Display</code>: <code>{}</code>로 표시합니다. 문자열을 사용자가 보기 좋게 포맷팅합니다.</li>
</ul>
<p>기본 타입들은 표준 라이브러리에서 <code>fmt::Display</code> 트레잇을 구현해두었습니다.
따라서 기본 타입은 별도의 작업 없이 바로 <code>{}</code> 로 포맷팅할 수 있지만, 사용자 정의 타입은 추가 작업이 필요합니다</p>
<p><code>fmt::Display</code> 트레잇을 구현하면 <a href="https://doc.rust-lang.org/std/string/trait.ToString.html"><code>ToString</code></a> 트레잇이 자동으로 구현되어
해당 타입을 <a href="hello/../std/str.html"><code>String</code></a>으로 <a href="hello/../conversion/string.html">변환</a>할 수 있습니다.</p>
<h3 id="실습-1"><a class="header" href="#실습-1">실습</a></h3>
<ul>
<li>앞선 코드의 문제점('고쳐주세요!'로 표시)을 수정하여 오류 없이
실행되도록 만들어보세요.</li>
<li><code>Pi는 약 3.142입니다</code>를 출력하는 <code>println!</code> 매크로를 추가해보세요.
<code>let pi = 3.141592</code> 코드로 원주율을 계산하고, 표시할 소수점 자리수를
조정하세요. (힌트: 표시할 소수점 자리수를 지정하는 방법은
<a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a>에서 찾아볼 수 있습니다)</li>
</ul>
<h3 id="see-also-1"><a class="header" href="#see-also-1">See also:</a></h3>
<p><a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a>, <a href="hello/../macros.html"><code>macros</code></a>, <a href="hello/../custom_types/structs.html"><code>struct</code></a>,
and <a href="https://doc.rust-lang.org/std/fmt/#formatting-traits"><code>traits</code></a></p>
<p><a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a>, <a href="hello/../macros.html"><code>매크로</code></a>, <a href="hello/../custom_types/structs.html"><code>구조체</code></a>,
<a href="https://doc.rust-lang.org/std/fmt/#formatting-traits"><code>트레잇</code></a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="debug"><a class="header" href="#debug">Debug</a></h1>
<p>출력 구현체가 존재하지 않는 타입에는 <code>std::fmt</code> 포맷팅 트레잇을
사용할 수 없습니다. 러스트가 자동으로 구현체를 제공하는 타입은
<code>std</code> 라이브러리 내 타입뿐입니다. 그 외에는 전부 어떤 형태로건
<strong>직접</strong> 구현해야 합니다.</p>
<p>이 문제는 <code>fmt::Debug</code> 트레잇으로 쉽게 해결할 수 있습니다.
<strong>모든</strong> 타입은 <code>fmt::Debug</code> 트레잇을 <code>derive</code> 하여 구현체를 자동으로 생성할 수 있습니다.
이는 <code>fmt::Display</code> 트레잇에는 해당되지 않습니다. <code>fmt::Display</code> 트레잇은 반드시 직접 구현해야합니다.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 이 구조체는 `fmt::Display`로 출력할 수 없으며,
// `fmt::Debug`로도 출력할 수 없습니다.
struct UnPrintable(i32);

// 다음 `derive` 속성은 이 구조체가 `fmt::Debug`로 출력될 수 있도록
// 구현체를 자동으로 생성합니다.
#[derive(Debug)]
struct DebugPrintable(i32);
<span class="boring">}
</span></code></pre></pre>
<p><code>std</code> 라이브러리 내 타입은 <code>{:?}</code> 로도 출력할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable">// `Structure` 구조체에 `fmt::Debug` 구현체를 derive 합니다.
// `Structure` 구조체는 `i32` 값 하나를 포함합니다.
#[derive(Debug)]
struct Structure(i32);

// `Structure`를 `Deep` 구조체에 집어넣고,
// `Deep` 구조체도 출력 가능하게 만듭니다.
#[derive(Debug)]
struct Deep(Structure);

fn main() {
    // `{:?}` 출력은 `{}`와 비슷합니다.
    println!(&quot;1년은 {:?}개월입니다.&quot;, 12);
    println!(&quot;{1:?} {0:?}는 {actor:?} 이름입니다.&quot;,
             &quot;슬레이터(Slater)&quot;,
             &quot;크리스찬(Christian)&quot;,
             actor=&quot;배우&quot;);

    // `Structure`는 출력 가능합니다.
    println!(&quot;이제 {:?}(을)를 출력할 수 있습니다!&quot;, Structure(3));
    
    // `derive`의 문제점은 출력 결과의 형태를 조정할 수 없다는 점입니다.
    // 단순히 `7` 만 출력하려면 어떻게 해야 할까요?
    println!(&quot;이제 {:?}(을)를 출력할 수 있습니다!&quot;, Deep(Structure(7)));
}
</code></pre></pre>
<p><code>fmt::Debug</code>를 이용해 출력할 수 없던 것을 출력 가능하게 만들어보았습니다.
단정한 형태의 출력을 원하면 <code>{:#?}</code>를 사용해 예쁘게 출력할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Person&lt;'a&gt; {
    name: &amp;'a str,
    age: u8
}

fn main() {
    let name = &quot;Peter&quot;;
    let age = 27;
    let peter = Person { name, age };

    // 예쁘게 출력하기
    println!(&quot;{:#?}&quot;, peter);
}
</code></pre></pre>
<p>출력 형태를 원하는 대로 조정하려면 <code>fmt::Display</code>를 직접 구현해야 합니다.</p>
<h3 id="see-also-2"><a class="header" href="#see-also-2">See also:</a></h3>
<p><a href="https://doc.rust-lang.org/reference/attributes.html"><code>attributes</code></a>, <a href="hello/print/../../trait/derive.html"><code>derive</code></a>, <a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a>, <a href="hello/print/../../custom_types/structs.html"><code>구조체</code></a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="display"><a class="header" href="#display">Display</a></h1>
<p><code>fmt::Debug</code>로는 간결하고 깔끔한 출력을 만들기 어렵습니다.
출력 형태를 원하는대로 바꾸기 위해선 <a href="https://doc.rust-lang.org/std/fmt/"><code>fmt::Display</code></a>(출력 시 <code>{}</code>로 표시)를 직접 구현해야 합니다.
구현 방법은 다음과 같습니다.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `use` 키워드로`fmt` 모듈을 가져옵니다.
use std::fmt;

// `fmt::Display`를 구현할 구조체를 정의합니다.
// `Structure`는 `i32` 값을 갖는 튜플 구조체입니다.
struct Structure(i32);

// `{}` 표시자는 `fmt::Display` 트레잇을 구현하는
// 타입으로만 사용할 수 있습니다.
impl fmt::Display for Structure {
    // Display 트레잇의 정확한 시그니처에선 `fmt`를 사용합니다
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        // 제공된 출력 스트림 `f`에 첫 번째 요소를 작성합니다.
        // 반환하는 `fmt::Result`는 연산의 성공 여부를 나타냅니다.
        // `write!` 사용 문법은 `println!`과 굉장히 유사하다는 점을
        // 기억해두세요.
        write!(f, &quot;{}&quot;, self.0)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>fmt::Display</code>는 <code>fmt::Debug</code>보다 깔끔합니다. 하지만, 오히려 깔끔하기 때문에  <code>std</code> 라이브러리는 <code>fmt::Display</code> 기본 구현을 제공하지 않습니다.
타입의 출력 형태를 정하기가 애매하기 때문입니다.
예를 들어, 만약 <code>std</code> 라이브러리에서 <code>Vec&lt;T&gt;</code> 타입의 출력을 구현한다면, 어떤 형태로 출력되도록 구현해야 할까요? 다음 두 가지 중 하나일까요?</p>
<ul>
<li><code>Vec&lt;path&gt;</code>: <code>/:/etc:/home/username:/bin</code> (<code>:</code>로 구분)</li>
<li><code>Vec&lt;number&gt;</code>: <code>1,2,3</code> (<code>,</code>로 구분)</li>
</ul>
<p>모든 타입에 어울리는 이상적인 형태는 존재하지 않습니다.
따라서 <code>std</code> 라이브러리는 함부로 <code>Vec&lt;T&gt;</code> 등의 기본 제네릭 컨테이너에 <code>fmt::Display</code>를 구현하지 않습니다.
기본 제네릭 컨테이너에는 <code>fmt::Debug</code>를 사용해야 합니다.</p>
<p>표준 라이브러리의 기본 제네릭 컨테이너가 <strong>아닌</strong>,
새로 만든 <strong>컨테이너</strong> 타입에는 문제 없이 <code>fmt::Display</code>를 구현할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::fmt; // `fmt`를 가져옵니다.

// 두 숫자를 보관하는 구조체입니다. `Display` 결과와 비교하기 위해
// `Debug`를 derive합니다.
#[derive(Debug)]
struct MinMax(i64, i64);

// `MinMax`에 `Display`를 구현합니다.
impl fmt::Display for MinMax {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        // `self.숫자`는 각 위치의 데이터를 가리킵니다.
        write!(f, &quot;({}, {})&quot;, self.0, self.1)
    }
}

// 비교를 위해, 필드에 이름을 붙인 구조체를 정의합니다.
#[derive(Debug)]
struct Point2D {
    x: f64,
    y: f64,
}

// 마찬가지로 `Point2D`에도 `Display`를 구현합니다.
impl fmt::Display for Point2D {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        // `x`, `y`만 표시하도록 합니다.
        write!(f, &quot;x: {}, y: {}&quot;, self.x, self.y)
    }
}

fn main() {
    let minmax = MinMax(0, 14);

    println!(&quot;구조체 비교&quot;);
    println!(&quot;Display: {}&quot;, minmax);
    println!(&quot;Debug: {:?}&quot;, minmax);

    let big_range =   MinMax(-300, 300);
    let small_range = MinMax(-3, 3);

    println!(&quot;큰 범위는 {big}이며, 작은 범위는 {small}입니다.&quot;,
             small = small_range,
             big = big_range);

    let point = Point2D { x: 3.3, y: 7.2 };

    println!(&quot;Point 비교&quot;);
    println!(&quot;Display: {}&quot;, point);
    println!(&quot;Debug: {:?}&quot;, point);

    // 다음 줄은 작동하지 않습니다. `Debug`, `Display`를 모두 구현하더라도
    // `{:b}`는 `fmt::Binary`가 구현되어야 작동하기 때문입니다.
    // println!(&quot;Point2D를 이진법으로 나타내면 어떤 모습일까요? {:b}?&quot;, point);
}
</code></pre></pre>
<p><code>fmt::Display</code>를 구현한다고 해서 만사가 해결되는건 아닙니다.
만약 바이너리 출력을 사용하려면, <code>fmt::Binary</code>를 구현해야합니다.
바이너리 이외에도 각각 따로 구현해야하는 <code>std::fmt</code> <a href="https://doc.rust-lang.org/std/fmt/#formatting-traits"><code>트레잇</code></a>은 여럿 있습니다.
(자세한 내용은 <a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a>를 찾아보세요.)</p>
<h3 id="실습-2"><a class="header" href="#실습-2">실습</a></h3>
<p>앞선 예제에서 어떤 출력이 나오는지 확인해보았다면, <code>Point2D</code> 구조체 정의 예시 삼아
<code>Complex</code> 구조체를 추가해보세요. 동일한 방식으로 출력하여 다음과 같은 결과가 나와야합니다.</p>
<pre><code class="language-txt">Display: 3.3 + 7.2i
Debug: Complex { real: 3.3, imag: 7.2 }
</code></pre>
<h3 id="see-also-3"><a class="header" href="#see-also-3">See also:</a></h3>
<p><a href="hello/print/../../trait/derive.html"><code>derive</code></a>, <a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a>, <a href="hello/print/../../macros.html"><code>매크로</code></a>, <a href="hello/print/../../custom_types/structs.html"><code>구조체</code></a>,
<a href="https://doc.rust-lang.org/std/fmt/#formatting-traits"><code>트레잇</code></a>, <a href="hello/print/../../mod/use.html"><code>use</code></a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="testcase-list"><a class="header" href="#testcase-list">Testcase: List</a></h1>
<p>순차적인 요소들을 처리하는 구조체에 <code>fmt::Display</code>를 구현하는 건 까다롭습니다.
각 <code>write!</code> 마다 <code>fmt::Result</code> 를 생성하는데, 이를 <strong>전부</strong> 알맞게
처리해야하기 때문입니다.
러스트에서 제공하는 <code>?</code> 연산자는 이런 경우에 딱 알맞습니다.</p>
<p><code>write!</code>에서 <code>?</code> 연산자를 사용한 모습은 다음과 같습니다.</p>
<pre><code class="language-rust ignore">// `write!`를 시도하여 에러가 있는지 확인합니다.
// 에러가 발생하면 해당 에러를 반환하고, 발생하지 않으면 계속 진행합니다.
write!(f, &quot;{}&quot;, value)?;
</code></pre>
<p><code>Vec</code> 타입에 <code>fmt::Display</code>를 구현하는 것도 <code>?</code> 연산자를 사용하면
간단합니다.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::fmt; // `fmt`를 가져옵니다.

// `Vec` 타입을 보관하는 `List` 구조체를 정의합니다.
struct List(Vec&lt;i32&gt;);

impl fmt::Display for List {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        // 튜플 인덱싱 문법으로 값을 추출하고
        // `vec`에 대한 참조자를 생성합니다.
        let vec = &amp;self.0;

        write!(f, &quot;[&quot;)?;

        // 반복자 `v`로 `vec`을 순회하며 반복 횟수를
        // `count`로 열거합니다.
        for (count, v) in vec.iter().enumerate() {
            // 첫 번째 요소 이외에는 쉼표를 추가합니다.
            // 에러일 경우 반환하기 위해 `?` 연산자를 사용합니다.
            if count != 0 { write!(f, &quot;, &quot;)?; }
            write!(f, &quot;{}&quot;, v)?;
        }

        // 대괄호를 닫고 fmt::Result 값을 반환합니다.
        write!(f, &quot;]&quot;)
    }
}

fn main() {
    let v = List(vec![1, 2, 3]);
    println!(&quot;{}&quot;, v);
}
</code></pre></pre>
<h3 id="실습-3"><a class="header" href="#실습-3">실습</a></h3>
<p>프로그램을 수정해서 각 요소의 인덱스 번호도 출력하도록 만들어보세요. 출력 예시는 다음과 같습니다.</p>
<pre><code class="language-rust ignore">[0: 1, 1: 2, 2: 3]
</code></pre>
<h3 id="see-also-4"><a class="header" href="#see-also-4">See also:</a></h3>
<p><a href="hello/print/print_display/../../../flow_control/for.html"><code>for</code></a>, <a href="hello/print/print_display/../../../scope/borrow/ref.html"><code>ref</code></a>, <a href="hello/print/print_display/../../../std/result.html"><code>Result</code></a>, <a href="hello/print/print_display/../../../custom_types/structs.html"><code>struct</code></a>,
<a href="hello/print/print_display/../../../std/result/question_mark.html"><code>?</code></a>, <a href="hello/print/print_display/../../../std/vec.html"><code>vec!</code></a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="포맷팅"><a class="header" href="#포맷팅">포맷팅</a></h1>
<p>앞서 봤듯, 포맷팅은 <strong>포맷 문자열(format string)</strong> 로 명시합니다.</p>
<ul>
<li><code>format!(&quot;{}&quot;, foo)</code> -&gt; <code>&quot;3735928559&quot;</code></li>
<li><code>format!(&quot;0x{:X}&quot;, foo)</code> -&gt;
<a href="https://en.wikipedia.org/wiki/Deadbeef#Magic_debug_values"><code>&quot;0xDEADBEEF&quot;</code></a></li>
<li><code>format!(&quot;0o{:o}&quot;, foo)</code> -&gt; <code>&quot;0o33653337357&quot;</code></li>
</ul>
<p>똑같은 <code>foo</code> 변수를 <strong>인수 형식(argument type)</strong> 에 따라 다르게 포맷팅할 수 있습니다.
각각 <code>X</code>, <code>o</code>, <strong>명시되지 않은</strong> 인수 형식을 사용했습니다.</p>
<p>포맷팅 기능은 여러 트레잇으로 구현되어 있으며, 각각의 트레잇이 인수 형식에 하나씩 대응합니다.
가장 보편적인 포맷팅 트레잇은 <code>Display</code> 트레잇입니다.
<code>Display</code> 트레잇은 명시되지 않은 인수 형식(<code>{}</code>)을 처리합니다.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::fmt::{self, Formatter, Display};

struct City {
    name: &amp;'static str,
    // 위도(Latitude)
    lat: f32,
    // 경도(Longitude)
    lon: f32,
}

impl Display for City {
    // `f`는 버퍼입니다. fmt 메소드는 포맷 스트링을 `f` 버퍼에 작성해야 합니다.
    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; fmt::Result {
        let lat_c = if self.lat &gt;= 0.0 { 'N' } else { 'S' };
        let lon_c = if self.lon &gt;= 0.0 { 'E' } else { 'W' };

        // `write!`은 `format!`과 비슷하지만, 첫 번째 인수인 버퍼에
        // 포맷 스트링을 작성한다는 차이점이 있습니다.
        write!(f, &quot;{}: {:.3}°{} {:.3}°{}&quot;,
               self.name, self.lat.abs(), lat_c, self.lon.abs(), lon_c)
    }
}

#[derive(Debug)]
struct Color {
    red: u8,
    green: u8,
    blue: u8,
}

fn main() {
    for city in [
        City { name: &quot;더블린&quot;, lat: 53.347778, lon: -6.259722 },
        City { name: &quot;오슬로&quot;, lat: 59.95, lon: 10.75 },
        City { name: &quot;밴쿠버&quot;, lat: 49.25, lon: -123.1 },
    ].iter() {
        println!(&quot;{}&quot;, *city);
    }
    for color in [
        Color { red: 128, green: 255, blue: 90 },
        Color { red: 0, green: 3, blue: 254 },
        Color { red: 0, green: 0, blue: 0 },
    ].iter() {
        // fmt::Display를 구현하고 나면 이 부분을 {}로 변경하세요.
        println!(&quot;{:?}&quot;, *color);
    }
}
</code></pre></pre>
<p>더 자세히 알아보고 싶다면 <a href="https://doc.rust-lang.org/std/fmt/#formatting-traits">전체 포맷팅 트레잇 목록</a>이나
<a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a> 문서에서 포맷팅 인수 형식을 살펴볼 수 있습니다.</p>
<h3 id="실습-4"><a class="header" href="#실습-4">실습</a></h3>
<p>앞선 코드의 <code>Color</code> 구조체에 <code>fmt::Display</code> 트레잇을 구현하여
출력 결과가 다음과 같이 나타나도록 만들어보세요.</p>
<pre><code class="language-text">RGB (128, 255, 90) 0x80FF5A
RGB (0, 3, 254) 0x0003FE
RGB (0, 0, 0) 0x000000
</code></pre>
<p>막힐 때를 위해 힌트를 드리겠습니다.</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/fmt/#named-parameters">하나의 색깔을 여러 번 표시하는 방법</a>,</li>
<li><code>:02</code>를 사용하면 <a href="https://doc.rust-lang.org/std/fmt/#width">2칸 내 공백에 0을 채울 수 있습니다(Zero Padding).</a></li>
</ul>
<h3 id="see-also-5"><a class="header" href="#see-also-5">See also:</a></h3>
<p><a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="기본-요소"><a class="header" href="#기본-요소">기본 요소</a></h1>
<p>러스트는 다양한 기본 요소(primitives)를 제공합니다.
어떤 것들을 제공하는지 살펴보죠.</p>
<h3 id="스칼라-타입"><a class="header" href="#스칼라-타입">스칼라 타입</a></h3>
<ul>
<li>부호 있는 정수(signed integer): <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code> 및 <code>isize</code> (포인트 크기)</li>
<li>부호 없는 정수(unsigned integer): <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code> 및 <code>usize</code> (포인터 크기)</li>
<li>부동 소수점(floating point): <code>f32</code>, <code>f64</code></li>
<li><code>char</code> - <code>'a'</code>, <code>'α'</code>, <code>'∞'</code> (각각 4바이트) 등의 유니코드 스칼라 값</li>
<li><code>bool</code> - <code>true</code> 혹은 <code>false</code></li>
<li>유닛 타입 <code>()</code> - 빈 튜플(<code>()</code>) 값만을 의미하는 타입</li>
</ul>
<p>유닛 타입은 튜플이지만, 여러 값을 포함하지는 않기 때문에
복합 타입으로 간주하지 않습니다.</p>
<h3 id="복합-타입"><a class="header" href="#복합-타입">복합 타입</a></h3>
<ul>
<li>배열 (<code>[1, 2, 3]</code>)</li>
<li>튜플 (<code>(1, true)</code>)</li>
</ul>
<p>모든 변수에는 타입을 명시할 수 있습니다.
숫자는 접미사로도 타입을 명시할 수 있고, 아무것도 작성하지 않고 기본 타입을 이용할 수 있죠.
정수는 <code>i32</code> 타입, 소수는 <code>f64</code> 타입이 기본 타입입니다.
또한, 러스트는 코드 문맥에서 타입을 추론할 수도 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    // 변수에는 타입을 명시할 수 있습니다.
    let logical: bool = true;

    let a_float: f64 = 1.0;  // 일반적인 명시
    let an_integer   = 5i32; // 접미사 명시

    // 기본 타입을 사용할 수도 있습니다.
    let default_float   = 3.0; // `f64`
    let default_integer = 7;   // `i32`
    
    // 타입은 코드 문맥에서 추론될 수도 있습니다.
    let mut inferred_type = 12; // 다른 줄로 인해서 i64 타입으로 추론됩니다
    inferred_type = 4294967296i64;
    
    // 가변 변수 값은 변경 가능합니다.
    let mut mutable = 12; // 가변 `i32`
    mutable = 21;
    
    // 에러! 변수의 타입은 변경할 수 없습니다.
    mutable = true;
    
    // 변수는 가려질(shadowing) 수 있습니다.
    let mutable = true;
}
</code></pre></pre>
<h3 id="see-also-6"><a class="header" href="#see-also-6">See also:</a></h3>
<p><a href="https://doc.rust-lang.org/std/">the <code>std</code> library</a>, <a href="variable_bindings/mut.html"><code>mut</code></a>, <a href="types/inference.html"><code>inference</code></a>, <a href="variable_bindings/scope.html"><code>shadowing</code></a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="리터럴-연산자"><a class="header" href="#리터럴-연산자">리터럴, 연산자</a></h1>
<p>정수 <code>1</code>, 부동 소수점 <code>1.2</code>, 문자 <code>'a'</code>, 문자열 <code>&quot;abc&quot;</code>, boolean <code>true</code>,
유닛 타입 <code>()</code>은 리터럴로 표현할 수 있습니다.</p>
<p>정수는 <code>0x</code>, <code>0o</code>, <code>0b</code> 접두사를 사용해 각각 16진수, 8진수, 2진수로
표기할 수 있습니다.</p>
<p>숫자 리터럴에 언더스코어(<code>_</code>)를 추가하여 가독성을 높일 수도 있습니다.
<code>1_000</code>은 <code>1000</code>과 같고, <code>0.000_001</code>은 <code>0.000001</code>와 같습니다.</p>
<!-- 원문: We need to tell the compiler the type of the literals we use. -->
<p>원하는 타입의 리터럴을 사용하려면 컴파일러에게 타입을 알려주어야 합니다.
이번에는 부호 없는 32비트 정수 리터럴을 <code>u32</code> 접미사로 표시하고,
부호 있는 32비트 정수 리터럴을 <code>i32</code> 접미사로 표시하겠습니다.</p>
<p><a href="https://doc.rust-lang.org/reference/expressions.html#expression-precedence">러스트에서 사용 가능한 연산자와 연산자 우선 순위</a>는
다른 <a href="https://en.wikipedia.org/wiki/Operator_precedence#Programming_languages">C언어계 언어(C-like languages)</a>와 유사합니다.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    // 정수 덧셈
    println!(&quot;1 + 2 = {}&quot;, 1u32 + 2);

    // 정수 뺄셈
    println!(&quot;1 - 2 = {}&quot;, 1i32 - 2);
    // TODO ^  `1i32`를 `1u32`로 바꿔보면 타입이 중요한 이유를 알 수 있습니다.

    // boolean 논리 연산
    println!(&quot;true AND false = {}&quot;, true &amp;&amp; false);
    println!(&quot;true OR false = {}&quot;, true || false);
    println!(&quot;NOT true = {}&quot;, !true);

    // 비트 연산
    println!(&quot;0011 AND 0101 = {:04b}&quot;, 0b0011u32 &amp; 0b0101);
    println!(&quot;0011 OR 0101 = {:04b}&quot;, 0b0011u32 | 0b0101);
    println!(&quot;0011 XOR 0101 = {:04b}&quot;, 0b0011u32 ^ 0b0101);
    println!(&quot;1 &lt;&lt; 5 = {}&quot;, 1u32 &lt;&lt; 5);
    println!(&quot;0x80 &gt;&gt; 2 = 0x{:x}&quot;, 0x80u32 &gt;&gt; 2);

    // 언더스코어를 사용해 가독성을 높였습니다.
    println!(&quot;백만을 숫자로 쓰면 {}입니다&quot;, 1_000_000u32);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="튜플"><a class="header" href="#튜플">튜플</a></h1>
<p>튜플은 다양한 타입 값의 집합입니다.
튜플은 괄호를 사용해 생성하며, 각각의 튜플은 <code>(T1, T2, ...)</code>
(<code>T1</code>, <code>T2</code>은 구성 요소의 타입) 타입 시그니처 타입의 값입니다.
튜플은 여러 값을 포함할 수 있으므로 함수에서 튜플을 이용해 여러 값을 반환할 수도 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable">// 튜플은 함수 인수 및 반환 값으로 사용할 수 있습니다.
fn reverse(pair: (i32, bool)) -&gt; (bool, i32) {
    // `let` 구문으로 튜플의 구성 요소를 변수에 바인딩합니다.
    let (integer, boolean) = pair;

    (boolean, integer)
}

// 실습용 구조체입니다.
#[derive(Debug)]
struct Matrix(f32, f32, f32, f32);

fn main() {
    // 다양한 타입이 모인 튜플
    let long_tuple = (1u8, 2u16, 3u32, 4u64,
                      -1i8, -2i16, -3i32, -4i64,
                      0.1f32, 0.2f64,
                      'a', true);

    // 튜플 내 값은 튜플 인덱싱을 사용해 추출할 수 있습니다
    println!(&quot;long tuple 첫 번째 값: {}&quot;, long_tuple.0);
    println!(&quot;long tuple 두 번째 값: {}&quot;, long_tuple.1);

    // 튜플이 튜플의 구성요소가 될 수도 있습니다.
    let tuple_of_tuples = ((1u8, 2u16, 2u32), (4u64, -1i8), -2i16);

    // 튜플은 출력 가능합니다.
    println!(&quot;튜플로 만든 튜플: {:?}&quot;, tuple_of_tuples);
    
    // 하지만 긴 튜플은 출력할 수 없습니다.
    // let too_long_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13);
    // println!(&quot;너무 긴 튜플: {:?}&quot;, too_long_tuple);
    // TODO ^ 위 두 줄을 주석 해제하여 어떤 컴파일러 에러가 나타나는지 확인해보세요.

    let pair = (1, true);
    println!(&quot;쌍은 {:?}입니다.&quot;, pair);

    println!(&quot;뒤집은 쌍은 {:?}입니다.&quot;, reverse(pair));

    // 요소가 하나뿐인 튜플을 생성할 땐 괄호로 둘러싸인 리터럴과 구별하기 위해
    // 반드시 쉼표를 작성해야 합니다.
    println!(&quot;{:?}는 요소가 하나인 튜플입니다.&quot;, (5u32,));
    println!(&quot;{:?}는 그냥 숫자입니다.&quot;, (5u32));

    // 튜플을 해체하여 바인딩을 생성할 수 있습니다.
    let tuple = (1, &quot;hello&quot;, 4.5, true);

    let (a, b, c, d) = tuple;
    println!(&quot;{:?}, {:?}, {:?}, {:?}&quot;, a, b, c, d);

    let matrix = Matrix(1.1, 1.2, 2.1, 2.2);
    println!(&quot;{:?}&quot;, matrix);

}
</code></pre></pre>
<h3 id="실습-5"><a class="header" href="#실습-5">실습</a></h3>
<ol>
<li>
<p><strong>복습</strong>: 앞선 예제의 <code>Matrix</code> 구조체에 <code>fmt::Display</code> 트레잇을 구현해보세요.
출력 부분의 Debug 포맷팅(<code>{:?}</code>)을 Display 포맷팅(<code>{}</code>)으로 변경했을 때
다음과 같은 결과가 출력되어야 합니다.</p>
<pre><code class="language-text">( 1.1 1.2 )
( 2.1 2.2 )
</code></pre>
<p>필요하다면, 이전 <a href="primitives/../hello/print/print_display.html">Display 출력</a> 예제를 참고하세요.</p>
</li>
<li>
<p><code>reverse</code> 함수를 참고자료 삼아, matrix(행렬)를 인수로 받아
두 개의 요소를 교환하여 반환하는 <code>transpose</code> 함수를 추가해보세요.
예시는 다음과 같습니다.</p>
<pre><code class="language-rust ignore">println!(&quot;Matrix:\n{}&quot;, matrix);
println!(&quot;Transpose:\n{}&quot;, transpose(matrix));
</code></pre>
<p>다음은 출력 결과입니다.</p>
<pre><code class="language-text">Matrix:
( 1.1 1.2 )
( 2.1 2.2 )
Transpose:
( 1.1 2.1 )
( 1.2 2.2 )
</code></pre>
</li>
</ol>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="배열-슬라이스"><a class="header" href="#배열-슬라이스">배열, 슬라이스</a></h1>
<p>배열은 메모리에 연속적으로 저장된 동일한 <code>T</code> 타입 요소의 집합입니다.
배열은 대괄호 <code>[]</code>를 사용해 생성하며, 타입 시그니처 <code>[T; length]</code>의
일부인 배열 길이는 컴파일 타임에 알 수 있습니다.</p>
<p>슬라이스는 배열과 유사하지만, 슬라이스의 길이는 컴파일 타임에 알 수 없습니다.
슬라이스는 두 개의 word로 구성됩니다. 첫 번째 word는 데이터의 포인터이고,
두 번째 word는 슬라이스의 길이입니다.
word 크기는 <code>usize</code> 크기와 동일하게 프로세서 아키텍처(x86-64의 경우 64비트)에 의해 결정됩니다.
슬라이스는 배열의 일부를 borrow 하는 데에 사용할 수 있습니다. (타입 시그니처는 <code>&amp;[T]</code>입니다.)</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">use std::mem;

// 슬라이스를 borrow 하는 함수
fn analyze_slice(slice: &amp;[i32]) {
    println!(&quot;슬라이스 첫 번째 요소: {}&quot;, slice[0]);
    println!(&quot;슬라이스는 요소가 {}개 있습니다&quot;, slice.len());
}

fn main() {
    // 고정된 크기 배열 (타입 시그니처는 불필요합니다)
    let xs: [i32; 5] = [1, 2, 3, 4, 5];

    // 모든 요소를 같은 값으로 초기화
    let ys: [i32; 500] = [0; 500];

    // 인덱스는 0부터 시작합니다.
    println!(&quot;배열 첫 번째 요소: {}&quot;, xs[0]);
    println!(&quot;배열 두 번째 요소: {}&quot;, xs[1]);

    // `len` 함수는 배열 요소의 개수를 반환합니다.
    println!(&quot;배열 요소의 개수: {}&quot;, xs.len());

    // 배열은 스택에 할당됩니다.
    println!(&quot;배열은 {}바이트를 차지합니다&quot;, mem::size_of_val(&amp;xs));

    // 배열은 자동으로 슬라이스로 borrow 될 수 있습니다.
    println!(&quot;전체 배열을 슬라이스로 borrow 합니다&quot;);
    analyze_slice(&amp;xs);

    // 슬라이스는 [시작_인덱스..끝_인덱스] 형태로
    // 배열의 일부를 가리킬 수 있습니다.
    // 시작_인덱스는 슬라이스에 포함할 첫 번째 요소의 위치이고,
    // 끝_인덱스는 슬라이스에 포함할 마지막 위치에 1을 더한 위치입니다.
    println!(&quot;배열의 일부를 슬라이스로 borrow 합니다&quot;);
    analyze_slice(&amp;ys[1 .. 4]);

    // 인덱싱이 범위를 벗어나면 컴파일 에러가 발생합니다.
    println!(&quot;{}&quot;, xs[5]);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="커스텀-타입"><a class="header" href="#커스텀-타입">커스텀 타입</a></h1>
<p>러스트에서는 주로 다음 두 키워드로 커스텀 데이터 타입을 작성합니다.</p>
<ul>
<li><code>struct</code>: 구조체를 정의합니다.</li>
<li><code>enum</code>: 열거형을 정의합니다.</li>
</ul>
<p>상수는 <code>const</code>, <code>static</code> 키워드로 생성합니다.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="구조체"><a class="header" href="#구조체">구조체</a></h1>
<p><code>struct</code> 키워드로 만들 수 있는 구조체는 세 종류가 있습니다.</p>
<ul>
<li>튜플 구조체 - 간단하게, '이름이 있는 튜플'입니다.</li>
<li>전통 <a href="https://en.wikipedia.org/wiki/Struct_(C_programming_language)">C언어 구조체</a></li>
<li>유닛 구조체 - 필드가 없는 구조체입니다. 제네릭에 사용됩니다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Person {
    name: String,
    age: u8,
}

// 유닛 구조체
struct Unit;

// 튜플 구조체
struct Pair(i32, f32);

// 두 개의 필드를 가진 구조체
struct Point {
    x: f32,
    y: f32,
}

// 구조체는 또 다른 구조체의 필드가 될 수 있습니다.
#[allow(dead_code)]
struct Rectangle {
    // 사각형은 좌측 상단 꼭짓점과 우측 하단 꼭짓점이 공간의 어디에
    // 위치해 있는지로 나타낼 수 있습니다.
    top_left: Point,
    bottom_right: Point,
}

fn main() {
    // 필드 초기화 축약법으로 구조체를 생성합니다.
    let name = String::from(&quot;Peter&quot;);
    let age = 27;
    let peter = Person { name, age };

    // debug 출력으로 구조체를 출력합니다.
    println!(&quot;{:?}&quot;, peter);


    // `Point` 구조체 인스턴스를 생성합니다.
    let point: Point = Point { x: 10.3, y: 0.4 };

    // point 인스턴스의 필드에 접근합니다.
    println!(&quot;point 좌표: ({}, {})&quot;, point.x, point.y);

    // 구조체 갱신 문법을 사용해 기존 구조체 인스턴스의 필드로 새로운 구조체
    // 인스턴스를 생성합니다.
    let bottom_right = Point { x: 5.2, ..point };

    // `point`의 필드로 `bottom_right`를 생성했으므로,
    // `bottom_right.y`는 `point.y`와 같습니다.
    println!(&quot;두 번째 point 좌표: ({}, {})&quot;, bottom_right.x, bottom_right.y);

    // `let` 구문으로 point를 해체하여 바인딩합니다.
    let Point { x: top_edge, y: left_edge } = point;

    let _rectangle = Rectangle {
        // 구조체 인스턴스 생성문도 표현식입니다.
        top_left: Point { x: left_edge, y: top_edge },
        bottom_right: bottom_right,
    };

    // 유닛 구조체 생성문입니다.
    let _unit = Unit;

    // 튜플 구조체를 생성합니다.
    let pair = Pair(1, 0.1);

    // 튜플 구조체 필드에 접근합니다
    println!(&quot;pair에는 {:?}, {:?}이 들어있습니다&quot;, pair.0, pair.1);

    // 튜플 구조체를 해체합니다
    let Pair(integer, decimal) = pair;

    println!(&quot;pair에는 {:?}, {:?}이 들어있습니다&quot;, integer, decimal);
}
</code></pre></pre>
<h3 id="실습-6"><a class="header" href="#실습-6">실습</a></h3>
<ol>
<li>사각형의 면적을 계산하는 <code>react_area</code> 함수를 추가해보세요.
(중첩 해체 구문을 사용해보세요.)</li>
<li><code>Point</code>, <code>f32</code>를 매개변수로 전달받는 <code>square</code> 함수를 추가해보세요.
<code>Point</code>를 좌측 하단 꼭짓점으로 사용하고, <code>f32</code> 값을 너비, 높이로
사용하는 <code>Rectangle</code>을 반환해야합니다.</li>
</ol>
<h3 id="see-also-7"><a class="header" href="#see-also-7">See also</a></h3>
<p><a href="custom_types/../attribute.html"><code>attributes</code></a>, <a href="custom_types/../flow_control/match/destructuring.html">destructuring</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="열거형"><a class="header" href="#열거형">열거형</a></h1>
<p><code>enum</code> 키워드는 여러 variant(변종) 중 하나의 값이 될 수 있는 타입을 생성합니다.
구조체의 형태로 유효한 것은 열거형의 variant로도 유효합니다.</p>
<pre><pre class="playground"><code class="language-rust editable">// 웹 이벤트를 분류하는 열거형을 생성합니다.
// 열거형의 이름뿐만 아니라 variant를 어떤 방식으로 지정하는지도 유의해주세요.
// `PageLoad`는 `PageUnload`와 다르며, `KeyPress(char)`와 `Paste(String)` 또한 다릅니다.
// 각각의 variant는 모두 다르고 독립적입니다.
enum WebEvent {
    // 열거형은 종류만 지정할 수도 있으며(`unit-like`),
    PageLoad,
    PageUnload,
    // 튜플 구조체 같은 형태도 가능하고,
    KeyPress(char),
    Paste(String),
    // C언어식 구조체도 가능합니다.
    Click { x: i64, y: i64 },
}

// `WebEvent` 열거형을 인자로 전달받고 아무것도 반환하지 않는
// 함수입니다.
fn inspect(event: WebEvent) {
    match event {
        WebEvent::PageLoad =&gt; println!(&quot;페이지 로드됨&quot;),
        WebEvent::PageUnload =&gt; println!(&quot;페이지 언로드됨&quot;),
        // 열거형 값 안의 `c`를 해체합니다.
        WebEvent::KeyPress(c) =&gt; println!(&quot;'{}' 눌림&quot;, c),
        WebEvent::Paste(s) =&gt; println!(&quot;\&quot;{}\&quot; 붙여넣음&quot;, s),
        // `Click`을 `x`, `y`로 해체합니다.
        WebEvent::Click { x, y } =&gt; {
            println!(&quot;x={}, y={} 지점 클릭됨&quot;, x, y);
        },
    }
}

fn main() {
    let pressed = WebEvent::KeyPress('x');
    // 소유권을 갖는 `String`을 생성하기 위해 문자열 슬라이스로 `to_owned()`를 호출합니다.
    let pasted  = WebEvent::Paste(&quot;텍스트&quot;.to_owned());
    let click   = WebEvent::Click { x: 20, y: 80 };
    let load    = WebEvent::PageLoad;
    let unload  = WebEvent::PageUnload;

    inspect(pressed);
    inspect(pasted);
    inspect(click);
    inspect(load);
    inspect(unload);
}

</code></pre></pre>
<h2 id="타입-별칭"><a class="header" href="#타입-별칭">타입 별칭</a></h2>
<p>타입 별칭을 사용해, 열거형의 별칭으로 각 variant를 참조할 수 있습니다.
열거형의 이름이 너무 길거나, 오히려 너무 평범해서 이름을 바꾸고 싶을 때 유용합니다.</p>
<pre><pre class="playground"><code class="language-rust editable">enum VeryVerboseEnumOfThingsToDoWithNumbers {
    Add,
    Subtract,
}

// 타입 별칭을 생성합니다.
type Operations = VeryVerboseEnumOfThingsToDoWithNumbers;

fn main() {
    // 길고 불편한 이름 대신 별칭으로 각 variant를 참조합니다.
    let x = Operations::Add;
}
</code></pre></pre>
<p>여러분이 가장 자주 보게 될 타입 별칭은 <code>impl</code> 블록 내 <code>Self</code> 별칭입니다.</p>
<pre><pre class="playground"><code class="language-rust editable">enum VeryVerboseEnumOfThingsToDoWithNumbers {
    Add,
    Subtract,
}

impl VeryVerboseEnumOfThingsToDoWithNumbers {
    fn run(&amp;self, x: i32, y: i32) -&gt; i32 {
        match self {
            Self::Add =&gt; x + y,
            Self::Subtract =&gt; x - y,
        }
    }
}
</code></pre></pre>
<h3 id="see-also-8"><a class="header" href="#see-also-8">See also:</a></h3>
<p><a href="custom_types/../flow_control/match.html"><code>match</code></a>, <a href="custom_types/../fn.html"><code>fn</code></a>, <a href="custom_types/../std/str.html"><code>String</code></a>, <a href="https://rust-lang.github.io/rfcs/2338-type-alias-enum-variants.html">&quot;Type alias enum variants&quot; RFC</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="use"><a class="header" href="#use">use</a></h1>
<p><code>use</code> 구문으로 매번 스코프를 지정할 필요 없도록 만들 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable">// 사용하지 않은 코드(unused code) 경고를 숨기기 위한 속성입니다.
#![allow(dead_code)]

enum Status {
    Rich,
    Poor,
}

enum Work {
    Civilian,
    Soldier,
}

fn main() {
    // `use`를 명시하여, 스코프를 지정하지 않아도 되도록 만듭니다. 
    use crate::Status::{Poor, Rich};
    // `Work` 내 모든 이름을 `use` 합니다.
    use crate::Work::*;

    // `Status::Poor`과 동일합니다.
    let status = Poor;
    // `Work::Civilian`과 동일합니다.
    let work = Civilian;

    match status {
        // 앞서 `use`를 명시했으므로 스코프 지정은 불필요합니다.
        Rich =&gt; println!(&quot;부자는 돈이 많습니다!&quot;),
        Poor =&gt; println!(&quot;빈민은 돈이 없습니다...&quot;),
    }

    match work {
        // 마찬가지로 스코프 지정은 불필요합니다.
        Civilian =&gt; println!(&quot;시민이 일합니다!&quot;),
        Soldier  =&gt; println!(&quot;군인이 전투합니다!&quot;),
    }
}
</code></pre></pre>
<h3 id="see-also-9"><a class="header" href="#see-also-9">See also:</a></h3>
<p><a href="custom_types/enum/../../flow_control/match.html"><code>match</code></a>, <a href="custom_types/enum/../../mod/use.html"><code>use</code></a> </p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="c-like"><a class="header" href="#c-like">C-like</a></h1>
<p>열거형은 C언어에서처럼 사용할 수도 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable">// 사용하지 않은 코드(unused code) 경고를 숨기기 위한 속성입니다.
#![allow(dead_code)]

// 암묵적 식별자(0부터 시작)를 사용한 열거형
enum Number {
    Zero,
    One,
    Two,
}

// 명시적 식별자를 사용한 열거형
enum Color {
    Red = 0xff0000,
    Green = 0x00ff00,
    Blue = 0x0000ff,
}

fn main() {
    // 열거형은 정수로 형 변환할 수 있습니다.
    println!(&quot;Zero는 {}입니다&quot;, Number::Zero as i32);
    println!(&quot;One은 {}입니다&quot;, Number::One as i32);

    println!(&quot;장미 색은 #{:06x}입니다&quot;, Color::Red as i32);
    println!(&quot;제비꽃 색은 #{:06x}입니다&quot;, Color::Blue as i32);
}
</code></pre></pre>
<h3 id="see-also-10"><a class="header" href="#see-also-10">See also:</a></h3>
<p><a href="custom_types/enum/../../types/cast.html">casting</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="testcase-연결-리스트"><a class="header" href="#testcase-연결-리스트">Testcase: 연결 리스트</a></h1>
<p>연결 리스트 구현은 적절한 열거형 사용 예시입니다.</p>
<pre><pre class="playground"><code class="language-rust editable">use crate::List::*;

enum List {
    // Cons: 요소와 다음 노드의 포인터를 감싼 튜플 구조체입니다.
    Cons(u32, Box&lt;List&gt;),
    // Nil: 연결 리스트의 끝을 표시하는 노드입니다.
    Nil,
}

// 열거형에는 메소드를 추가할 수 있습니다.
impl List {
    // 빈 리스트를 생성합니다.
    fn new() -&gt; List {
        // `Nil`의 타입은 `List`입니다.
        Nil
    }

    // 리스트의 소유권을 가져오고, 해당 리스트의 앞에 새 요소를 추가한 리스트를 반환합니다.
    fn prepend(self, elem: u32) -&gt; List {
        // `Cons`의 타입도 마찬가지로 `List`입니다.
        Cons(elem, Box::new(self))
    }

    // 리스트 길이를 반환합니다.
    fn len(&amp;self) -&gt; u32 {
        // `self`가 어떤 variant이냐에 따라 다르게 동작하는 메소드이므로
        // `self`를 매치합니다.
        // `self`는 `&amp;List` 타입이니, `*self`는 `List` 타입입니다.
        // 매치할 때는 참조자 `&amp;T` 타입보다 구체적 타입 `T`가 더 선호됩니다.
        // 러스트 2018 에디션 이후에는 다음 위치에 `self`와 `tail` (ref 없이)
        // 을 작성할 수도 있습니다. 러스트는 &amp;s, ref tail을 추론합니다.
        // https://doc.rust-lang.org/edition-guide/rust-2018/ownership-and-lifetimes/default-match-bindings.html 참고
        match *self {
            // `self`는 borrow 되었기 때문에 다음 노드의 소유권을 얻어올 수 없으니,
            // 참조자를 가져옵니다.
            Cons(_, ref tail) =&gt; 1 + tail.len(),
            // 기본 케이스: 빈 리스트의 길이는 0입니다.
            Nil =&gt; 0
        }
    }

    // 리스트를 문자열(힙 할당된)로 표현하여 반환합니다.
    fn stringify(&amp;self) -&gt; String {
        match *self {
            Cons(head, ref tail) =&gt; {
                // `format!`은 `print!`와 유사하지만,
                // 콘솔에 출력하는 대신 힙 할당된 문자열을 반환합니다.
                format!(&quot;{}, {}&quot;, head, tail.stringify())
            },
            Nil =&gt; {
                format!(&quot;Nil&quot;)
            },
        }
    }
}

fn main() {
    // 빈 연결 리스트를 생성합니다.
    let mut list = List::new();

    // 몇몇 요소를 덧붙입니다.
    list = list.prepend(1);
    list = list.prepend(2);
    list = list.prepend(3);

    // 리스트의 최종 상태를 표시합니다.
    println!(&quot;연결 리스트 길이: {}&quot;, list.len());
    println!(&quot;{}&quot;, list.stringify());
}
</code></pre></pre>
<h3 id="see-also-11"><a class="header" href="#see-also-11">See also:</a></h3>
<p><a href="custom_types/enum/../../std/box.html"><code>Box</code></a>, <a href="custom_types/enum/../../fn/methods.html">methods</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="상수"><a class="header" href="#상수">상수</a></h1>
<p>러스트에는 두 종류 상수가 있습니다. 전역 범위를 포함한 모든 스코프에 선언 가능하며,
타입을 반드시 명시해야 합니다.</p>
<ul>
<li><code>const</code>: 변경 불가능한 값 (보편적인 상수입니다).</li>
<li><code>static</code>: <code>mut</code> 키워드를 이용하면 변경 가능한 변수입니다.
<a href="custom_types/../scope/lifetime/static_lifetime.html"><code>'static</code></a> 라이프타임을 갖습니다.
static 라이프타임은 자동으로 추론되며, 명시할 필요 없습니다.
변경 가능한 static 변수에의 접근 및 수정은 <code>unsafe</code> 연산입니다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">// 모든 스코프를 벗어난 전역 범위에 선언합니다.
static LANGUAGE: &amp;str = &quot;Rust&quot;;
const THRESHOLD: i32 = 10;

fn is_big(n: i32) -&gt; bool {
    // 함수 내에서 상수에 접근합니다.
    n &gt; THRESHOLD
}

fn main() {
    let n = 16;

    // 메인 스레드 내에서 상수에 접근합니다.
    println!(&quot;프로그래밍 언어 {}&quot;, LANGUAGE);
    println!(&quot;임계치는 {}입니다&quot;, THRESHOLD);
    println!(&quot;{}은 {} 값입니다&quot;, n, if is_big(n) { &quot;큰&quot; } else { &quot;작은&quot; });

    // 에러! `const`는 수정할 수 없습니다.
    THRESHOLD = 5;
    // 고쳐주세요! ^ 이 줄을 주석 처리해주세요.
}
</code></pre></pre>
<h3 id="see-also-12"><a class="header" href="#see-also-12">See also:</a></h3>
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/0246-const-vs-static.md">The <code>const</code>/<code>static</code> RFC</a>,
<a href="custom_types/../scope/lifetime/static_lifetime.html"><code>'static</code> lifetime</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="변수-바인딩"><a class="header" href="#변수-바인딩">변수 바인딩</a></h1>
<p>러스트는 정적 타이핑으로 타입 안전성을 보장합니다.
따라서 변수 바인딩 선언 시 타입 어노테이션을 작성할 수 있습니다.
하지만 대부분의 경우는 컴파일러가 문맥에 맞게 타입을 추론하기 때문에,
어노테이션 작성 부담은 크지 않습니다.</p>
<p>리터럴 등의 값을 변수에 바인딩할 때에는 <code>let</code> 바인딩을 사용합니다.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let an_integer = 1u32;
    let a_boolean = true;
    let unit = ();

    // `an_integer`를 `copied_integer`로 복사합니다.
    let copied_integer = an_integer;

    println!(&quot;정수: {:?}&quot;, copied_integer);
    println!(&quot;boolean: {:?}&quot;, a_boolean);
    println!(&quot;)유닛 값을 소개합니다: {:?}&quot;, unit);

    // 컴파일러는 사용되지 않은 변수 바인딩에 `unused variable` 경고를 표시합니다.
    // 변수명 앞에 밑줄(`_`, 언더스코어)을 추가하면 해당 경고를 잠재울 수 있습니다.
    let _unused_variable = 3u32;

    let noisy_unused_variable = 2u32;
    // 고쳐주세요! ^ 앞에 밑줄을 추가해 경고가 나타나지 않도록 하세요
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="가변성"><a class="header" href="#가변성">가변성</a></h1>
<p>변수 바인딩은 기본적으로 불변(immutable)이지만,
<code>mut</code> 수식어를 사용하면 가변성(mutability)을 갖도록 바꿀 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    let _immutable_binding = 1;
    let mut mutable_binding = 1;

    println!(&quot;변하기 전: {}&quot;, mutable_binding);

    // 문제없음
    mutable_binding += 1;

    println!(&quot;변한 후: {}&quot;, mutable_binding);

    // 에러!
    _immutable_binding += 1;
    // 고쳐주세요! ^ 이 줄을 주석 처리해주세요
}
</code></pre></pre>
<p>컴파일러가 가변성 에러 진단 메시지를 상세히 표시할 겁니다.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="스코프-변수-가리기"><a class="header" href="#스코프-변수-가리기">스코프, 변수 가리기</a></h1>
<p>변수 바인딩은 스코프(scope, 범위)를 가지며, <strong>블록</strong> 내에서만 존재할 수 있습니다.
블록은 <code>{}</code> 로 둘러싸인 구문의 모음을 의미합니다.</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    // 메인 함수 내에서 존재하는 바인딩
    let long_lived_binding = 1;

    // 메인 함수보다는 스코프가 작은 블록입니다.
    {
        // 이 블록 내에서만 존재하는 바인딩
        let short_lived_binding = 2;

        println!(&quot;내부에서의 수명 짧은 바인딩: {}&quot;, short_lived_binding);
    }
    // 블록 끝

    // 에러! `short_lived_binding`는 이 스코프에 존재하지 않습니다.
    println!(&quot;외부에서의 수명 짧은 바인딩: {}&quot;, short_lived_binding);
    // 고쳐주세요! ^ 이 줄을 주석 처리해주세요.

    println!(&quot;외부에서의 수명 긴 바인딩: {}&quot;, long_lived_binding);
}
</code></pre></pre>
<p>또한, 변수는 가려질 수 있습니다. (<a href="https://en.wikipedia.org/wiki/Variable_shadowing">variable shadowing</a>)</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    let shadowed_binding = 1;

    {
        println!(&quot;가려지기 전: {}&quot;, shadowed_binding);

        // 외부의 바인딩을 *가리는* 바인딩
        let shadowed_binding = &quot;abc&quot;;

        println!(&quot;내부 블록에서 가려진 후: {}&quot;, shadowed_binding);
    }
    println!(&quot;내부 블록 벗어남: {}&quot;, shadowed_binding);

    // 기존 바인딩을 *가리는* 바인딩
    let shadowed_binding = 2;
    println!(&quot;외부 블록에서 가려진 후: {}&quot;, shadowed_binding);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="조기-선언"><a class="header" href="#조기-선언">조기 선언</a></h1>
<p>변수 바인딩을 먼저 선언하고, 나중에 초기화할 수도 있습니다.
다만, 이러한 형식은 초기화되지 않은 변수 사용을 유발할 수 있으므로 자주 사용되지는
않습니다.</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    // 변수 바인딩 선언
    let a_binding;

    {
        let x = 2;

        // 바인딩 초기화
        a_binding = x * x;
    }

    println!(&quot;a_binding: {}&quot;, a_binding);

    let another_binding;

    // 에러! 초기화되지 않은 바인딩 사용
    println!(&quot;another binding: {}&quot;, another_binding);
    // 고쳐주세요! ^ 이 줄을 주석 처리해주세요

    another_binding = 1;

    println!(&quot;another_binding: {}&quot;, another_binding);
}
</code></pre></pre>
<p>초기화되지 않은 변수 사용은 정의되지 않은 행동(Undefined behavior)을 유발할 수 있으므로,
컴파일러가 금지합니다.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="변수-동결"><a class="header" href="#변수-동결">변수 동결</a></h1>
<p>가변 변수를 동일한 이름의 불변 변수로 바인딩하면 데이터를 <strong>동결</strong>(freeze)할 수 있습니다.
동결된 데이터는 불변 바인딩이 스코프를 벗어나기 전까진 수정할 수 없습니다.</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    let mut _mutable_integer = 7i32;

    {
        // 불변 `_mutable_integer`로 가리기
        let _mutable_integer = _mutable_integer;

        // 에러! `_mutable_integer`는 이 스코프에서 동결되었습니다.
        _mutable_integer = 50;
        // 고쳐주세요! ^ 이 줄을 주석 처리해주세요.

        // `_mutable_integer`가 스코프를 벗어남
    }

    // 문제없음! `_mutable_integer`는 이 스코프에서 동결되어있지 않습니다.
    _mutable_integer = 3;
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="타입"><a class="header" href="#타입">타입</a></h1>
<p>러스트는 기본 타입 및 사용자 정의 타입을 변경하거나 정의하는 방법을 여럿 제공합니다.
이번에 다루는 내용은 각각 다음과 같습니다.</p>
<ul>
<li>기본 타입 간 <a href="types/cast.html">형변환</a></li>
<li><a href="types/literals.html">리터럴</a> 타입 지정</li>
<li><a href="types/inference.html">타입 추론</a></li>
<li>타입 <a href="types/alias.html">별칭</a></li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="형변환"><a class="header" href="#형변환">형변환</a></h1>
<p>러스트는 기본 타입 간 암묵적 형변환 기능을 제공하지 않습니다.
형변환은 <code>as</code> 키워드를 사용해 명시적으로 수행해야 합니다.</p>
<p>정수 타입 간의 형변환 규칙은 일반적으로 C언어 규칙을 따릅니다.
(C언어에서 동작하지만 정의되지 않은 동작(UB)인 경우는 제외됩니다.)
정수 타입 간 형변환은 모두 러스트에 잘 정의되어 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">// 오버플로우 형변환 경고를 모두 숨깁니다.
#![allow(overflowing_literals)]

fn main() {
    let decimal = 65.4321_f32;

    // 에러! 암묵적 형변환은 불가능합니다
    let integer: u8 = decimal;
    // 고쳐주세요! ^ 이 줄을 주석 처리해주세요

    // 명시적 형변환
    let integer = decimal as u8;
    let character = integer as char;

    // 에러! 변환 규칙에는 제한이 존재합니다.
    // 부동 소수점 타입은 char 타입으로 직접 변환할 수 없습니다.
    let character = decimal as char;
    // 고쳐주세요! ^ 이 줄을 주석 처리해주세요

    println!(&quot;형변환: {} -&gt; {} -&gt; {}&quot;, decimal, integer, character);

    // 어떤 값을 부호 없는 타입 T로 형변환 할 경우,
    // 값을 새로운 타입에 저장 할 수 있을때까지
    // T::MAX + 1 을 더하거나 뺍니다.

    // 1000은 u16 타입으로 저장할 수 있습니다
    println!(&quot;1000 as u16 = {}&quot;, 1000 as u16);

    // 1000 - 256 - 256 - 256 = 232
    // 내부적으로, 처음 8개 최하위 비트(LSB)는 유지되고,
    // 최상위 비트(MSB) 방향의 나머지는 잘립니다.
    println!(&quot;1000 as u8  = {}&quot;, 1000 as u8);
    // -1 + 256 = 255
    println!(&quot;  -1 as u8  = {}&quot;, (-1i8) as u8);

    // 양수의 경우, 나머지 연산 결과와 동일합니다
    println!(&quot;1000 % 256  = {}&quot;, 1000 % 256);

    // 부호 있는 타입으로 형변환 할 경우,
    // (비트 단위) 결과는 부호 없는 타입으로 형변환한 것과 같습니다.
    // 만약 값의 최상위 비트(MSB)가 1일 경우, 해당 값은 음수입니다.

    // 물론, 바로 저장 가능한 경우는 제외고요.
    println!(&quot; 128 as i16 = {}&quot;, 128 as i16);
    // 128 as u8 -&gt; 128, 8비트 상에서 2의 보수:
    println!(&quot; 128 as i8  = {}&quot;, 128 as i8);

    // 앞선 예시 반복
    // 1000 as u8 -&gt; 232
    println!(&quot;1000 as u8  = {}&quot;, 1000 as u8);
    // 232에 대한 2의 보수는 -24입니다
    println!(&quot; 232 as i8  = {}&quot;, 232 as i8);
    
    // 러스트 1.45 버전부터, `as` 키워드는 부동 소수점을 정수로 형변환 할 경우
    // *포화 연산(saturate cast)*를 수행합니다.
    // 부동 소수점 값이 상한을 초과하거나 하한보다 작을 경우,
    // 반환 값은 한계치와 동일합니다.
    
    // 300.0 = 255
    println!(&quot;       300.0 = {}&quot;, 300.0_f32 as u8);
    // -100.0 as u8 = 0
    println!(&quot;-100.0 as u8 = {}&quot;, -100.0_f32 as u8);
    // nan as u8 = 0
    println!(&quot;   nan as u8 = {}&quot;, f32::NAN as u8);
    
    // 포화 연산은 약간의 런타임 비용이 발생합니다.
    // unsafe 메소드로 포화 연산을 회피할 수 있지만, 오버플로우가 발생해
    // **부적절한** 결과 값이 반환될 수 있으므로 사용에 주의해야 합니다.
    unsafe {
        // 300.0 = 44
        println!(&quot;       300.0 = {}&quot;, 300.0_f32.to_int_unchecked::&lt;u8&gt;());
        // -100.0 as u8 = 156
        println!(&quot;-100.0 as u8 = {}&quot;, (-100.0_f32).to_int_unchecked::&lt;u8&gt;());
        // nan as u8 = 0
        println!(&quot;   nan as u8 = {}&quot;, f32::NAN.to_int_unchecked::&lt;u8&gt;());
    }
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="리터럴"><a class="header" href="#리터럴">리터럴</a></h1>
<p>숫자 리터럴에는 접미사로 타입 어노테이션을 작성할 수 있습니다.
예를 들어, <code>42i32</code>는 <code>42</code> 리터럴을 <code>i32</code> 타입으로 지정한다는 의미입니다.</p>
<p>접미사가 없는 숫자 리터럴은 어떻게 사용되느냐에 따라서 타입이 달라집니다.
제약 조건이 없을 경우, 컴파일러는 정수에 <code>i32</code> 타입을,
부동 소수점에 <code>f64</code> 타입을 사용합니다.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    // 접미사가 있는 리터럴 (초기화 시점에 타입을 알 수 있음)
    let x = 1u8;
    let y = 2u32;
    let z = 3f32;

    // 접미사가 없는 리터럴 (어떻게 사용되느냐에 따라 타입이 달라짐)
    let i = 1;
    let f = 1.0;

    // `size_of_val`는 변수의 크기를 바이트 단위로 반환합니다.
    println!(&quot;`x`의 바이트 단위 크기: {}&quot;, std::mem::size_of_val(&amp;x));
    println!(&quot;`y`의 바이트 단위 크기: {}&quot;, std::mem::size_of_val(&amp;y));
    println!(&quot;`z`의 바이트 단위 크기: {}&quot;, std::mem::size_of_val(&amp;z));
    println!(&quot;`i`의 바이트 단위 크기: {}&quot;, std::mem::size_of_val(&amp;i));
    println!(&quot;`f`의 바이트 단위 크기: {}&quot;, std::mem::size_of_val(&amp;f));
}
</code></pre></pre>
<p>앞선 코드에서는 아직 설명하지 않은 개념이 몇 가지 사용되었습니다.
궁금하신 분을 위해 간단히 설명하겠습니다.</p>
<ul>
<li><code>std::mem::size_of_val</code>는 함수이며, <strong>전체 경로</strong>를 통해 호출했습니다.
코드는 <strong>모듈</strong>이라는 논리적 단위로 분할할 수 있습니다.
이 경우, <code>size_of_val</code> 함수는 <code>mem</code> 모듈 내에 정의되어있고,
<code>mem</code> 모듈은 <code>std</code> <strong>크레이트</strong> 내에 정의되어있습니다.
자세한 내용은 <a href="types/../mod.html">모듈</a>, <a href="types/../crates.html">크레이트</a>를 참고해주세요.</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="타입-추론"><a class="header" href="#타입-추론">타입 추론</a></h1>
<p>타입 추론 엔진은 꽤 영리합니다.
초기화 시 표현식 값의 타입을 알아내는 것을 넘어,
변수가 이후에 어떻게 사용되는지까지 지켜보고 타입을 추론하죠.
다음은 타입 추론의 심화 예시입니다.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    // 타입 어노테이션이 있으니, 컴파일러는 `elem`이 u8 타입임을 알 수 있습니다
    let elem = 5u8;

    // 빈 벡터(크기가 늘어나는 배열)를 생성합니다.
    let mut vec = Vec::new();
    // 이 시점에서, 컴파일러는 `vec`의 정확한 타입을 알 수 없습니다.
    // 무언가에 대한 벡터(`Vec&lt;_&gt;`)라는 것만 알 수 있죠.

    // `elem`을 벡터에 삽입합니다.
    vec.push(elem);
    // 이제 컴파일러는 `vec`이 `u8` 타입의 벡터(`Vec&lt;u8&gt;`)임을 알 수 있습니다!
    // TODO ^ `vec.push(elem)` 줄을 주석 처리해보세요

    println!(&quot;{:?}&quot;, vec);
}
</code></pre></pre>
<p>변수에 타입 어노테이션을 작성하지 않고도 컴파일 문제가 발생하지 않으면,
프로그래머에게는 행복한 일이죠!</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="타입-별칭-1"><a class="header" href="#타입-별칭-1">타입 별칭</a></h1>
<p><code>type</code> 구문으로 기존 타입에 새로운 이름을 지어줄 수도 있습니다.
타입명은 반드시 대문자 낙타 표기법(<code>UpperCamelCase</code>)을 따라야 하며, 따르지 않을 경우 컴파일러 경고가 발생합니다.
단, <code>usize</code>, <code>f32</code> 등 기본 타입은 이 규칙에서 예외입니다.</p>
<pre><pre class="playground"><code class="language-rust editable">// `NanoSecond`는 `u64`의 새로운 별칭입니다.
type NanoSecond = u64;
type Inch = u64;

// 속성을 사용해 경고를 무시합니다
#[allow(non_camel_case_types)]
type u64_t = u64;
// TODO ^ 속성을 제거해보세요

fn main() {
    // `NanoSecond` = `Inch` = `u64_t` = `u64`.
    let nanoseconds: NanoSecond = 5 as u64_t;
    let inches: Inch = 2 as u64_t;

    // 타입 별칭이 추가적인 타입 안정성을 제공하지는 *않는다는* 점을 알아두세요.
    // 별칭일 뿐 새로운 타입이 *아닙니다*
    println!(&quot;{} nanoseconds + {} inches = {} unit?&quot;,
             nanoseconds,
             inches,
             nanoseconds + inches);
}
</code></pre></pre>
<p>타입 별칭은 주로 보일러플레이트를 줄이기 위해 사용됩니다.
예를 들어, <code>IoResult&lt;T&gt;</code> 타입은 <code>Result&lt;T, IoError&gt;</code> 라는 긴 타입의 별칭입니다.</p>
<h3 id="see-also-13"><a class="header" href="#see-also-13">See also:</a></h3>
<p><a href="types/../attribute.html">속성</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="형변환-1"><a class="header" href="#형변환-1">형변환</a></h1>
<p>기본 타입은 서로 간에 <a href="types/cast.html">형변환(Casting)</a>할 수 있습니다.</p>
<p>러스트에서 커스텀 타입(<code>struct</code>, <code>enum</code> 등) 간
형변환(Conversion)은 <a href="trait.html">트레잇</a>을 사용합니다.
일반적인 형변환은 <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a>, <a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a> 트레잇을 이용하며,
자주 사용되는 <code>String</code> 형변환은 별도의 방법이
특별히 제공됩니다.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="from-into"><a class="header" href="#from-into"><code>From</code>, <code>Into</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a>, <a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a> 트레잇은 본질적으로 서로 이어져있으며,
실제 구현 또한 마찬가지입니다. A 타입을 B 타입으로 변환할 수 있다면,
B 타입을 A 타입으로 변환할 수도 있어야 하는 건 당연한 일이죠.</p>
<h2 id="from"><a class="header" href="#from"><code>From</code></a></h2>
<p><a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> 트레잇으로는 어떠한 타입을 다른 타입으로부터 어떻게 생성하는지 정의할 수 있습니다.
이를 이용하면 여러 타입 간에 쉽게 변환할 수 있습니다.
기본 타입 및 공용 타입은 표준 라이브러리에 수많은 <code>From</code> 트레잇 구현이
이미 작성되어있습니다.</p>
<p>그 예로, <code>str</code>은 <code>String</code>으로 쉽게 변환할 수 있죠.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_str = &quot;hello&quot;;
let my_string = String::from(my_str);
<span class="boring">}
</span></code></pre></pre>
<p>우리가 직접 만든 타입도 변환 방법을 정의해주면 쉽게 변환 가능합니다.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::convert::From;

#[derive(Debug)]
struct Number {
    value: i32,
}

impl From&lt;i32&gt; for Number {
    fn from(item: i32) -&gt; Self {
        Number { value: item }
    }
}

fn main() {
    let num = Number::from(30);
    println!(&quot;내가 만든 Number {:?}&quot;, num);
}
</code></pre></pre>
<h2 id="into"><a class="header" href="#into"><code>Into</code></a></h2>
<p><a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a> 트레잇은 단순히 <code>From</code> 트레잇의 반대입니다.
즉, <code>From</code> 트레잇이 구현된 여러분의 타입에 <code>Into</code>를 사용하면
<code>from</code>이 호출됩니다.</p>
<p><code>Into</code> 트레잇을 사용하는 대부분의 경우,
컴파일러는 알맞은 타입을 알아낼 수 없으므로 타입 명시가 필수적입니다.
하지만 이건 얻는 이점에 비하면 사소한 문제입니다.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::convert::From;

#[derive(Debug)]
struct Number {
    value: i32,
}

impl From&lt;i32&gt; for Number {
    fn from(item: i32) -&gt; Self {
        Number { value: item }
    }
}

fn main() {
    let int = 5;
    // 타입 선언을 지워보세요
    let num: Number = int.into();
    println!(&quot;Number는 {:?}입니다&quot;, num);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="tryfrom-tryinto"><a class="header" href="#tryfrom-tryinto"><code>TryFrom</code>, <code>TryInto</code></a></h1>
<p><a href="conversion/from_into.html"><code>From</code>, <code>Into</code></a>와 마찬가지로,
<a href="https://doc.rust-lang.org/std/convert/trait.TryFrom.html"><code>TryFrom</code></a>, <a href="https://doc.rust-lang.org/std/convert/trait.TryInto.html"><code>TryInto</code></a>은 형변환용 제네릭 트레잇입니다.
다만 <code>From</code>/<code>Into</code> 와는 다르게, <code>TryFrom</code>/<code>TryInto</code> 트레잇은
실패할 가능성이 있는 변환에 사용됩니다(따라서 <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a>를 반환합니다).</p>
<pre><pre class="playground"><code class="language-rust editable">use std::convert::TryFrom;
use std::convert::TryInto;

#[derive(Debug, PartialEq)]
struct EvenNumber(i32); // 짝수

impl TryFrom&lt;i32&gt; for EvenNumber {
    type Error = ();

    fn try_from(value: i32) -&gt; Result&lt;Self, Self::Error&gt; {
        if value % 2 == 0 {
            Ok(EvenNumber(value))
        } else {
            Err(())
        }
    }
}

fn main() {
    // TryFrom

    assert_eq!(EvenNumber::try_from(8), Ok(EvenNumber(8)));
    assert_eq!(EvenNumber::try_from(5), Err(()));

    // TryInto

    let result: Result&lt;EvenNumber, ()&gt; = 8i32.try_into();
    assert_eq!(result, Ok(EvenNumber(8)));
    let result: Result&lt;EvenNumber, ()&gt; = 5i32.try_into();
    assert_eq!(result, Err(()));
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="문자열-변환"><a class="header" href="#문자열-변환">문자열 변환</a></h1>
<h2 id="문자열로-변환하기"><a class="header" href="#문자열로-변환하기">문자열로 변환하기</a></h2>
<p>어떤 타입에 <a href="https://doc.rust-lang.org/std/string/trait.ToString.html"><code>ToString</code></a> 트레잇이 구현되어있다면 <code>String</code>으로 변환할 수 있습니다.
다만, 타입에 <a href="https://doc.rust-lang.org/std/string/trait.ToString.html"><code>ToString</code></a>을 직접 구현하는 대신, <a href="https://doc.rust-lang.org/std/fmt/trait.Display.html"><code>fmt::Display</code></a> 트레잇을 구현해
<a href="https://doc.rust-lang.org/std/string/trait.ToString.html"><code>ToString</code></a>을 자동으로 생성하고 <a href="conversion/../hello/print.html"><code>print!</code></a>에서 다룬 타입 출력도
가능하게 만들 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::fmt;

struct Circle {
    radius: i32
}

impl fmt::Display for Circle {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;반지름이 {}인 원&quot;, self.radius)
    }
}

fn main() {
    let circle = Circle { radius: 6 };
    println!(&quot;{}&quot;, circle.to_string());
}
</code></pre></pre>
<h2 id="문자열-파싱하기"><a class="header" href="#문자열-파싱하기">문자열 파싱하기</a></h2>
<p>문자열을 다른 타입으로 변환하는 문자열 파싱은
일반적으로 <a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse"><code>parse</code></a> 함수가 사용되며, 여기에 타입 추론을 붙이거나
'turbofish' 구문으로 타입을 명시합니다.
다음 예제는 각각의 방법으로 문자열을 숫자로 변환하는 예시를 나타냅니다.</p>
<p>어떤 타입에 <a href="https://doc.rust-lang.org/std/str/trait.FromStr.html"><code>FromStr</code></a> 트레잇이 구현되어있다면, 문자열을 해당 타입으로 변환할 수 있습니다.
표준 라이브러리 내에는 다양한 타입에 대해서 <a href="https://doc.rust-lang.org/std/str/trait.FromStr.html"><code>FromStr</code></a> 트레잇이 구현되어있습니다.
사용자 정의 타입에도 <a href="https://doc.rust-lang.org/std/str/trait.FromStr.html"><code>FromStr</code></a> 트레잇을 구현하면
마찬가지 동작이 가능합니다.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let parsed: i32 = &quot;5&quot;.parse().unwrap();
    let turbo_parsed = &quot;10&quot;.parse::&lt;i32&gt;().unwrap();

    let sum = parsed + turbo_parsed;
    println!(&quot;합계: {:?}&quot;, sum);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="표현식"><a class="header" href="#표현식">표현식</a></h1>
<p>러스트 프로그램은 (대부분) 여러 개의 구문으로 이루어져 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    // 구문
    // 구문
    // 구문
}
</code></pre></pre>
<p>러스트에서 구문은 여러 종류가 존재합니다.
가장 일반적인 두 가지는 변수 바인딩 선언, <code>;</code>이 붙은 표현식입니다.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    // 변수 바인딩
    let x = 5;

    // 표현식;
    x;
    x + 1;
    15;
}
</code></pre></pre>
<p>블록 또한 표현식이므로 대입 값으로 사용할 수 있습니다.
블록 내 마지막 표현식은 지역 변수 등의 표현식에 대입됩니다.
블록의 마지막 표현식에 세미콜론이 붙는 경우,
반환값은 <code>()</code> 입니다.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let x = 5u32;

    let y = {
        let x_squared = x * x;
        let x_cube = x_squared * x;

        // 이 표현식은 `y`에 대입됩니다
        x_cube + x_squared + x
    };

    let z = {
        // 이 표현식은 세미콜론으로 억제되어, `z`에 `()`가 대입됩니다
        2 * x;
    };

    println!(&quot;x = {:?}&quot;, x);
    println!(&quot;y = {:?}&quot;, y);
    println!(&quot;z = {:?}&quot;, z);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="흐름-제어"><a class="header" href="#흐름-제어">흐름 제어</a></h1>
<p><code>if</code>/<code>else</code>, <code>for</code> 등 흐름 제어 구문은 모든 프로그래밍 언어의 필수 요소입니다.
러스트의 흐름 제어 구문을 알아봅시다.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="ifelse"><a class="header" href="#ifelse">if/else</a></h1>
<p><code>if</code>-<code>else</code>를 사용하는 분기 방법은 다른 언어와 유사합니다.
하지만, 대다수의 언어와 달리 boolean 조건을 괄호로 묶을 필요가 없으며,
각 조건 뒤에는 블록이 반드시 따라붙습니다.
<code>if</code>-<code>eles</code> 조건문 또한 표현식이며, 모든 갈래는 동일한 타입을 반환해야 합니다.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let n = 5;

    if n &lt; 0 {
        print!(&quot;{}은(는) 음수입니다.&quot;, n);
    } else if n &gt; 0 {
        print!(&quot;{}은(는) 양수입니다.&quot;, n);
    } else {
        print!(&quot;{}은 0입니다.&quot;, n);
    }

    let big_n =
        if n &lt; 10 &amp;&amp; n &gt; -10 {
            println!(&quot; 작은 숫자이므로, 10배로 늘립니다.&quot;);

            // 이 표현식은 `i32`를 반환합니다.
            10 * n
        } else {
            println!(&quot; 큰 숫자이므로, 반으로 나눕니다.&quot;);

            // 이 표현식 또한 마찬가지로 `i32`를 반환해야 합니다.
            n / 2
            // TODO ^ 이 표현식에 세미콜론을 붙여보세요.
        };
    //   ^ 이 부분에 세미콜론을 빠트리면 안 됩니다!
    //     모든 `let` 바인딩에는 세미콜론이 필요합니다.

    println!(&quot;{} -&gt; {}&quot;, n, big_n);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="loop"><a class="header" href="#loop">loop</a></h1>
<p>러스트에선 <code>loop</code> 키워드로 무한 반복을 명시할 수 있습니다.</p>
<p><code>break</code> 구문으로 언제든지 반복을 끝낼 수 있습니다.
<code>continue</code> 구문은 현 회차의 나머지를 생략하고,
새로운 회차를 시작합니다.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut count = 0u32;

    println!(&quot;무한 카운트 시작!&quot;);

    // 무한 반복
    loop {
        count += 1;

        if count == 3 {
            println!(&quot;셋&quot;);

            // 이번 회차의 나머지 생략
            continue;
        }

        println!(&quot;{}&quot;, count);

        if count == 5 {
            println!(&quot;이 정도면 충분하겠네요&quot;);

            // 반복 종료
            break;
        }
    }
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="중첩-라벨"><a class="header" href="#중첩-라벨">중첩, 라벨</a></h1>
<p>중첩된 반복 내에서 <code>break</code>, <code>continue</code>로 외부 반복문을 제어하는 것도 가능합니다.
이 경우, 반복문에는 어떤 <code>'label</code> 이 어노테이션되어있어야 하며,
해당 라벨을  <code>break</code>/<code>continue</code> 구문에 전달해야 합니다.</p>
<pre><pre class="playground"><code class="language-rust editable">#![allow(unreachable_code)]

fn main() {
    'outer: loop {
        println!(&quot;바깥쪽 반복문 진입&quot;);

        'inner: loop {
            println!(&quot;안쪽 반복문 진입&quot;);

            // 이 break 구문은 안쪽 반복문을 종료합니다
            //break;

            // 이 break 구문은 바깥쪽 반복문을 종료합니다
            break 'outer;
        }

        println!(&quot;이 부분은 실행될 일이 없습니다&quot;);
    }

    println!(&quot;바깥쪽 반복문 종료됨&quot;);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="반복문에서-반환하기"><a class="header" href="#반복문에서-반환하기">반복문에서 반환하기</a></h1>
<p><code>loop</code>는 어떤 작업에 성공할 때까지 재시도하는 용도로 사용되기도 합니다.
해당 작업이 어떠한 값을 반환하고, 이후의 코드에서 사용할 수 있도록
값을 전달해야 할 경우, <code>break</code> 구문 뒤에 값을 작성하면
<code>loop</code> 표현식이 해당 값을 반환합니다.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    assert_eq!(result, 20);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="while"><a class="header" href="#while">while</a></h1>
<p><code>while</code> 키워드는 조건이 참인 동안 반복합니다.</p>
<p><code>while</code> 반복문으로 <a href="https://en.wikipedia.org/wiki/Fizz_buzz">FizzBuzz</a> 문제를 구현해보죠.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    // 카운터 변수
    let mut n = 1;

    // `n`이 101 미만인 동안 반복
    while n &lt; 101 {
        if n % 15 == 0 {
            println!(&quot;fizzbuzz&quot;);
        } else if n % 3 == 0 {
            println!(&quot;fizz&quot;);
        } else if n % 5 == 0 {
            println!(&quot;buzz&quot;);
        } else {
            println!(&quot;{}&quot;, n);
        }

        // 카운터 증가
        n += 1;
    }
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="for-반복문"><a class="header" href="#for-반복문">for 반복문</a></h1>
<h2 id="범위-표기법으로-for-반복문-사용하기"><a class="header" href="#범위-표기법으로-for-반복문-사용하기">범위 표기법으로 for 반복문 사용하기</a></h2>
<p><code>for in</code> 구문은 <code>Iterator</code>를 통해 순회합니다.
반복자(iterator)를 만드는 가장 쉬운 방법은 범위 표기법을 사용하는 겁니다.
<code>a..b</code> 범위 표기법은 <code>a</code>(포함)부터 <code>b</code>(제외)까지,
한 단계씩 값이 생성됩니다.</p>
<p>FizzBuzz 문제를 <code>while</code> 대신 <code>for</code> 반복문으로 구현해보겠습니다.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    // `n`은 각 회차에 따라 1, 2, ..., 100이 됩니다
    for n in 1..101 {
        if n % 15 == 0 {
            println!(&quot;fizzbuzz&quot;);
        } else if n % 3 == 0 {
            println!(&quot;fizz&quot;);
        } else if n % 5 == 0 {
            println!(&quot;buzz&quot;);
        } else {
            println!(&quot;{}&quot;, n);
        }
    }
}
</code></pre></pre>
<p>범위의 양쪽 끝을 모두 포함하려면 <code>a..=b</code>를 사용합니다.
위 예제를 <code>a..=b</code> 표기법을 사용해 작성하면 다음과 같습니다.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    // `n`은 각 회차에 따라 1, 2, ..., 100이 됩니다
    for n in 1..=100 {
        if n % 15 == 0 {
            println!(&quot;fizzbuzz&quot;);
        } else if n % 3 == 0 {
            println!(&quot;fizz&quot;);
        } else if n % 5 == 0 {
            println!(&quot;buzz&quot;);
        } else {
            println!(&quot;{}&quot;, n);
        }
    }
}
</code></pre></pre>
<h2 id="반복자iterator로-for-반복문-사용하기"><a class="header" href="#반복자iterator로-for-반복문-사용하기">반복자(Iterator)로 for 반복문 사용하기</a></h2>
<p><code>for in</code> 구문은 <code>Iterator</code>와 사용할 수 있습니다.
<a href="flow_control/../trait/iter.html">Iterator</a> 트레잇 부분에서 다뤘듯, <code>for</code> 반복문은
기본적으로 <code>into_iter</code> 함수를 컬렉션에 적용합니다.
물론, <code>into_iter</code> 만이 컬렉션을 반복자로 변환하는 유일한 방법은 아닙니다.</p>
<p><code>into_iter</code>, <code>iter</code>, <code>iter_mut</code>는
모두 컬렉션을 반복자로 변환하며,
데이터를 각각의 관점으로 제공합니다.</p>
<ul>
<li><code>iter</code> - 컬렉션의 각 요소를 borrow 합니다.
컬렉션을 건드리지 않으므로, 반복문 이후에도 사용할 수 있습니다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let names = vec![&quot;Bob&quot;, &quot;Frank&quot;, &quot;Ferris&quot;];

    for name in names.iter() {
        match name {
            &amp;&quot;Ferris&quot; =&gt; println!(&quot;이 중에 러스트 사용자가 있다!&quot;),
            // TODO ^ `&amp;`를 지우고 &quot;Ferris&quot;로만 매칭해보세요
            _ =&gt; println!(&quot;안녕, {}&quot;, name),
        }
    }
    
    println!(&quot;names: {:?}&quot;, names);
}
</code></pre></pre>
<ul>
<li><code>into_iter</code> - 컬렉션을 소비하여 각 회차에 정확한 데이터를 가져옵니다.
데이터가 반복문 내로 '이동'되므로 컬렉션을 소비하고 나면
이후에는 사용할 수 없습니다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    let names = vec![&quot;Bob&quot;, &quot;Frank&quot;, &quot;Ferris&quot;];

    for name in names.into_iter() {
        match name {
            &quot;Ferris&quot; =&gt; println!(&quot;이 중에 러스트 사용자가 있다!&quot;),
            _ =&gt; println!(&quot;안녕, {}&quot;, name),
        }
    }
    
    println!(&quot;names: {:?}&quot;, names);
    // 고쳐주세요! ^ 이 줄을 주석 처리해주세요
}
</code></pre></pre>
<ul>
<li><code>iter_mut</code> - 컬렉션의 각 요소를 변경 가능하게 borrow 합니다.
컬렉션을 수정할 수 있습니다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut names = vec![&quot;Bob&quot;, &quot;Frank&quot;, &quot;Ferris&quot;];

    for name in names.iter_mut() {
        *name = match name {
            &amp;mut &quot;Ferris&quot; =&gt; &quot;이 중에 러스트 사용자가 있다!&quot;,
            _ =&gt; &quot;안녕&quot;,
        }
    }

    println!(&quot;names: {:?}&quot;, names);
}
</code></pre></pre>
<p>앞선 코드 예제에서는 <code>match</code> 가지의 타입을 주목해주세요.
각 종류의 주요 차이점입니다.
당연하지만, 여러 종류가 존재한다는 것은 종류마다 할 수 있는 일이 다르다는 의미입니다.</p>
<h3 id="see-also-14"><a class="header" href="#see-also-14">See also:</a></h3>
<p><a href="flow_control/../trait/iter.html">Iterator</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="match"><a class="header" href="#match">match</a></h1>
<p>러스트는 C 언어의 <code>switch</code> 처럼
사용할 수 있는 <code>match</code> 패턴 매칭을 제공합니다.
가장 먼저 매칭되는 갈래가 평가되며, 가능성이 있는 모든 값이 다뤄져야 합니다.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let number = 13;
    // TODO ^ `number`에 다른 값을 설정해 보세요.

    println!(&quot;{}는&quot;, number);
    match number {
        // 하나의 값 매칭
        1 =&gt; println!(&quot;1 입니다!&quot;),
        // 여러 값 매칭
        2 | 3 | 5 | 7 | 11 =&gt; println!(&quot;소수입니다&quot;),
        // TODO ^ 소수 값 목록에 13을 추가해보세요
        // 포함 범위(inclusive range) 매칭
        13..=19 =&gt; println!(&quot;10대입니다&quot;),
        // 나머지 경우 처리
        _ =&gt; println!(&quot;특별한 숫자는 아닙니다&quot;),
        // TODO ^ 위의 모든 경우 처리 갈래를 주석 처리해보세요
    }

    let boolean = true;
    // match도 표현식입니다
    let binary = match boolean {
        // 매치 갈래는 가능성 있는 모든 값을 처리해야 합니다
        false =&gt; 0,
        true =&gt; 1,
        // TODO ^ 갈래 중 하나를 주석 처리해보세요
    };

    println!(&quot;{} -&gt; {}&quot;, boolean, binary);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="해체"><a class="header" href="#해체">해체</a></h1>
<p><code>match</code> 블록은 다양한 방식으로 항목을 해체할 수 있습니다.</p>
<ul>
<li><a href="flow_control/match/destructuring/destructure_tuple.html">튜플 해체</a></li>
<li><a href="flow_control/match/destructuring/destructure_enum.html">열거형 해체</a></li>
<li><a href="flow_control/match/destructuring/destructure_pointers.html">포인터 해체</a></li>
<li><a href="flow_control/match/destructuring/destructure_structures.html">구조체 해체</a></li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="튜플-1"><a class="header" href="#튜플-1">튜플</a></h1>
<p><code>match</code>에서, 튜플은 다음과 같이 해체할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let triple = (0, -2, 3);
    // TODO ^ `triple`에 다른 값을 넣어 보세요

    println!(&quot;{:?}&quot;, triple);
    // 매치에서 튜플을 해체할 수 있습니다.
    match triple {
        // 두 번째, 세 번째 요소를 해체합니다
        (0, y, z) =&gt; println!(&quot;첫 번째는 `0`, `y`는 {:?}, `z`는 {:?}&quot;, y, z),
        (1, ..)  =&gt; println!(&quot;첫 번째는 `1`, 나머지는 상관없음&quot;),
        // `..`는 튜플의 나머지를 무시하는 데 사용합니다
        _      =&gt; println!(&quot;뭐든지 상관없음&quot;),
        // `_`는 값을 변수에 바인딩하지 않음을 의미합니다
    }
}
</code></pre></pre>
<h3 id="see-also-15"><a class="header" href="#see-also-15">See also:</a></h3>
<p><a href="flow_control/match/destructuring/../../../primitives/tuples.html">튜플</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="열거형-1"><a class="header" href="#열거형-1">열거형</a></h1>
<p><code>enum</code> 해체도 비슷합니다.</p>
<pre><pre class="playground"><code class="language-rust editable">// 이 `allow`는 하나의 variant만 사용할 경우
// 나타나는 경고를 억제합니다.
#[allow(dead_code)]
enum Color {
    // 이 3개는 이름만 존재합니다
    Red,
    Blue,
    Green,
    // `u32` 튜플을 색상 모델 이름으로 묶습니다.
    RGB(u32, u32, u32),
    HSV(u32, u32, u32),
    HSL(u32, u32, u32),
    CMY(u32, u32, u32),
    CMYK(u32, u32, u32, u32),
}

fn main() {
    let color = Color::RGB(122, 17, 40);
    // TODO ^ `color`에 다른 variant를 설정해 보세요

    println!(&quot;어떤 색상인가요?&quot;);
    // 매치에서 열거형을 해체할 수 있습니다.
    match color {
        Color::Red   =&gt; println!(&quot;빨간색입니다!&quot;),
        Color::Blue  =&gt; println!(&quot;파란색입니다!&quot;),
        Color::Green =&gt; println!(&quot;초록색입니다!&quot;),
        Color::RGB(r, g, b) =&gt;
            println!(&quot;빨간색: {}, 초록색: {}, 파란색: {}!&quot;, r, g, b),
        Color::HSV(h, s, v) =&gt;
            println!(&quot;색상(Hue): {}, 채도(Saturation): {}, 명도(Value): {}!&quot;, h, s, v),
        Color::HSL(h, s, l) =&gt;
            println!(&quot;색상(Hue): {}, 채도(Saturation): {}, 명도(Lightness): {}!&quot;, h, s, l),
        Color::CMY(c, m, y) =&gt;
            println!(&quot;Cyan: {}, Magenta: {}, Yellow: {}!&quot;, c, m, y),
        Color::CMYK(c, m, y, k) =&gt;
            println!(&quot;Cyan: {}, Magenta: {}, Yellow: {}, Key(Black): {}!&quot;,
                c, m, y, k),
        // 모든 variant가 검사되었으므로 더 이상의 갈래가 필요하지 않습니다
    }
}
</code></pre></pre>
<h3 id="see-also-16"><a class="header" href="#see-also-16">See also:</a></h3>
<p><a href="flow_control/match/destructuring/../../../attribute/unused.html"><code>#[allow(...)]</code></a>, <a href="https://en.wikipedia.org/wiki/Color_model">색상 모델</a>, <a href="flow_control/match/destructuring/../../../custom_types/enum.html">열거형(<code>enum</code>)</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="포인터참조자"><a class="header" href="#포인터참조자">포인터/참조자</a></h1>
<p>포인터의 경우, <code>C</code> 같은 언어와는 사용 개념이 다르므로
해체(destructuring)와 역참조(dereferencing)를
구별해야 합니다.</p>
<ul>
<li>역참조는 <code>*</code>를 사용합니다</li>
<li>해체는 <code>&amp;</code>, <code>ref</code>, <code>ref mut</code>를 사용합니다</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    // `i32` 타입의 참조자를 할당합니다.
    // `&amp;`는 참조자가 대입됨을 나타냅니다.
    let reference = &amp;4;

    match reference {
        // `reference`를 `&amp;val`에 매치되는 패턴으로 비교하면
        // 다음과 같습니다:
        // `&amp;i32`
        // `&amp;val`
        // ^ 대응되는 `&amp;i32`의 `&amp;` 가 빠지면 `val`에 대입될
        // `i32`만 남는 것을 확인할 수 있습니다.
        &amp;val =&gt; println!(&quot;해체로 얻은 값: {:?}&quot;, val),
    }

    // 매칭하기 전에 역참조하면 `&amp;`를 회피할 수 있습니다.
    match *reference {
        val =&gt; println!(&quot;역참조로 얻은 값: {:?}&quot;, val),
    }

    // 처음부터 참조가 아닌 경우엔 어떨까요?
    // `reference`는 우변이 참조자였으니 `&amp;` 였지만,
    // 이번엔 우변이 참조자가 아닙니다.
    let _not_a_reference = 3;

    // 러스트는 이 용도로 `ref`를 제공합니다.
    // `ref`는 대입문을 수정해서, 요소에 대한 참조자를
    // 생성하고 대입합니다.
    let ref _is_a_reference = 3;

    // 참조 없이 두 값을 정의하고
    // `ref`, `ref mut`으로 참조자를 얻어옵니다.
    let value = 5;
    let mut mut_value = 6;

    // `ref` 키워드로 참조자를 생성합니다.
    match value {
        ref r =&gt; println!(&quot;값의 참조자: {:?}&quot;, r),
    }

    // `ref mut` 사용 방법도 비슷합니다.
    match mut_value {
        ref mut m =&gt; {
            // 참조자를 얻어옵니다.
            // 역참조했으므로 값을 더할 수 있습니다.
            *m += 10;
            println!(&quot;10을 더했습니다. `mut_value`: {:?}&quot;, m);
        },
    }
}
</code></pre></pre>
<h3 id="see-also-17"><a class="header" href="#see-also-17">See also:</a></h3>
<p><a href="flow_control/match/destructuring/../../../scope/borrow/ref.html">The ref pattern</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="구조체-1"><a class="header" href="#구조체-1">구조체</a></h1>
<p><code>struct</code> 해체도 비슷합니다.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    struct Foo {
        x: (u32, u32),
        y: u32,
    }

    // 구조체 내 값을 변경하면 어떻게 되는지 확인해보세요
    let foo = Foo { x: (1, 2), y: 3 };

    match foo {
        Foo { x: (1, b), y } =&gt; println!(&quot;x의 첫 번째 값 = 1, b = {},  y = {} &quot;, b, y),

        // 구조체를 해체하고 변수의 이름을 다시 지을 수도 있습니다.
        // 순서는 중요하지 않습니다.
        Foo { y: 2, x: i } =&gt; println!(&quot;y is 2, i = {:?}&quot;, i),

        // 일부 변수를 무시할 수도 있습니다:
        Foo { y, .. } =&gt; println!(&quot;y = {}, x는 신경 쓰지 않습니다&quot;, y),
        // 다음은 오류가 발생합니다. 패턴에 `x` 필드가 언급되지 않았습니다.
        //Foo { y } =&gt; println!(&quot;y = {}&quot;, y),
    }
}
</code></pre></pre>
<h3 id="see-also-18"><a class="header" href="#see-also-18">See also:</a></h3>
<p><a href="flow_control/match/destructuring/../../../custom_types/structs.html">구조체</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="매치-가드"><a class="header" href="#매치-가드">매치 가드</a></h1>
<p><code>match</code> 갈래 필터링에 **가드(guard)**를 추가할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let pair = (2, -2);
    // TODO ^ `pair`에 다른 값을 설정해 보세요

    println!(&quot;{:?}를 설명합니다&quot;, pair);
    match pair {
        (x, y) if x == y =&gt; println!(&quot;둘이 서로 같습니다&quot;),
        // 여기 ^ `if 조건문` 부분이 매치 가드입니다
        (x, y) if x + y == 0 =&gt; println!(&quot;둘은 상반 관계입니다!&quot;),
        (x, _) if x % 2 == 1 =&gt; println!(&quot;첫 번째 값은 홀수입니다&quot;),
        _ =&gt; println!(&quot;서로 상관없는 값이네요...&quot;),
    }
}
</code></pre></pre>
<p>단, 컴파일러는 표현식의 모든 가능성이
검사되었는지 임의로 평가하지 않습니다.
따라서 마지막에 <code>_</code> 패턴을 반드시 사용해야 합니다.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let number: u8 = 4;

    match number {
        i if i == 0 =&gt; println!(&quot;0&quot;),
        i if i &gt; 0 =&gt; println!(&quot;0보다 큼&quot;),
        _ =&gt; println!(&quot;그냥 통과&quot;), // 이 부분은 도달할 수 없어야 합니다
    }
}
</code></pre></pre>
<h3 id="see-also-19"><a class="header" href="#see-also-19">See also:</a></h3>
<p><a href="flow_control/match/../../primitives/tuples.html">튜플</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="바인딩"><a class="header" href="#바인딩">바인딩</a></h1>
<p>변수에 간접적으로 접근하면 분기 이후에 다시 바인딩하지 않고는
해당 변수를 사용할 수 없습니다. <code>match</code> 에서 <code>@</code>를 이용하면
값을 어떤 이름에 바인딩할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable">// `age` 함수는 `u32` 타입을 반환합니다.
fn age() -&gt; u32 {
    15
}

fn main() {
    println!(&quot;당신은 나이는?&quot;);

    match age() {
        0             =&gt; println!(&quot;아직 돌잔치도 못했습니다&quot;),
        // 1 ..= 12에 바로 매칭시킬 수도 있지만,
        // 이 경우 나이 값이 어떤지 알 수 없습니다.
        // `n`에 1 ..= 12를 바인딩하면 나이를 알 수 있습니다.
        n @ 1  ..= 12 =&gt; println!(&quot;{:?}살 어린이입니다&quot;, n),
        n @ 13 ..= 19 =&gt; println!(&quot;{:?}살 청소년입니다&quot;, n),
        // 바인딩 된 것이 없습니다. 결과를 반환합니다.
        n             =&gt; println!(&quot;{:?}세 성인입니다.&quot;, n),
    }
}
</code></pre></pre>
<p>바인딩으로 <code>enum</code> variant를 해체할 수도 있습니다. <code>Option</code>처럼 말이죠.</p>
<pre><pre class="playground"><code class="language-rust editable">fn some_number() -&gt; Option&lt;u32&gt; {
    Some(42)
}

fn main() {
    match some_number() {
        // `Some` variant를 얻어내고, 값이 42로 일치하면
        // `n`에 바인딩합니다.
        Some(n @ 42) =&gt; println!(&quot;답: {}!&quot;, n),
        // 그 외 값에 매칭
        Some(n)      =&gt; println!(&quot;관심 없음... {}&quot;, n),
        // 어떤 것과도 매칭되지 않음 (`None` variant일 경우).
        _            =&gt; (),
    }
}
</code></pre></pre>
<h3 id="see-also-20"><a class="header" href="#see-also-20">See also:</a></h3>
<p><a href="flow_control/match/../../fn.html">함수</a>, <a href="flow_control/match/../../custom_types/enum.html">열거형</a>, <a href="flow_control/match/../../std/option.html"><code>Option</code></a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="if-let"><a class="header" href="#if-let">if let</a></h1>
<p>열거형을 매칭하는 상황 중, <code>match</code>를 사용하기에는 불편한 경우가 있습니다.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `Option&lt;i32&gt;` 타입 `optional`를 생성합니다
let optional = Some(7);

match optional {
    Some(i) =&gt; {
        println!(&quot;대충 긴 문자열, `{:?}`&quot;, i);
        // ^ `i`를 해체하기까지, 들여쓰기를
        // 두 번이나 해야 합니다.
    },
    _ =&gt; {},
    // ^ `match`는 모든 경우를 처리해야 하기 때문에, 이 부분은 필수적입니다.
    // 하지만 굳이 필요할까요?
};

<span class="boring">}
</span></code></pre></pre>
<p>이 사례에는 <code>if let</code>이 더 깔끔하며,
다양한 실패 옵션을 지정할 수도 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    // 전부 `Option&lt;i32&gt;` 타입입니다
    let number = Some(7);
    let letter: Option&lt;i32&gt; = None;
    let emoticon: Option&lt;i32&gt; = None;

    // `if let` 구문은 다음과 같이 읽습니다.
    // &quot;만약 `number`가 `Some(i)`로 해체된다면 블록(`{}`)을 평가해라.&quot;
    if let Some(i) = number {
        println!(&quot;일치합니다! {:?}&quot;, i);
    }

    // 실패할 경우를 지정하려면 `else`를 사용합니다.
    if let Some(i) = letter {
        println!(&quot;일치합니다! {:?}&quot;, i);
    } else {
        // 해체 실패했습니다. 실패했을 경우로 변경합니다.
        println!(&quot;일치하지 않는 숫자입니다. 문자를 이용해 주세요!&quot;);
    }

    // 변할 가능성이 있는 실패 조건
    let i_like_letters = false;

    if let Some(i) = emoticon {
        println!(&quot;일치합니다! {:?}&quot;, i);
    // 해체 실패했습니다. `else if` 조건을 평가하여
    // 이 분기를 선택해야 하는지 확인합니다.
    } else if i_like_letters {
        println!(&quot;일치하지 않는 숫자입니다. 문자를 이용해 주세요!&quot;);
    } else {
        // 조건이 false로 평가되었습니다. 이 분기가 기본값입니다.
        println!(&quot;문자는 선호하지 않습니다. 이모티콘을 이용해 주세요!&quot;);
    }
}
</code></pre></pre>
<p>같은 방식으로, <code>if let</code>를 사용해 어떤 열거형 값이든 매칭할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable">// 열거형 예시
enum Foo {
    Bar,
    Baz,
    Qux(u32)
}

fn main() {
    // 변수 예시 생성
    let a = Foo::Bar;
    let b = Foo::Baz;
    let c = Foo::Qux(100);
    
    // Foo::Bar에 매칭되는 변수
    if let Foo::Bar = a {
        println!(&quot;a는 foobar입니다&quot;);
    }
    
    // 변수 b는 Foo::Bar에 매칭되지 않습니다.
    // 따라서 아무것도 출력되지 않습니다.
    if let Foo::Bar = b {
        println!(&quot;b는 foobar입니다&quot;);
    }
    
    // 변수 c는 Foo::Qux와 매칭됩니다.
    // Foo::Quax는 이전 예제의 Some()처럼 값을 가지고 있습니다.
    if let Foo::Qux(value) = c {
        println!(&quot;c는 {}입니다&quot;, value);
    }

    // `if let`에서도 바인딩을 사용할 수 있습니다.
    if let Foo::Qux(value @ 100) = c {
        println!(&quot;c는 100입니다&quot;);
    }
}
</code></pre></pre>
<p><code>if let</code>의 또 다른 장점은 매개변수화되지 않은 열거형 variant와 매치할 수 있다는 것입니다. 열거형이 <code>PartialEq</code>를 구현하거나 derive하지 않아도 말이죠. 이 경우, 열거형의 인스턴스를 동일시할 수 없으므로 <code>if Foo::Bar == a</code>는 컴파일할 수 없지만, <code>if let</code>은 가능합니다.</p>
<p>직접 해보시겠나요? <code>if let</code>을 사용해 다음 예제를 고쳐보세요.</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">// 이 열거형은 의도적으로 PartialEq를 구현하거나 derive하지 않습니다.
// 따라서 이후의 Foo::Bar == a 비교는 실패합니다.
enum Foo {Bar}

fn main() {
    let a = Foo::Bar;

    // 변수 a는 Foo::Bar와 매칭됩니다
    if Foo::Bar == a {
    // ^-- 컴파일 에러가 나타납니다. `if let`을 사용하세요.
        println!(&quot;a는 foobar입니다&quot;);
    }
}
</code></pre></pre>
<h3 id="see-also-21"><a class="header" href="#see-also-21">See also:</a></h3>
<p><a href="flow_control/../custom_types/enum.html">열거형</a>, <a href="flow_control/../std/option.html"><code>Option</code></a>, <a href="https://github.com/rust-lang/rfcs/pull/160">RFC</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="while-let"><a class="header" href="#while-let">while let</a></h1>
<p><code>if let</code> 처럼, <code>while let</code>을 사용하면 불편한 <code>macth</code> 배열을
더 괜찮게 바꿀 수 있습니다. <code>i</code>를 증가시키는 예시를 생각해보죠.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `Option&lt;i32&gt;` 타입 `optional`를 생성합니다
let mut optional = Some(0);

// 반복해서 검사합니다.
loop {
    match optional {
        // `optional`이 해체되었다면 블록을 평가합니다.
        Some(i) =&gt; {
            if i &gt; 9 {
                println!(&quot;9보다 큽니다. 끝!&quot;);
                optional = None;
            } else {
                println!(&quot;`i`는 `{:?}입니다`. 다시 시도합니다.&quot;, i);
                optional = Some(i + 1);
            }
            // ^ 들여쓰기를 세 번이나 해야 합니다!
        },
        // 해체 실패 시 반복문을 이탈합니다.
        _ =&gt; { break; }
        // ^ 굳이 필요할까요? 더 좋은 방법을 찾아봅시다!
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>while let</code>을 사용하면 훨씬 나아집니다.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    // `Option&lt;i32&gt;` 타입 `optional`를 생성합니다
    let mut optional = Some(0);

    // 여긴 다음과 같이 읽습니다. &quot;`optional`이 `Some(i)`로
    // 해체 가능한 동안에는 블록(`{}`)을 평가하고, 아니라면 `break` 해라.&quot;
    while let Some(i) = optional {
        if i &gt; 9 {
            println!(&quot;9보다 큽니다. 끝!&quot;);
            optional = None;
        } else {
            println!(&quot;`i`는 `{:?}입니다`. 다시 시도합니다.&quot;, i);
            optional = Some(i + 1);
        }
        // ^ 오른쪽으로 덜 밀려났으며, 해체 실패한 경우를
        // 명시적으로 처리할 필요가 없습니다.
    }
    // ^ `if let`에는 `else`/`else if`를 추가할 수 있지만,
    // `while let`은 불가능합니다.
}
</code></pre></pre>
<h3 id="see-also-22"><a class="header" href="#see-also-22">See also:</a></h3>
<p><a href="flow_control/../custom_types/enum.html">열거형</a>, <a href="flow_control/../std/option.html"><code>Option</code></a>, <a href="https://github.com/rust-lang/rfcs/pull/214">RFC</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>Functions are declared using the <code>fn</code> keyword. Its arguments are type
annotated, just like variables, and, if the function returns a value, the
return type must be specified after an arrow <code>-&gt;</code>.</p>
<p>The final expression in the function will be used as return value.
Alternatively, the <code>return</code> statement can be used to return a value earlier
from within the function, even from inside loops or <code>if</code> statements.</p>
<p>Let's rewrite FizzBuzz using functions!</p>
<pre><pre class="playground"><code class="language-rust editable">// Unlike C/C++, there's no restriction on the order of function definitions
fn main() {
    // We can use this function here, and define it somewhere later
    fizzbuzz_to(100);
}

// Function that returns a boolean value
fn is_divisible_by(lhs: u32, rhs: u32) -&gt; bool {
    // Corner case, early return
    if rhs == 0 {
        return false;
    }

    // This is an expression, the `return` keyword is not necessary here
    lhs % rhs == 0
}

// Functions that &quot;don't&quot; return a value, actually return the unit type `()`
fn fizzbuzz(n: u32) -&gt; () {
    if is_divisible_by(n, 15) {
        println!(&quot;fizzbuzz&quot;);
    } else if is_divisible_by(n, 3) {
        println!(&quot;fizz&quot;);
    } else if is_divisible_by(n, 5) {
        println!(&quot;buzz&quot;);
    } else {
        println!(&quot;{}&quot;, n);
    }
}

// When a function returns `()`, the return type can be omitted from the
// signature
fn fizzbuzz_to(n: u32) {
    for n in 1..n + 1 {
        fizzbuzz(n);
    }
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="methods"><a class="header" href="#methods">Methods</a></h1>
<p>Methods are functions attached to objects. These methods have access to the
data of the object and its other methods via the <code>self</code> keyword. Methods are
defined under an <code>impl</code> block.</p>
<pre><pre class="playground"><code class="language-rust editable">struct Point {
    x: f64,
    y: f64,
}

// Implementation block, all `Point` methods go in here
impl Point {
    // This is a static method
    // Static methods don't need to be called by an instance
    // These methods are generally used as constructors
    fn origin() -&gt; Point {
        Point { x: 0.0, y: 0.0 }
    }

    // Another static method, taking two arguments:
    fn new(x: f64, y: f64) -&gt; Point {
        Point { x: x, y: y }
    }
}

struct Rectangle {
    p1: Point,
    p2: Point,
}

impl Rectangle {
    // This is an instance method
    // `&amp;self` is sugar for `self: &amp;Self`, where `Self` is the type of the
    // caller object. In this case `Self` = `Rectangle`
    fn area(&amp;self) -&gt; f64 {
        // `self` gives access to the struct fields via the dot operator
        let Point { x: x1, y: y1 } = self.p1;
        let Point { x: x2, y: y2 } = self.p2;

        // `abs` is a `f64` method that returns the absolute value of the
        // caller
        ((x1 - x2) * (y1 - y2)).abs()
    }

    fn perimeter(&amp;self) -&gt; f64 {
        let Point { x: x1, y: y1 } = self.p1;
        let Point { x: x2, y: y2 } = self.p2;

        2.0 * ((x1 - x2).abs() + (y1 - y2).abs())
    }

    // This method requires the caller object to be mutable
    // `&amp;mut self` desugars to `self: &amp;mut Self`
    fn translate(&amp;mut self, x: f64, y: f64) {
        self.p1.x += x;
        self.p2.x += x;

        self.p1.y += y;
        self.p2.y += y;
    }
}

// `Pair` owns resources: two heap allocated integers
struct Pair(Box&lt;i32&gt;, Box&lt;i32&gt;);

impl Pair {
    // This method &quot;consumes&quot; the resources of the caller object
    // `self` desugars to `self: Self`
    fn destroy(self) {
        // Destructure `self`
        let Pair(first, second) = self;

        println!(&quot;Destroying Pair({}, {})&quot;, first, second);

        // `first` and `second` go out of scope and get freed
    }
}

fn main() {
    let rectangle = Rectangle {
        // Static methods are called using double colons
        p1: Point::origin(),
        p2: Point::new(3.0, 4.0),
    };

    // Instance methods are called using the dot operator
    // Note that the first argument `&amp;self` is implicitly passed, i.e.
    // `rectangle.perimeter()` === `Rectangle::perimeter(&amp;rectangle)`
    println!(&quot;Rectangle perimeter: {}&quot;, rectangle.perimeter());
    println!(&quot;Rectangle area: {}&quot;, rectangle.area());

    let mut square = Rectangle {
        p1: Point::origin(),
        p2: Point::new(1.0, 1.0),
    };

    // Error! `rectangle` is immutable, but this method requires a mutable
    // object
    //rectangle.translate(1.0, 0.0);
    // TODO ^ Try uncommenting this line

    // Okay! Mutable objects can call mutable methods
    square.translate(1.0, 1.0);

    let pair = Pair(Box::new(1), Box::new(2));

    pair.destroy();

    // Error! Previous `destroy` call &quot;consumed&quot; `pair`
    //pair.destroy();
    // TODO ^ Try uncommenting this line
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="closures"><a class="header" href="#closures">Closures</a></h1>
<p>Closures are functions that can capture the enclosing environment. For
example, a closure that captures the x variable:</p>
<pre><code class="language-Rust">|val| val + x
</code></pre>
<p>The syntax and capabilities of closures make them very convenient for
on the fly usage. Calling a closure is exactly like calling a function.
However, both input and return types <em>can</em> be inferred and input
variable names <em>must</em> be specified.</p>
<p>Other characteristics of closures include:</p>
<ul>
<li>using <code>||</code> instead of <code>()</code> around input variables.</li>
<li>optional body delimination (<code>{}</code>) for a single expression (mandatory otherwise).</li>
<li>the ability to capture the outer environment variables.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    // Increment via closures and functions.
    fn function(i: i32) -&gt; i32 { i + 1 }

    // Closures are anonymous, here we are binding them to references
    // Annotation is identical to function annotation but is optional
    // as are the `{}` wrapping the body. These nameless functions
    // are assigned to appropriately named variables.
    let closure_annotated = |i: i32| -&gt; i32 { i + 1 };
    let closure_inferred  = |i     |          i + 1  ;

    let i = 1;
    // Call the function and closures.
    println!(&quot;function: {}&quot;, function(i));
    println!(&quot;closure_annotated: {}&quot;, closure_annotated(i));
    println!(&quot;closure_inferred: {}&quot;, closure_inferred(i));

    // A closure taking no arguments which returns an `i32`.
    // The return type is inferred.
    let one = || 1;
    println!(&quot;closure returning one: {}&quot;, one());

}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="capturing"><a class="header" href="#capturing">Capturing</a></h1>
<p>Closures are inherently flexible and will do what the functionality requires
to make the closure work without annotation. This allows capturing to
flexibly adapt to the use case, sometimes moving and sometimes borrowing.
Closures can capture variables:</p>
<ul>
<li>by reference: <code>&amp;T</code></li>
<li>by mutable reference: <code>&amp;mut T</code></li>
<li>by value: <code>T</code></li>
</ul>
<p>They preferentially capture variables by reference and only go lower when
required.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    use std::mem;
    
    let color = String::from(&quot;green&quot;);

    // A closure to print `color` which immediately borrows (`&amp;`) `color` and
    // stores the borrow and closure in the `print` variable. It will remain
    // borrowed until `print` is used the last time. 
    //
    // `println!` only requires arguments by immutable reference so it doesn't
    // impose anything more restrictive.
    let print = || println!(&quot;`color`: {}&quot;, color);

    // Call the closure using the borrow.
    print();

    // `color` can be borrowed immutably again, because the closure only holds
    // an immutable reference to `color`. 
    let _reborrow = &amp;color;
    print();

    // A move or reborrow is allowed after the final use of `print`
    let _color_moved = color;


    let mut count = 0;
    // A closure to increment `count` could take either `&amp;mut count` or `count`
    // but `&amp;mut count` is less restrictive so it takes that. Immediately
    // borrows `count`.
    //
    // A `mut` is required on `inc` because a `&amp;mut` is stored inside. Thus,
    // calling the closure mutates the closure which requires a `mut`.
    let mut inc = || {
        count += 1;
        println!(&quot;`count`: {}&quot;, count);
    };

    // Call the closure using a mutable borrow.
    inc();

    // The closure still mutably borrows `count` because it is called later.
    // An attempt to reborrow will lead to an error.
    // let _reborrow = &amp;count; 
    // ^ TODO: try uncommenting this line.
    inc();

    // The closure no longer needs to borrow `&amp;mut count`. Therefore, it is
    // possible to reborrow without an error
    let _count_reborrowed = &amp;mut count; 

    
    // A non-copy type.
    let movable = Box::new(3);

    // `mem::drop` requires `T` so this must take by value. A copy type
    // would copy into the closure leaving the original untouched.
    // A non-copy must move and so `movable` immediately moves into
    // the closure.
    let consume = || {
        println!(&quot;`movable`: {:?}&quot;, movable);
        mem::drop(movable);
    };

    // `consume` consumes the variable so this can only be called once.
    consume();
    // consume();
    // ^ TODO: Try uncommenting this line.
}
</code></pre></pre>
<p>Using <code>move</code> before vertical pipes forces closure
to take ownership of captured variables:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    // `Vec` has non-copy semantics.
    let haystack = vec![1, 2, 3];

    let contains = move |needle| haystack.contains(needle);

    println!(&quot;{}&quot;, contains(&amp;1));
    println!(&quot;{}&quot;, contains(&amp;4));

    // println!(&quot;There're {} elements in vec&quot;, haystack.len());
    // ^ Uncommenting above line will result in compile-time error
    // because borrow checker doesn't allow re-using variable after it
    // has been moved.
    
    // Removing `move` from closure's signature will cause closure
    // to borrow _haystack_ variable immutably, hence _haystack_ is still
    // available and uncommenting above line will not cause an error.
}
</code></pre></pre>
<h3 id="see-also-23"><a class="header" href="#see-also-23">See also:</a></h3>
<p><a href="fn/closures/../../std/box.html"><code>Box</code></a> and <a href="https://doc.rust-lang.org/std/mem/fn.drop.html"><code>std::mem::drop</code></a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="as-input-parameters"><a class="header" href="#as-input-parameters">As input parameters</a></h1>
<p>While Rust chooses how to capture variables on the fly mostly without type
annotation, this ambiguity is not allowed when writing functions. When
taking a closure as an input parameter, the closure's complete type must be
annotated using one of a few <code>traits</code>. In order of decreasing restriction,
they are:</p>
<ul>
<li><code>Fn</code>: the closure captures by reference (<code>&amp;T</code>)</li>
<li><code>FnMut</code>: the closure captures by mutable reference (<code>&amp;mut T</code>)</li>
<li><code>FnOnce</code>: the closure captures by value (<code>T</code>)</li>
</ul>
<p>On a variable-by-variable basis, the compiler will capture variables in the
least restrictive manner possible.</p>
<p>For instance, consider a parameter annotated as <code>FnOnce</code>. This specifies
that the closure <em>may</em> capture by <code>&amp;T</code>, <code>&amp;mut T</code>, or <code>T</code>, but the compiler
will ultimately choose based on how the captured variables are used in the
closure.</p>
<p>This is because if a move is possible, then any type of borrow should also
be possible. Note that the reverse is not true. If the parameter is
annotated as <code>Fn</code>, then capturing variables by <code>&amp;mut T</code> or <code>T</code> are not
allowed.</p>
<p>In the following example, try swapping the usage of <code>Fn</code>, <code>FnMut</code>, and
<code>FnOnce</code> to see what happens:</p>
<pre><pre class="playground"><code class="language-rust editable">// A function which takes a closure as an argument and calls it.
// &lt;F&gt; denotes that F is a &quot;Generic type parameter&quot;
fn apply&lt;F&gt;(f: F) where
    // The closure takes no input and returns nothing.
    F: FnOnce() {
    // ^ TODO: Try changing this to `Fn` or `FnMut`.

    f();
}

// A function which takes a closure and returns an `i32`.
fn apply_to_3&lt;F&gt;(f: F) -&gt; i32 where
    // The closure takes an `i32` and returns an `i32`.
    F: Fn(i32) -&gt; i32 {

    f(3)
}

fn main() {
    use std::mem;

    let greeting = &quot;hello&quot;;
    // A non-copy type.
    // `to_owned` creates owned data from borrowed one
    let mut farewell = &quot;goodbye&quot;.to_owned();

    // Capture 2 variables: `greeting` by reference and
    // `farewell` by value.
    let diary = || {
        // `greeting` is by reference: requires `Fn`.
        println!(&quot;I said {}.&quot;, greeting);

        // Mutation forces `farewell` to be captured by
        // mutable reference. Now requires `FnMut`.
        farewell.push_str(&quot;!!!&quot;);
        println!(&quot;Then I screamed {}.&quot;, farewell);
        println!(&quot;Now I can sleep. zzzzz&quot;);

        // Manually calling drop forces `farewell` to
        // be captured by value. Now requires `FnOnce`.
        mem::drop(farewell);
    };

    // Call the function which applies the closure.
    apply(diary);

    // `double` satisfies `apply_to_3`'s trait bound
    let double = |x| 2 * x;

    println!(&quot;3 doubled: {}&quot;, apply_to_3(double));
}
</code></pre></pre>
<h3 id="see-also-24"><a class="header" href="#see-also-24">See also:</a></h3>
<p><a href="https://doc.rust-lang.org/std/mem/fn.drop.html"><code>std::mem::drop</code></a>, <a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a>, <a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a>, <a href="fn/closures/../../generics.html">Generics</a>, <a href="fn/closures/../../generics/where.html">where</a> and <a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="type-anonymity"><a class="header" href="#type-anonymity">Type anonymity</a></h1>
<p>Closures succinctly capture variables from enclosing scopes. Does this have
any consequences? It surely does. Observe how using a closure as a function
parameter requires <a href="fn/closures/../../generics.html">generics</a>, which is necessary because of how they are
defined:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `F` must be generic.
fn apply&lt;F&gt;(f: F) where
    F: FnOnce() {
    f();
}
<span class="boring">}
</span></code></pre></pre>
<p>When a closure is defined, the compiler implicitly creates a new
anonymous structure to store the captured variables inside, meanwhile
implementing the functionality via one of the <code>traits</code>: <code>Fn</code>, <code>FnMut</code>, or
<code>FnOnce</code> for this unknown type. This type is assigned to the variable which
is stored until calling.</p>
<p>Since this new type is of unknown type, any usage in a function will require
generics. However, an unbounded type parameter <code>&lt;T&gt;</code> would still be ambiguous
and not be allowed. Thus, bounding by one of the <code>traits</code>: <code>Fn</code>, <code>FnMut</code>, or
<code>FnOnce</code> (which it implements) is sufficient to specify its type.</p>
<pre><pre class="playground"><code class="language-rust editable">// `F` must implement `Fn` for a closure which takes no
// inputs and returns nothing - exactly what is required
// for `print`.
fn apply&lt;F&gt;(f: F) where
    F: Fn() {
    f();
}

fn main() {
    let x = 7;

    // Capture `x` into an anonymous type and implement
    // `Fn` for it. Store it in `print`.
    let print = || println!(&quot;{}&quot;, x);

    apply(print);
}
</code></pre></pre>
<h3 id="see-also-25"><a class="header" href="#see-also-25">See also:</a></h3>
<p><a href="https://huonw.github.io/blog/2015/05/finding-closure-in-rust/">A thorough analysis</a>, <a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a>, <a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a>,
and <a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="input-functions"><a class="header" href="#input-functions">Input functions</a></h1>
<p>Since closures may be used as arguments, you might wonder if the same can be said
about functions. And indeed they can! If you declare a function that takes a
closure as parameter, then any function that satisfies the trait bound of that
closure can be passed as a parameter.</p>
<pre><pre class="playground"><code class="language-rust editable">// Define a function which takes a generic `F` argument
// bounded by `Fn`, and calls it
fn call_me&lt;F: Fn()&gt;(f: F) {
    f();
}

// Define a wrapper function satisfying the `Fn` bound
fn function() {
    println!(&quot;I'm a function!&quot;);
}

fn main() {
    // Define a closure satisfying the `Fn` bound
    let closure = || println!(&quot;I'm a closure!&quot;);

    call_me(closure);
    call_me(function);
}
</code></pre></pre>
<p>As an additional note, the <code>Fn</code>, <code>FnMut</code>, and <code>FnOnce</code> <code>traits</code> dictate how
a closure captures variables from the enclosing scope.</p>
<h3 id="see-also-26"><a class="header" href="#see-also-26">See also:</a></h3>
<p><a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a>, <a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a>, and <a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="as-output-parameters"><a class="header" href="#as-output-parameters">As output parameters</a></h1>
<p>Closures as input parameters are possible, so returning closures as
output parameters should also be possible. However, anonymous
closure types are, by definition, unknown, so we have to use
<code>impl Trait</code> to return them.</p>
<p>The valid traits for returning a closure are:</p>
<ul>
<li><code>Fn</code></li>
<li><code>FnMut</code></li>
<li><code>FnOnce</code></li>
</ul>
<p>Beyond this, the <code>move</code> keyword must be used, which signals that all captures
occur by value. This is required because any captures by reference would be
dropped as soon as the function exited, leaving invalid references in the
closure.</p>
<pre><pre class="playground"><code class="language-rust editable">fn create_fn() -&gt; impl Fn() {
    let text = &quot;Fn&quot;.to_owned();

    move || println!(&quot;This is a: {}&quot;, text)
}

fn create_fnmut() -&gt; impl FnMut() {
    let text = &quot;FnMut&quot;.to_owned();

    move || println!(&quot;This is a: {}&quot;, text)
}

fn create_fnonce() -&gt; impl FnOnce() {
    let text = &quot;FnOnce&quot;.to_owned();

    move || println!(&quot;This is a: {}&quot;, text)
}

fn main() {
    let fn_plain = create_fn();
    let mut fn_mut = create_fnmut();
    let fn_once = create_fnonce();

    fn_plain();
    fn_mut();
    fn_once();
}
</code></pre></pre>
<h3 id="see-also-27"><a class="header" href="#see-also-27">See also:</a></h3>
<p><a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a>, <a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a>, <a href="fn/closures/../../generics.html">Generics</a> and <a href="fn/closures/../../trait/impl_trait.html">impl Trait</a>.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="examples-in-std"><a class="header" href="#examples-in-std">Examples in <code>std</code></a></h1>
<p>This section contains a few examples of using closures from the <code>std</code> library.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="iteratorany"><a class="header" href="#iteratorany">Iterator::any</a></h1>
<p><code>Iterator::any</code> is a function which when passed an iterator, will return
<code>true</code> if any element satisfies the predicate. Otherwise <code>false</code>. Its
signature:</p>
<pre><code class="language-rust ignore">pub trait Iterator {
    // The type being iterated over.
    type Item;

    // `any` takes `&amp;mut self` meaning the caller may be borrowed
    // and modified, but not consumed.
    fn any&lt;F&gt;(&amp;mut self, f: F) -&gt; bool where
        // `FnMut` meaning any captured variable may at most be
        // modified, not consumed. `Self::Item` states it takes
        // arguments to the closure by value.
        F: FnMut(Self::Item) -&gt; bool {}
}
</code></pre>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let vec1 = vec![1, 2, 3];
    let vec2 = vec![4, 5, 6];

    // `iter()` for vecs yields `&amp;i32`. Destructure to `i32`.
    println!(&quot;2 in vec1: {}&quot;, vec1.iter()     .any(|&amp;x| x == 2));
    // `into_iter()` for vecs yields `i32`. No destructuring required.
    println!(&quot;2 in vec2: {}&quot;, vec2.into_iter().any(| x| x == 2));

    let array1 = [1, 2, 3];
    let array2 = [4, 5, 6];

    // `iter()` for arrays yields `&amp;i32`.
    println!(&quot;2 in array1: {}&quot;, array1.iter()     .any(|&amp;x| x == 2));
    // `into_iter()` for arrays unusually yields `&amp;i32`.
    println!(&quot;2 in array2: {}&quot;, array2.into_iter().any(|&amp;x| x == 2));
}
</code></pre></pre>
<h3 id="see-also-28"><a class="header" href="#see-also-28">See also:</a></h3>
<p><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.any"><code>std::iter::Iterator::any</code></a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="searching-through-iterators"><a class="header" href="#searching-through-iterators">Searching through iterators</a></h1>
<p><code>Iterator::find</code> is a function which iterates over an iterator and searches for the 
first value which satisfies some condition. If none of the values satisfy the 
condition, it returns <code>None</code>. Its signature:</p>
<pre><code class="language-rust ignore">pub trait Iterator {
    // The type being iterated over.
    type Item;

    // `find` takes `&amp;mut self` meaning the caller may be borrowed
    // and modified, but not consumed.
    fn find&lt;P&gt;(&amp;mut self, predicate: P) -&gt; Option&lt;Self::Item&gt; where
        // `FnMut` meaning any captured variable may at most be
        // modified, not consumed. `&amp;Self::Item` states it takes
        // arguments to the closure by reference.
        P: FnMut(&amp;Self::Item) -&gt; bool {}
}
</code></pre>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let vec1 = vec![1, 2, 3];
    let vec2 = vec![4, 5, 6];

    // `iter()` for vecs yields `&amp;i32`.
    let mut iter = vec1.iter();
    // `into_iter()` for vecs yields `i32`.
    let mut into_iter = vec2.into_iter();

    // `iter()` for vecs yields `&amp;i32`, and we want to reference one of its
    // items, so we have to destructure `&amp;&amp;i32` to `i32`
    println!(&quot;Find 2 in vec1: {:?}&quot;, iter     .find(|&amp;&amp;x| x == 2));
    // `into_iter()` for vecs yields `i32`, and we want to reference one of
    // its items, so we have to destructure `&amp;i32` to `i32`
    println!(&quot;Find 2 in vec2: {:?}&quot;, into_iter.find(| &amp;x| x == 2));

    let array1 = [1, 2, 3];
    let array2 = [4, 5, 6];

    // `iter()` for arrays yields `&amp;i32`
    println!(&quot;Find 2 in array1: {:?}&quot;, array1.iter()     .find(|&amp;&amp;x| x == 2));
    // `into_iter()` for arrays unusually yields `&amp;i32`
    println!(&quot;Find 2 in array2: {:?}&quot;, array2.into_iter().find(|&amp;&amp;x| x == 2));
}
</code></pre></pre>
<p><code>Iterator::find</code> gives you a reference to the item. But if you want the <em>index</em> of the
item, use <code>Iterator::position</code>.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let vec = vec![1, 9, 3, 3, 13, 2];

    let index_of_first_even_number = vec.iter().position(|x| x % 2 == 0);
    assert_eq!(index_of_first_even_number, Some(5));
    
    
    let index_of_first_negative_number = vec.iter().position(|x| x &lt; &amp;0);
    assert_eq!(index_of_first_negative_number, None);
}
</code></pre></pre>
<h3 id="see-also-29"><a class="header" href="#see-also-29">See also:</a></h3>
<p><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.find"><code>std::iter::Iterator::find</code></a></p>
<p><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.find_map"><code>std::iter::Iterator::find_map</code></a></p>
<p><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.position"><code>std::iter::Iterator::position</code></a></p>
<p><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.rposition"><code>std::iter::Iterator::rposition</code></a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="higher-order-functions"><a class="header" href="#higher-order-functions">Higher Order Functions</a></h1>
<p>Rust provides Higher Order Functions (HOF). These are functions that
take one or more functions and/or produce a more useful function. HOFs
and lazy iterators give Rust its functional flavor.</p>
<pre><pre class="playground"><code class="language-rust editable">fn is_odd(n: u32) -&gt; bool {
    n % 2 == 1
}

fn main() {
    println!(&quot;Find the sum of all the squared odd numbers under 1000&quot;);
    let upper = 1000;

    // Imperative approach
    // Declare accumulator variable
    let mut acc = 0;
    // Iterate: 0, 1, 2, ... to infinity
    for n in 0.. {
        // Square the number
        let n_squared = n * n;

        if n_squared &gt;= upper {
            // Break loop if exceeded the upper limit
            break;
        } else if is_odd(n_squared) {
            // Accumulate value, if it's odd
            acc += n_squared;
        }
    }
    println!(&quot;imperative style: {}&quot;, acc);

    // Functional approach
    let sum_of_squared_odd_numbers: u32 =
        (0..).map(|n| n * n)                             // All natural numbers squared
             .take_while(|&amp;n_squared| n_squared &lt; upper) // Below upper limit
             .filter(|&amp;n_squared| is_odd(n_squared))     // That are odd
             .fold(0, |acc, n_squared| acc + n_squared); // Sum them
    println!(&quot;functional style: {}&quot;, sum_of_squared_odd_numbers);
}
</code></pre></pre>
<p><a href="https://doc.rust-lang.org/core/option/enum.Option.html">Option</a>
and
<a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html">Iterator</a>
implement their fair share of HOFs.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="diverging-functions"><a class="header" href="#diverging-functions">Diverging functions</a></h1>
<p>Diverging functions never return. They are marked using <code>!</code>, which is an empty type.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() -&gt; ! {
    panic!(&quot;This call never returns.&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>As opposed to all the other types, this one cannot be instantiated, because the
set of all possible values this type can have is empty. Note that, it is
different from the <code>()</code> type, which has exactly one possible value.</p>
<p>For example, this function returns as usual, although there is no information
in the return value.</p>
<pre><pre class="playground"><code class="language-rust">fn some_fn() {
    ()
}

fn main() {
    let a: () = some_fn();
    println!(&quot;This function returns and you can see this line.&quot;)
}
</code></pre></pre>
<p>As opposed to this function, which will never return the control back to the caller.</p>
<pre><code class="language-rust ignore">#![feature(never_type)]

fn main() {
    let x: ! = panic!(&quot;This call never returns.&quot;);
    println!(&quot;You will never see this line!&quot;);
}
</code></pre>
<p>Although this might seem like an abstract concept, it is in fact very useful and
often handy. The main advantage of this type is that it can be cast to any other
one and therefore used at places where an exact type is required, for instance
in <code>match</code> branches. This allows us to write code like this:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    fn sum_odd_numbers(up_to: u32) -&gt; u32 {
        let mut acc = 0;
        for i in 0..up_to {
            // Notice that the return type of this match expression must be u32
            // because of the type of the &quot;addition&quot; variable.
            let addition: u32 = match i%2 == 1 {
                // The &quot;i&quot; variable is of type u32, which is perfectly fine.
                true =&gt; i,
                // On the other hand, the &quot;continue&quot; expression does not return
                // u32, but it is still fine, because it never returns and therefore
                // does not violate the type requirements of the match expression.
                false =&gt; continue,
            };
            acc += addition;
        }
        acc
    }
    println!(&quot;Sum of odd numbers up to 9 (excluding): {}&quot;, sum_odd_numbers(9));
}
</code></pre></pre>
<p>It is also the return type of functions that loop forever (e.g. <code>loop {}</code>) like
network servers or functions that terminate the process (e.g. <code>exit()</code>).</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="modules"><a class="header" href="#modules">Modules</a></h1>
<p>Rust provides a powerful module system that can be used to hierarchically split
code in logical units (modules), and manage visibility (public/private) between
them.</p>
<p>A module is a collection of items: functions, structs, traits, <code>impl</code> blocks,
and even other modules.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="visibility"><a class="header" href="#visibility">Visibility</a></h1>
<p>By default, the items in a module have private visibility, but this can be
overridden with the <code>pub</code> modifier. Only the public items of a module can be
accessed from outside the module scope.</p>
<pre><pre class="playground"><code class="language-rust editable">// A module named `my_mod`
mod my_mod {
    // Items in modules default to private visibility.
    fn private_function() {
        println!(&quot;called `my_mod::private_function()`&quot;);
    }

    // Use the `pub` modifier to override default visibility.
    pub fn function() {
        println!(&quot;called `my_mod::function()`&quot;);
    }

    // Items can access other items in the same module,
    // even when private.
    pub fn indirect_access() {
        print!(&quot;called `my_mod::indirect_access()`, that\n&gt; &quot;);
        private_function();
    }

    // Modules can also be nested
    pub mod nested {
        pub fn function() {
            println!(&quot;called `my_mod::nested::function()`&quot;);
        }

        #[allow(dead_code)]
        fn private_function() {
            println!(&quot;called `my_mod::nested::private_function()`&quot;);
        }

        // Functions declared using `pub(in path)` syntax are only visible
        // within the given path. `path` must be a parent or ancestor module
        pub(in crate::my_mod) fn public_function_in_my_mod() {
            print!(&quot;called `my_mod::nested::public_function_in_my_mod()`, that\n&gt; &quot;);
            public_function_in_nested();
        }

        // Functions declared using `pub(self)` syntax are only visible within
        // the current module, which is the same as leaving them private
        pub(self) fn public_function_in_nested() {
            println!(&quot;called `my_mod::nested::public_function_in_nested()`&quot;);
        }

        // Functions declared using `pub(super)` syntax are only visible within
        // the parent module
        pub(super) fn public_function_in_super_mod() {
            println!(&quot;called `my_mod::nested::public_function_in_super_mod()`&quot;);
        }
    }

    pub fn call_public_function_in_my_mod() {
        print!(&quot;called `my_mod::call_public_function_in_my_mod()`, that\n&gt; &quot;);
        nested::public_function_in_my_mod();
        print!(&quot;&gt; &quot;);
        nested::public_function_in_super_mod();
    }

    // pub(crate) makes functions visible only within the current crate
    pub(crate) fn public_function_in_crate() {
        println!(&quot;called `my_mod::public_function_in_crate()`&quot;);
    }

    // Nested modules follow the same rules for visibility
    mod private_nested {
        #[allow(dead_code)]
        pub fn function() {
            println!(&quot;called `my_mod::private_nested::function()`&quot;);
        }

        // Private parent items will still restrict the visibility of a child item,
        // even if it is declared as visible within a bigger scope.
        #[allow(dead_code)]
        pub(crate) fn restricted_function() {
            println!(&quot;called `my_mod::private_nested::restricted_function()`&quot;);
        }
    }
}

fn function() {
    println!(&quot;called `function()`&quot;);
}

fn main() {
    // Modules allow disambiguation between items that have the same name.
    function();
    my_mod::function();

    // Public items, including those inside nested modules, can be
    // accessed from outside the parent module.
    my_mod::indirect_access();
    my_mod::nested::function();
    my_mod::call_public_function_in_my_mod();

    // pub(crate) items can be called from anywhere in the same crate
    my_mod::public_function_in_crate();

    // pub(in path) items can only be called from within the module specified
    // Error! function `public_function_in_my_mod` is private
    //my_mod::nested::public_function_in_my_mod();
    // TODO ^ Try uncommenting this line

    // Private items of a module cannot be directly accessed, even if
    // nested in a public module:

    // Error! `private_function` is private
    //my_mod::private_function();
    // TODO ^ Try uncommenting this line

    // Error! `private_function` is private
    //my_mod::nested::private_function();
    // TODO ^ Try uncommenting this line

    // Error! `private_nested` is a private module
    //my_mod::private_nested::function();
    // TODO ^ Try uncommenting this line

    // Error! `private_nested` is a private module
    //my_mod::private_nested::restricted_function();
    // TODO ^ Try uncommenting this line
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="struct-visibility"><a class="header" href="#struct-visibility">Struct visibility</a></h1>
<p>Structs have an extra level of visibility with their fields. The visibility 
defaults to private, and can be overridden with the <code>pub</code> modifier. This 
visibility only matters when a struct is accessed from outside the module 
where it is defined, and has the goal of hiding information (encapsulation).</p>
<pre><pre class="playground"><code class="language-rust editable">mod my {
    // A public struct with a public field of generic type `T`
    pub struct OpenBox&lt;T&gt; {
        pub contents: T,
    }

    // A public struct with a private field of generic type `T`
    #[allow(dead_code)]
    pub struct ClosedBox&lt;T&gt; {
        contents: T,
    }

    impl&lt;T&gt; ClosedBox&lt;T&gt; {
        // A public constructor method
        pub fn new(contents: T) -&gt; ClosedBox&lt;T&gt; {
            ClosedBox {
                contents: contents,
            }
        }
    }
}

fn main() {
    // Public structs with public fields can be constructed as usual
    let open_box = my::OpenBox { contents: &quot;public information&quot; };

    // and their fields can be normally accessed.
    println!(&quot;The open box contains: {}&quot;, open_box.contents);

    // Public structs with private fields cannot be constructed using field names.
    // Error! `ClosedBox` has private fields
    //let closed_box = my::ClosedBox { contents: &quot;classified information&quot; };
    // TODO ^ Try uncommenting this line

    // However, structs with private fields can be created using
    // public constructors
    let _closed_box = my::ClosedBox::new(&quot;classified information&quot;);

    // and the private fields of a public struct cannot be accessed.
    // Error! The `contents` field is private
    //println!(&quot;The closed box contains: {}&quot;, _closed_box.contents);
    // TODO ^ Try uncommenting this line
}
</code></pre></pre>
<h3 id="see-also-30"><a class="header" href="#see-also-30">See also:</a></h3>
<p><a href="mod/../generics.html">generics</a> and <a href="mod/../fn/methods.html">methods</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="the-use-declaration"><a class="header" href="#the-use-declaration">The <code>use</code> declaration</a></h1>
<p>The <code>use</code> declaration can be used to bind a full path to a new name, for easier
access. It is often used like this:</p>
<pre><code class="language-rust editable ignore">use crate::deeply::nested::{
    my_first_function,
    my_second_function,
    AndATraitType
};

fn main() {
    my_first_function();
}
</code></pre>
<p>You can use the <code>as</code> keyword to bind imports to a different name:</p>
<pre><pre class="playground"><code class="language-rust editable">// Bind the `deeply::nested::function` path to `other_function`.
use deeply::nested::function as other_function;

fn function() {
    println!(&quot;called `function()`&quot;);
}

mod deeply {
    pub mod nested {
        pub fn function() {
            println!(&quot;called `deeply::nested::function()`&quot;);
        }
    }
}

fn main() {
    // Easier access to `deeply::nested::function`
    other_function();

    println!(&quot;Entering block&quot;);
    {
        // This is equivalent to `use deeply::nested::function as function`.
        // This `function()` will shadow the outer one.
        use crate::deeply::nested::function;

        // `use` bindings have a local scope. In this case, the
        // shadowing of `function()` is only in this block.
        function();

        println!(&quot;Leaving block&quot;);
    }

    function();
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="super-and-self"><a class="header" href="#super-and-self"><code>super</code> and <code>self</code></a></h1>
<p>The <code>super</code> and <code>self</code> keywords can be used in the path to remove ambiguity
when accessing items and to prevent unnecessary hardcoding of paths.</p>
<pre><pre class="playground"><code class="language-rust editable">fn function() {
    println!(&quot;called `function()`&quot;);
}

mod cool {
    pub fn function() {
        println!(&quot;called `cool::function()`&quot;);
    }
}

mod my {
    fn function() {
        println!(&quot;called `my::function()`&quot;);
    }
    
    mod cool {
        pub fn function() {
            println!(&quot;called `my::cool::function()`&quot;);
        }
    }
    
    pub fn indirect_call() {
        // Let's access all the functions named `function` from this scope!
        print!(&quot;called `my::indirect_call()`, that\n&gt; &quot;);
        
        // The `self` keyword refers to the current module scope - in this case `my`.
        // Calling `self::function()` and calling `function()` directly both give
        // the same result, because they refer to the same function.
        self::function();
        function();
        
        // We can also use `self` to access another module inside `my`:
        self::cool::function();
        
        // The `super` keyword refers to the parent scope (outside the `my` module).
        super::function();
        
        // This will bind to the `cool::function` in the *crate* scope.
        // In this case the crate scope is the outermost scope.
        {
            use crate::cool::function as root_function;
            root_function();
        }
    }
}

fn main() {
    my::indirect_call();
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="file-hierarchy"><a class="header" href="#file-hierarchy">File hierarchy</a></h1>
<p>Modules can be mapped to a file/directory hierarchy. Let's break down the
<a href="mod/visibility.html">visibility example</a> in files:</p>
<pre><code class="language-shell">$ tree .
.
|-- my
|   |-- inaccessible.rs
|   |-- mod.rs
|   `-- nested.rs
`-- split.rs
</code></pre>
<p>In <code>split.rs</code>:</p>
<pre><code class="language-rust ignore">// This declaration will look for a file named `my.rs` or `my/mod.rs` and will
// insert its contents inside a module named `my` under this scope
mod my;

fn function() {
    println!(&quot;called `function()`&quot;);
}

fn main() {
    my::function();

    function();

    my::indirect_access();

    my::nested::function();
}

</code></pre>
<p>In <code>my/mod.rs</code>:</p>
<pre><code class="language-rust ignore">// Similarly `mod inaccessible` and `mod nested` will locate the `nested.rs`
// and `inaccessible.rs` files and insert them here under their respective
// modules
mod inaccessible;
pub mod nested;

pub fn function() {
    println!(&quot;called `my::function()`&quot;);
}

fn private_function() {
    println!(&quot;called `my::private_function()`&quot;);
}

pub fn indirect_access() {
    print!(&quot;called `my::indirect_access()`, that\n&gt; &quot;);

    private_function();
}
</code></pre>
<p>In <code>my/nested.rs</code>:</p>
<pre><code class="language-rust ignore">pub fn function() {
    println!(&quot;called `my::nested::function()`&quot;);
}

#[allow(dead_code)]
fn private_function() {
    println!(&quot;called `my::nested::private_function()`&quot;);
}
</code></pre>
<p>In <code>my/inaccessible.rs</code>:</p>
<pre><code class="language-rust ignore">#[allow(dead_code)]
pub fn public_function() {
    println!(&quot;called `my::inaccessible::public_function()`&quot;);
}
</code></pre>
<p>Let's check that things still work as before:</p>
<pre><code class="language-shell">$ rustc split.rs &amp;&amp; ./split
called `my::function()`
called `function()`
called `my::indirect_access()`, that
&gt; called `my::private_function()`
called `my::nested::function()`
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="crates"><a class="header" href="#crates">Crates</a></h1>
<p>A crate is a compilation unit in Rust. Whenever <code>rustc some_file.rs</code> is called,
<code>some_file.rs</code> is treated as the <em>crate file</em>. If <code>some_file.rs</code> has <code>mod</code>
declarations in it, then the contents of the module files would be inserted in
places where <code>mod</code> declarations in the crate file are found, <em>before</em> running
the compiler over it. In other words, modules do <em>not</em> get compiled
individually, only crates get compiled.</p>
<p>A crate can be compiled into a binary or into a library. By default, <code>rustc</code>
will produce a binary from a crate. This behavior can be overridden by passing
the <code>--crate-type</code> flag to <code>lib</code>.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-library"><a class="header" href="#creating-a-library">Creating a Library</a></h1>
<p>Let's create a library, and then see how to link it to another crate.</p>
<pre><code class="language-rust ignore">pub fn public_function() {
    println!(&quot;called rary's `public_function()`&quot;);
}

fn private_function() {
    println!(&quot;called rary's `private_function()`&quot;);
}

pub fn indirect_access() {
    print!(&quot;called rary's `indirect_access()`, that\n&gt; &quot;);

    private_function();
}
</code></pre>
<pre><code class="language-shell">$ rustc --crate-type=lib rary.rs
$ ls lib*
library.rlib
</code></pre>
<p>Libraries get prefixed with &quot;lib&quot;, and by default they get named after their
crate file, but this default name can be overridden by passing
the <code>--crate-name</code> option to <code>rustc</code> or by using the <a href="crates/../attribute/crate.html"><code>crate_name</code>
attribute</a>.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="using-a-library"><a class="header" href="#using-a-library">Using a Library</a></h1>
<p>To link a crate to this new library you may use <code>rustc</code>'s <code>--extern</code> flag. All 
of its items will then be imported under a module named the same as the library.
This module generally behaves the same way as any other module.</p>
<pre><code class="language-rust ignore">// extern crate rary; // May be required for Rust 2015 edition or earlier

fn main() {
    rary::public_function();

    // Error! `private_function` is private
    //rary::private_function();

    rary::indirect_access();
}
</code></pre>
<pre><code class="language-txt"># Where library.rlib is the path to the compiled library, assumed that it's
# in the same directory here:
$ rustc executable.rs --extern rary=library.rlib --edition=2018 &amp;&amp; ./executable 
called rary's `public_function()`
called rary's `indirect_access()`, that
&gt; called rary's `private_function()`
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="cargo"><a class="header" href="#cargo">Cargo</a></h1>
<p><code>cargo</code> is the official Rust package management tool. It has lots of really
useful features to improve code quality and developer velocity! These include</p>
<ul>
<li>Dependency management and integration with <a href="https://crates.io">crates.io</a> (the
official Rust package registry)</li>
<li>Awareness of unit tests</li>
<li>Awareness of benchmarks</li>
</ul>
<p>This chapter will go through some quick basics, but you can find the
comprehensive docs in <a href="https://doc.rust-lang.org/cargo/">The Cargo Book</a>.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h1>
<p>Most programs have dependencies on some libraries. If you have ever managed
dependencies by hand, you know how much of a pain this can be. Luckily, the Rust
ecosystem comes standard with <code>cargo</code>! <code>cargo</code> can manage dependencies for a
project.</p>
<p>To create a new Rust project,</p>
<pre><code class="language-sh"># A binary
cargo new foo

# OR A library
cargo new --lib foo
</code></pre>
<p>For the rest of this chapter, let's assume we are making a binary, rather than
a library, but all of the concepts are the same.</p>
<p>After the above commands, you should see a file hierarchy like this:</p>
<pre><code class="language-txt">foo
├── Cargo.toml
└── src
    └── main.rs
</code></pre>
<p>The <code>main.rs</code> is the root source file for your new project -- nothing new there.
The <code>Cargo.toml</code> is the config file for <code>cargo</code> for this project (<code>foo</code>). If you
look inside it, you should see something like this:</p>
<pre><code class="language-toml">[package]
name = &quot;foo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;mark&quot;]

[dependencies]
</code></pre>
<p>The <code>name</code> field under <code>[package]</code> determines the name of the project. This is
used by <code>crates.io</code> if you publish the crate (more later). It is also the name
of the output binary when you compile.</p>
<p>The <code>version</code> field is a crate version number using <a href="http://semver.org/">Semantic
Versioning</a>.</p>
<p>The <code>authors</code> field is a list of authors used when publishing the crate.</p>
<p>The <code>[dependencies]</code> section lets you add dependencies for your project.</p>
<p>For example, suppose that we want our program to have a great CLI. You can find
lots of great packages on <a href="https://crates.io">crates.io</a> (the official Rust
package registry). One popular choice is <a href="https://crates.io/crates/clap">clap</a>.
As of this writing, the most recent published version of <code>clap</code> is <code>2.27.1</code>. To
add a dependency to our program, we can simply add the following to our
<code>Cargo.toml</code> under <code>[dependencies]</code>: <code>clap = &quot;2.27.1&quot;</code>. And that's it! You can start using
<code>clap</code> in your program.</p>
<p><code>cargo</code> also supports <a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html">other types of dependencies</a>. Here is just
a small sampling:</p>
<pre><code class="language-toml">[package]
name = &quot;foo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;mark&quot;]

[dependencies]
clap = &quot;2.27.1&quot; # from crates.io
rand = { git = &quot;https://github.com/rust-lang-nursery/rand&quot; } # from online repo
bar = { path = &quot;../bar&quot; } # from a path in the local filesystem
</code></pre>
<p><code>cargo</code> is more than a dependency manager. All of the available
configuration options are listed in the <a href="https://doc.rust-lang.org/cargo/reference/manifest.html">format specification</a> of
<code>Cargo.toml</code>.</p>
<p>To build our project we can execute <code>cargo build</code> anywhere in the project
directory (including subdirectories!). We can also do <code>cargo run</code> to build and
run. Notice that these commands will resolve all dependencies, download crates
if needed, and build everything, including your crate. (Note that it only
rebuilds what it has not already built, similar to <code>make</code>).</p>
<p>Voila! That's all there is to it!</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="conventions"><a class="header" href="#conventions">Conventions</a></h1>
<p>In the previous chapter, we saw the following directory hierarchy:</p>
<pre><code class="language-txt">foo
├── Cargo.toml
└── src
    └── main.rs
</code></pre>
<p>Suppose that we wanted to have two binaries in the same project, though. What
then?</p>
<p>It turns out that <code>cargo</code> supports this. The default binary name is <code>main</code>, as
we saw before, but you can add additional binaries by placing them in a <code>bin/</code>
directory:</p>
<pre><code class="language-txt">foo
├── Cargo.toml
└── src
    ├── main.rs
    └── bin
        └── my_other_bin.rs
</code></pre>
<p>To tell <code>cargo</code> to compile or run this binary as opposed to the default or other
binaries, we just pass <code>cargo</code> the <code>--bin my_other_bin</code> flag, where <code>my_other_bin</code>
is the name of the binary we want to work with.</p>
<p>In addition to extra binaries, <code>cargo</code> supports <a href="https://doc.rust-lang.org/cargo/guide/project-layout.html">more features</a> such as
benchmarks, tests, and examples.</p>
<p>In the next chapter, we will look more closely at tests.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<p>As we know testing is integral to any piece of software! Rust has first-class
support for unit and integration testing (<a href="https://doc.rust-lang.org/book/ch11-00-testing.html">see this
chapter</a> in
TRPL).</p>
<p>From the testing chapters linked above, we see how to write unit tests and
integration tests. Organizationally, we can place unit tests in the modules they
test and integration tests in their own <code>tests/</code> directory:</p>
<pre><code class="language-txt">foo
├── Cargo.toml
├── src
│   └── main.rs
│   └── lib.rs
└── tests
    ├── my_test.rs
    └── my_other_test.rs
</code></pre>
<p>Each file in <code>tests</code> is a separate 
<a href="https://doc.rust-lang.org/book/ch11-03-test-organization.html#integration-tests">integration test</a>,
i.e. a test that is meant to test your library as if it were being called from a dependent
crate.</p>
<p>The <a href="cargo/../testing.html">Testing</a> chapter elaborates on the three different testing styles: 
<a href="cargo/../testing/unit_testing.html">Unit</a>, <a href="cargo/../testing/doc_testing.html">Doc</a>, and <a href="cargo/../testing/unit_testing.html">Integration</a>. </p>
<p><code>cargo</code> naturally provides an easy way to run all of your tests!</p>
<pre><code class="language-shell">$ cargo test
</code></pre>
<p>You should see output like this:</p>
<pre><code class="language-shell">$ cargo test
   Compiling blah v0.1.0 (file:///nobackup/blah)
    Finished dev [unoptimized + debuginfo] target(s) in 0.89 secs
     Running target/debug/deps/blah-d3b32b97275ec472

running 3 tests
test test_bar ... ok
test test_baz ... ok
test test_foo_bar ... ok
test test_foo ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>You can also run tests whose name matches a pattern:</p>
<pre><code class="language-shell">$ cargo test test_foo
</code></pre>
<pre><code class="language-shell">$ cargo test test_foo
   Compiling blah v0.1.0 (file:///nobackup/blah)
    Finished dev [unoptimized + debuginfo] target(s) in 0.35 secs
     Running target/debug/deps/blah-d3b32b97275ec472

running 2 tests
test test_foo ... ok
test test_foo_bar ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out
</code></pre>
<p>One word of caution: Cargo may run multiple tests concurrently, so make sure
that they don't race with each other. </p>
<p>One example of this concurrency causing issues is if two tests output to a
file, such as below:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    // Import the necessary modules
    use std::fs::OpenOptions;
    use std::io::Write;

    // This test writes to a file
    #[test]
    fn test_file() {
        // Opens the file ferris.txt or creates one if it doesn't exist.
        let mut file = OpenOptions::new()
            .append(true)
            .create(true)
            .open(&quot;ferris.txt&quot;)
            .expect(&quot;Failed to open ferris.txt&quot;);

        // Print &quot;Ferris&quot; 5 times.
        for _ in 0..5 {
            file.write_all(&quot;Ferris\n&quot;.as_bytes())
                .expect(&quot;Could not write to ferris.txt&quot;);
        }
    }

    // This test tries to write to the same file
    #[test]
    fn test_file_also() {
        // Opens the file ferris.txt or creates one if it doesn't exist.
        let mut file = OpenOptions::new()
            .append(true)
            .create(true)
            .open(&quot;ferris.txt&quot;)
            .expect(&quot;Failed to open ferris.txt&quot;);

        // Print &quot;Corro&quot; 5 times.
        for _ in 0..5 {
            file.write_all(&quot;Corro\n&quot;.as_bytes())
                .expect(&quot;Could not write to ferris.txt&quot;);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Although the intent is to get the following:</p>
<pre><code class="language-shell">$ cat ferris.txt
Ferris
Ferris
Ferris
Ferris
Ferris
Corro
Corro
Corro
Corro
Corro
</code></pre>
<p>What actually gets put into <code>ferris.txt</code> is this:</p>
<pre><code class="language-shell">$ cargo test test_foo
Corro
Ferris
Corro
Ferris
Corro
Ferris
Corro
Ferris
Corro
Ferris
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="build-scripts"><a class="header" href="#build-scripts">Build Scripts</a></h1>
<p>Sometimes a normal build from <code>cargo</code> is not enough. Perhaps your crate needs
some pre-requisites before <code>cargo</code> will successfully compile, things like code
generation, or some native code that needs to be compiled. To solve this problem
we have build scripts that Cargo can run.</p>
<p>To add a build script to your package it can either be specified in the
<code>Cargo.toml</code> as follows:</p>
<pre><code class="language-toml">[package]
...
build = &quot;build.rs&quot;
</code></pre>
<p>Otherwise Cargo will look for a <code>build.rs</code> file in the project directory by
default.</p>
<h2 id="how-to-use-a-build-script"><a class="header" href="#how-to-use-a-build-script">How to use a build script</a></h2>
<p>The build script is simply another Rust file that will be compiled and invoked
prior to compiling anything else in the package. Hence it can be used to fulfill
pre-requisites of your crate.</p>
<p>Cargo provides the script with inputs via environment variables <a href="https://doc.rust-lang.org/cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-build-scripts">specified
here</a> that can be used.</p>
<p>The script provides output via stdout. All lines printed are written to
<code>target/debug/build/&lt;pkg&gt;/output</code>. Further, lines prefixed with <code>cargo:</code> will be
interpreted by Cargo directly and hence can be used to define parameters for the
package's compilation.</p>
<p>For further specification and examples have a read of the
<a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">Cargo specification</a>.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="attributes"><a class="header" href="#attributes">Attributes</a></h1>
<p>An attribute is metadata applied to some module, crate or item. This metadata
can be used to/for:</p>
<!-- TODO: Link these to their respective examples -->
<ul>
<li><a href="attribute/cfg.html">conditional compilation of code</a></li>
<li><a href="attribute/crate.html">set crate name, version and type (binary or library)</a></li>
<li>disable <a href="https://en.wikipedia.org/wiki/Lint_%28software%29">lints</a> (warnings)</li>
<li>enable compiler features (macros, glob imports, etc.)</li>
<li>link to a foreign library</li>
<li>mark functions as unit tests</li>
<li>mark functions that will be part of a benchmark</li>
</ul>
<p>When attributes apply to a whole crate, their syntax is <code>#![crate_attribute]</code>,
and when they apply to a module or item, the syntax is <code>#[item_attribute]</code>
(notice the missing bang <code>!</code>).</p>
<p>Attributes can take arguments with different syntaxes:</p>
<ul>
<li><code>#[attribute = &quot;value&quot;]</code></li>
<li><code>#[attribute(key = &quot;value&quot;)]</code></li>
<li><code>#[attribute(value)]</code></li>
</ul>
<p>Attributes can have multiple values and can be separated over multiple lines, too:</p>
<pre><code class="language-rust ignore">#[attribute(value, value2)]


#[attribute(value, value2, value3,
            value4, value5)]
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="dead_code"><a class="header" href="#dead_code"><code>dead_code</code></a></h1>
<p>The compiler provides a <code>dead_code</code>
<a href="https://en.wikipedia.org/wiki/Lint_%28software%29"><em>lint</em></a> that will warn
about unused functions. An <em>attribute</em> can be used to disable the lint.</p>
<pre><pre class="playground"><code class="language-rust editable">fn used_function() {}

// `#[allow(dead_code)]` is an attribute that disables the `dead_code` lint
#[allow(dead_code)]
fn unused_function() {}

fn noisy_unused_function() {}
// FIXME ^ Add an attribute to suppress the warning

fn main() {
    used_function();
}
</code></pre></pre>
<p>Note that in real programs, you should eliminate dead code. In these examples
we'll allow dead code in some places because of the interactive nature of the
examples.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="crates-1"><a class="header" href="#crates-1">Crates</a></h1>
<p>The <code>crate_type</code> attribute can be used to tell the compiler whether a crate is
a binary or a library (and even which type of library), and the <code>crate_name</code>
attribute can be used to set the name of the crate.</p>
<p>However, it is important to note that both the <code>crate_type</code> and <code>crate_name</code>
attributes have <strong>no</strong> effect whatsoever when using Cargo, the Rust package
manager. Since Cargo is used for the majority of Rust projects, this means
real-world uses of <code>crate_type</code> and <code>crate_name</code> are relatively limited.</p>
<pre><pre class="playground"><code class="language-rust editable">// This crate is a library
#![crate_type = &quot;lib&quot;]
// The library is named &quot;rary&quot;
#![crate_name = &quot;rary&quot;]

pub fn public_function() {
    println!(&quot;called rary's `public_function()`&quot;);
}

fn private_function() {
    println!(&quot;called rary's `private_function()`&quot;);
}

pub fn indirect_access() {
    print!(&quot;called rary's `indirect_access()`, that\n&gt; &quot;);

    private_function();
}
</code></pre></pre>
<p>When the <code>crate_type</code> attribute is used, we no longer need to pass the
<code>--crate-type</code> flag to <code>rustc</code>.</p>
<pre><code class="language-shell">$ rustc lib.rs
$ ls lib*
library.rlib
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="cfg"><a class="header" href="#cfg"><code>cfg</code></a></h1>
<p>Configuration conditional checks are possible through two different operators:</p>
<ul>
<li>the <code>cfg</code> attribute: <code>#[cfg(...)]</code> in attribute position</li>
<li>the <code>cfg!</code> macro: <code>cfg!(...)</code> in boolean expressions</li>
</ul>
<p>While the former enables conditional compilation, the latter conditionally
evaluates to <code>true</code> or <code>false</code> literals allowing for checks at run-time. Both
utilize identical argument syntax.</p>
<pre><pre class="playground"><code class="language-rust editable">// This function only gets compiled if the target OS is linux
#[cfg(target_os = &quot;linux&quot;)]
fn are_you_on_linux() {
    println!(&quot;You are running linux!&quot;);
}

// And this function only gets compiled if the target OS is *not* linux
#[cfg(not(target_os = &quot;linux&quot;))]
fn are_you_on_linux() {
    println!(&quot;You are *not* running linux!&quot;);
}

fn main() {
    are_you_on_linux();

    println!(&quot;Are you sure?&quot;);
    if cfg!(target_os = &quot;linux&quot;) {
        println!(&quot;Yes. It's definitely linux!&quot;);
    } else {
        println!(&quot;Yes. It's definitely *not* linux!&quot;);
    }
}
</code></pre></pre>
<h3 id="see-also-31"><a class="header" href="#see-also-31">See also:</a></h3>
<p><a href="https://doc.rust-lang.org/reference/attributes.html#conditional-compilation">the reference</a>, <a href="https://doc.rust-lang.org/std/macro.cfg!.html"><code>cfg!</code></a>, and <a href="attribute/../macros.html">macros</a>.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="custom"><a class="header" href="#custom">Custom</a></h1>
<p>Some conditionals like <code>target_os</code> are implicitly provided by <code>rustc</code>, but
custom conditionals must be passed to <code>rustc</code> using the <code>--cfg</code> flag.</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">#[cfg(some_condition)]
fn conditional_function() {
    println!(&quot;condition met!&quot;);
}

fn main() {
    conditional_function();
}
</code></pre></pre>
<p>Try to run this to see what happens without the custom <code>cfg</code> flag.</p>
<p>With the custom <code>cfg</code> flag:</p>
<pre><code class="language-shell">$ rustc --cfg some_condition custom.rs &amp;&amp; ./custom
condition met!
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="generics"><a class="header" href="#generics">Generics</a></h1>
<p><em>Generics</em> is the topic of generalizing types and functionalities to broader
cases. This is extremely useful for reducing code duplication in many ways,
but can call for rather involving syntax. Namely, being generic requires 
taking great care to specify over which types a generic type 
is actually considered valid. The simplest and most common use of generics 
is for type parameters.</p>
<p>A type parameter is specified as generic by the use of angle brackets and upper
<a href="https://en.wikipedia.org/wiki/CamelCase">camel case</a>: <code>&lt;Aaa, Bbb, ...&gt;</code>. &quot;Generic type parameters&quot; are
typically represented as <code>&lt;T&gt;</code>. In Rust, &quot;generic&quot; also describes anything that
accepts one or more generic type parameters <code>&lt;T&gt;</code>. Any type specified as a 
generic type parameter is generic, and everything else is concrete (non-generic).</p>
<p>For example, defining a <em>generic function</em> named <code>foo</code> that takes an argument
<code>T</code> of any type:</p>
<pre><code class="language-rust ignore">fn foo&lt;T&gt;(arg: T) { ... }
</code></pre>
<p>Because <code>T</code> has been specified as a generic type parameter using <code>&lt;T&gt;</code>, it 
is considered generic when used here as <code>(arg: T)</code>. This is the case even if <code>T</code> 
has previously been defined as a <code>struct</code>.</p>
<p>This example shows some of the syntax in action:</p>
<pre><pre class="playground"><code class="language-rust editable">// A concrete type `A`.
struct A;

// In defining the type `Single`, the first use of `A` is not preceded by `&lt;A&gt;`.
// Therefore, `Single` is a concrete type, and `A` is defined as above.
struct Single(A);
//            ^ Here is `Single`s first use of the type `A`.

// Here, `&lt;T&gt;` precedes the first use of `T`, so `SingleGen` is a generic type.
// Because the type parameter `T` is generic, it could be anything, including
// the concrete type `A` defined at the top.
struct SingleGen&lt;T&gt;(T);

fn main() {
    // `Single` is concrete and explicitly takes `A`.
    let _s = Single(A);
    
    // Create a variable `_char` of type `SingleGen&lt;char&gt;`
    // and give it the value `SingleGen('a')`.
    // Here, `SingleGen` has a type parameter explicitly specified.
    let _char: SingleGen&lt;char&gt; = SingleGen('a');

    // `SingleGen` can also have a type parameter implicitly specified:
    let _t    = SingleGen(A); // Uses `A` defined at the top.
    let _i32  = SingleGen(6); // Uses `i32`.
    let _char = SingleGen('a'); // Uses `char`.
}
</code></pre></pre>
<h3 id="see-also-32"><a class="header" href="#see-also-32">See also:</a></h3>
<p><a href="custom_types/structs.html"><code>structs</code></a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="functions-1"><a class="header" href="#functions-1">Functions</a></h1>
<p>The same set of rules can be applied to functions: a type <code>T</code> becomes
generic when preceded by <code>&lt;T&gt;</code>.</p>
<p>Using generic functions sometimes requires explicitly specifying type 
parameters. This may be the case if the function is called where the return type 
is generic, or if the compiler doesn't have enough information to infer 
the necessary type parameters.</p>
<p>A function call with explicitly specified type parameters looks like:
<code>fun::&lt;A, B, ...&gt;()</code>.</p>
<pre><pre class="playground"><code class="language-rust editable">struct A;          // Concrete type `A`.
struct S(A);       // Concrete type `S`.
struct SGen&lt;T&gt;(T); // Generic type `SGen`.

// The following functions all take ownership of the variable passed into
// them and immediately go out of scope, freeing the variable.

// Define a function `reg_fn` that takes an argument `_s` of type `S`.
// This has no `&lt;T&gt;` so this is not a generic function.
fn reg_fn(_s: S) {}

// Define a function `gen_spec_t` that takes an argument `_s` of type `SGen&lt;T&gt;`.
// It has been explicitly given the type parameter `A`, but because `A` has not 
// been specified as a generic type parameter for `gen_spec_t`, it is not generic.
fn gen_spec_t(_s: SGen&lt;A&gt;) {}

// Define a function `gen_spec_i32` that takes an argument `_s` of type `SGen&lt;i32&gt;`.
// It has been explicitly given the type parameter `i32`, which is a specific type.
// Because `i32` is not a generic type, this function is also not generic.
fn gen_spec_i32(_s: SGen&lt;i32&gt;) {}

// Define a function `generic` that takes an argument `_s` of type `SGen&lt;T&gt;`.
// Because `SGen&lt;T&gt;` is preceded by `&lt;T&gt;`, this function is generic over `T`.
fn generic&lt;T&gt;(_s: SGen&lt;T&gt;) {}

fn main() {
    // Using the non-generic functions
    reg_fn(S(A));          // Concrete type.
    gen_spec_t(SGen(A));   // Implicitly specified type parameter `A`.
    gen_spec_i32(SGen(6)); // Implicitly specified type parameter `i32`.

    // Explicitly specified type parameter `char` to `generic()`.
    generic::&lt;char&gt;(SGen('a'));

    // Implicitly specified type parameter `char` to `generic()`.
    generic(SGen('c'));
}
</code></pre></pre>
<h3 id="see-also-33"><a class="header" href="#see-also-33">See also:</a></h3>
<p><a href="generics/../fn.html">functions</a> and <a href="generics/../custom_types/structs.html"><code>struct</code>s</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="implementation"><a class="header" href="#implementation">Implementation</a></h1>
<p>Similar to functions, implementations require care to remain generic.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S; // Concrete type `S`
struct GenericVal&lt;T&gt;(T); // Generic type `GenericVal`

// impl of GenericVal where we explicitly specify type parameters:
impl GenericVal&lt;f32&gt; {} // Specify `f32`
impl GenericVal&lt;S&gt; {} // Specify `S` as defined above

// `&lt;T&gt;` Must precede the type to remain generic
impl&lt;T&gt; GenericVal&lt;T&gt; {}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust editable">struct Val {
    val: f64,
}

struct GenVal&lt;T&gt; {
    gen_val: T,
}

// impl of Val
impl Val {
    fn value(&amp;self) -&gt; &amp;f64 {
        &amp;self.val
    }
}

// impl of GenVal for a generic type `T`
impl&lt;T&gt; GenVal&lt;T&gt; {
    fn value(&amp;self) -&gt; &amp;T {
        &amp;self.gen_val
    }
}

fn main() {
    let x = Val { val: 3.0 };
    let y = GenVal { gen_val: 3i32 };

    println!(&quot;{}, {}&quot;, x.value(), y.value());
}
</code></pre></pre>
<h3 id="see-also-34"><a class="header" href="#see-also-34">See also:</a></h3>
<p><a href="generics/../scope/lifetime/fn.html">functions returning references</a>, <a href="generics/../fn/methods.html"><code>impl</code></a>, and <a href="generics/../custom_types/structs.html"><code>struct</code></a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="traits"><a class="header" href="#traits">Traits</a></h1>
<p>Of course <code>trait</code>s can also be generic. Here we define one which reimplements
the <code>Drop</code> <code>trait</code> as a generic method to <code>drop</code> itself and an input.</p>
<pre><pre class="playground"><code class="language-rust editable">// Non-copyable types.
struct Empty;
struct Null;

// A trait generic over `T`.
trait DoubleDrop&lt;T&gt; {
    // Define a method on the caller type which takes an
    // additional single parameter `T` and does nothing with it.
    fn double_drop(self, _: T);
}

// Implement `DoubleDrop&lt;T&gt;` for any generic parameter `T` and
// caller `U`.
impl&lt;T, U&gt; DoubleDrop&lt;T&gt; for U {
    // This method takes ownership of both passed arguments,
    // deallocating both.
    fn double_drop(self, _: T) {}
}

fn main() {
    let empty = Empty;
    let null  = Null;

    // Deallocate `empty` and `null`.
    empty.double_drop(null);

    //empty;
    //null;
    // ^ TODO: Try uncommenting these lines.
}
</code></pre></pre>
<h3 id="see-also-35"><a class="header" href="#see-also-35">See also:</a></h3>
<p><a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a>, <a href="generics/../custom_types/structs.html"><code>struct</code></a>, and <a href="generics/../trait.html"><code>trait</code></a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="bounds"><a class="header" href="#bounds">Bounds</a></h1>
<p>When working with generics, the type parameters often must use traits as <em>bounds</em> to
stipulate what functionality a type implements. For example, the following
example uses the trait <code>Display</code> to print and so it requires <code>T</code> to be bound
by <code>Display</code>; that is, <code>T</code> <em>must</em> implement <code>Display</code>.</p>
<pre><code class="language-rust ignore">// Define a function `printer` that takes a generic type `T` which
// must implement trait `Display`.
fn printer&lt;T: Display&gt;(t: T) {
    println!(&quot;{}&quot;, t);
}
</code></pre>
<p>Bounding restricts the generic to types that conform to the bounds. That is:</p>
<pre><code class="language-rust ignore">struct S&lt;T: Display&gt;(T);

// Error! `Vec&lt;T&gt;` does not implement `Display`. This
// specialization will fail.
let s = S(vec![1]);
</code></pre>
<p>Another effect of bounding is that generic instances are allowed to access the 
<a href="generics/../fn/methods.html">methods</a> of traits specified in the bounds. For example:</p>
<pre><pre class="playground"><code class="language-rust editable">// A trait which implements the print marker: `{:?}`.
use std::fmt::Debug;

trait HasArea {
    fn area(&amp;self) -&gt; f64;
}

impl HasArea for Rectangle {
    fn area(&amp;self) -&gt; f64 { self.length * self.height }
}

#[derive(Debug)]
struct Rectangle { length: f64, height: f64 }
#[allow(dead_code)]
struct Triangle  { length: f64, height: f64 }

// The generic `T` must implement `Debug`. Regardless
// of the type, this will work properly.
fn print_debug&lt;T: Debug&gt;(t: &amp;T) {
    println!(&quot;{:?}&quot;, t);
}

// `T` must implement `HasArea`. Any type which meets
// the bound can access `HasArea`'s function `area`.
fn area&lt;T: HasArea&gt;(t: &amp;T) -&gt; f64 { t.area() }

fn main() {
    let rectangle = Rectangle { length: 3.0, height: 4.0 };
    let _triangle = Triangle  { length: 3.0, height: 4.0 };

    print_debug(&amp;rectangle);
    println!(&quot;Area: {}&quot;, area(&amp;rectangle));

    //print_debug(&amp;_triangle);
    //println!(&quot;Area: {}&quot;, area(&amp;_triangle));
    // ^ TODO: Try uncommenting these.
    // | Error: Does not implement either `Debug` or `HasArea`. 
}
</code></pre></pre>
<p>As an additional note, <a href="generics/../generics/where.html"><code>where</code></a> clauses can also be used to apply bounds in
some cases to be more expressive.</p>
<h3 id="see-also-36"><a class="header" href="#see-also-36">See also:</a></h3>
<p><a href="generics/../hello/print.html"><code>std::fmt</code></a>, <a href="generics/../custom_types/structs.html"><code>struct</code>s</a>, and <a href="generics/../trait.html"><code>trait</code>s</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="testcase-empty-bounds"><a class="header" href="#testcase-empty-bounds">Testcase: empty bounds</a></h1>
<p>A consequence of how bounds work is that even if a <code>trait</code> doesn't
include any functionality, you can still use it as a bound. <code>Eq</code> and
<code>Copy</code> are examples of such <code>trait</code>s from the <code>std</code> library.</p>
<pre><pre class="playground"><code class="language-rust editable">struct Cardinal;
struct BlueJay;
struct Turkey;

trait Red {}
trait Blue {}

impl Red for Cardinal {}
impl Blue for BlueJay {}

// These functions are only valid for types which implement these
// traits. The fact that the traits are empty is irrelevant.
fn red&lt;T: Red&gt;(_: &amp;T)   -&gt; &amp;'static str { &quot;red&quot; }
fn blue&lt;T: Blue&gt;(_: &amp;T) -&gt; &amp;'static str { &quot;blue&quot; }

fn main() {
    let cardinal = Cardinal;
    let blue_jay = BlueJay;
    let _turkey   = Turkey;

    // `red()` won't work on a blue jay nor vice versa
    // because of the bounds.
    println!(&quot;A cardinal is {}&quot;, red(&amp;cardinal));
    println!(&quot;A blue jay is {}&quot;, blue(&amp;blue_jay));
    //println!(&quot;A turkey is {}&quot;, red(&amp;_turkey));
    // ^ TODO: Try uncommenting this line.
}
</code></pre></pre>
<h3 id="see-also-37"><a class="header" href="#see-also-37">See also:</a></h3>
<p><a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html"><code>std::cmp::Eq</code></a>, <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>std::marker::Copy</code></a>, and <a href="generics/bounds/../../trait.html"><code>trait</code>s</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="multiple-bounds"><a class="header" href="#multiple-bounds">Multiple bounds</a></h1>
<p>Multiple bounds for a single type can be applied with a <code>+</code>. Like normal, different types are
separated with <code>,</code>.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::fmt::{Debug, Display};

fn compare_prints&lt;T: Debug + Display&gt;(t: &amp;T) {
    println!(&quot;Debug: `{:?}`&quot;, t);
    println!(&quot;Display: `{}`&quot;, t);
}

fn compare_types&lt;T: Debug, U: Debug&gt;(t: &amp;T, u: &amp;U) {
    println!(&quot;t: `{:?}`&quot;, t);
    println!(&quot;u: `{:?}`&quot;, u);
}

fn main() {
    let string = &quot;words&quot;;
    let array = [1, 2, 3];
    let vec = vec![1, 2, 3];

    compare_prints(&amp;string);
    //compare_prints(&amp;array);
    // TODO ^ Try uncommenting this.

    compare_types(&amp;array, &amp;vec);
}
</code></pre></pre>
<h3 id="see-also-38"><a class="header" href="#see-also-38">See also:</a></h3>
<p><a href="generics/../hello/print.html"><code>std::fmt</code></a> and <a href="generics/../trait.html"><code>trait</code>s</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="where-clauses"><a class="header" href="#where-clauses">Where clauses</a></h1>
<p>A bound can also be expressed using a <code>where</code> clause immediately
before the opening <code>{</code>, rather than at the type's first mention. 
Additionally, <code>where</code> clauses can apply bounds to arbitrary types, 
rather than just to type parameters.</p>
<p>Some cases that a <code>where</code> clause is useful:</p>
<ul>
<li>When specifying generic types and bounds separately is clearer:</li>
</ul>
<pre><code class="language-rust ignore">impl &lt;A: TraitB + TraitC, D: TraitE + TraitF&gt; MyTrait&lt;A, D&gt; for YourType {}

// Expressing bounds with a `where` clause
impl &lt;A, D&gt; MyTrait&lt;A, D&gt; for YourType where
    A: TraitB + TraitC,
    D: TraitE + TraitF {}
</code></pre>
<ul>
<li>When using a <code>where</code> clause is more expressive than using normal syntax. 
The <code>impl</code> in this example cannot be directly expressed without a <code>where</code> clause:</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">use std::fmt::Debug;

trait PrintInOption {
    fn print_in_option(self);
}

// Because we would otherwise have to express this as `T: Debug` or 
// use another method of indirect approach, this requires a `where` clause:
impl&lt;T&gt; PrintInOption for T where
    Option&lt;T&gt;: Debug {
    // We want `Option&lt;T&gt;: Debug` as our bound because that is what's
    // being printed. Doing otherwise would be using the wrong bound.
    fn print_in_option(self) {
        println!(&quot;{:?}&quot;, Some(self));
    }
}

fn main() {
    let vec = vec![1, 2, 3];

    vec.print_in_option();
}
</code></pre></pre>
<h3 id="see-also-39"><a class="header" href="#see-also-39">See also:</a></h3>
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/0135-where.md">RFC</a>, <a href="generics/../custom_types/structs.html"><code>struct</code></a>, and <a href="generics/../trait.html"><code>trait</code></a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="new-type-idiom"><a class="header" href="#new-type-idiom">New Type Idiom</a></h1>
<p>The <code>newtype</code> idiom gives compile time guarantees that the right type of value is supplied
to a program.</p>
<p>For example, an age verification function that checks age in years, <em>must</em> be given
a value of type <code>Years</code>.</p>
<pre><pre class="playground"><code class="language-rust editable">struct Years(i64);

struct Days(i64);

impl Years {
    pub fn to_days(&amp;self) -&gt; Days {
        Days(self.0 * 365)
    }
}


impl Days {
    /// truncates partial years
    pub fn to_years(&amp;self) -&gt; Years {
        Years(self.0 / 365)
    }
}

fn old_enough(age: &amp;Years) -&gt; bool {
    age.0 &gt;= 18
}

fn main() {
    let age = Years(5);
    let age_days = age.to_days();
    println!(&quot;Old enough {}&quot;, old_enough(&amp;age));
    println!(&quot;Old enough {}&quot;, old_enough(&amp;age_days.to_years()));
    // println!(&quot;Old enough {}&quot;, old_enough(&amp;age_days));
}
</code></pre></pre>
<p>Uncomment the last print statement to observe that the type supplied must be <code>Years</code>.</p>
<p>To obtain the <code>newtype</code>'s value as the base type, you may use the tuple or destructuring syntax like so:</p>
<pre><pre class="playground"><code class="language-rust editable">struct Years(i64);

fn main() {
    let years = Years(42);
    let years_as_primitive_1: i64 = years.0; // Tuple
    let Years(years_as_primitive_2) = years; // Destructuring
}
</code></pre></pre>
<h3 id="see-also-40"><a class="header" href="#see-also-40">See also:</a></h3>
<p><a href="generics/../custom_types/structs.html"><code>structs</code></a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="associated-items"><a class="header" href="#associated-items">Associated items</a></h1>
<p>&quot;Associated Items&quot; refers to a set of rules pertaining to <a href="https://doc.rust-lang.org/reference/items.html"><code>item</code></a>s
of various types. It is an extension to <code>trait</code> generics, and allows 
<code>trait</code>s to internally define new items.</p>
<p>One such item is called an <em>associated type</em>, providing simpler usage 
patterns when the <code>trait</code> is generic over its container type.</p>
<h3 id="see-also-41"><a class="header" href="#see-also-41">See also:</a></h3>
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/0195-associated-items.md">RFC</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="the-problem"><a class="header" href="#the-problem">The Problem</a></h1>
<p>A <code>trait</code> that is generic over its container type has type specification
requirements - users of the <code>trait</code> <em>must</em> specify all of its generic types.</p>
<p>In the example below, the <code>Contains</code> <code>trait</code> allows the use of the generic 
types <code>A</code> and <code>B</code>. The trait is then implemented for the <code>Container</code> type, 
specifying <code>i32</code> for <code>A</code> and <code>B</code> so that it can be used with <code>fn difference()</code>.</p>
<p>Because <code>Contains</code> is generic, we are forced to explicitly state <em>all</em> of the 
generic types for <code>fn difference()</code>. In practice, we want a way to express that 
<code>A</code> and <code>B</code> are determined by the <em>input</em> <code>C</code>. As you will see in the next 
section, associated types provide exactly that capability.</p>
<pre><pre class="playground"><code class="language-rust editable">struct Container(i32, i32);

// A trait which checks if 2 items are stored inside of container.
// Also retrieves first or last value.
trait Contains&lt;A, B&gt; {
    fn contains(&amp;self, _: &amp;A, _: &amp;B) -&gt; bool; // Explicitly requires `A` and `B`.
    fn first(&amp;self) -&gt; i32; // Doesn't explicitly require `A` or `B`.
    fn last(&amp;self) -&gt; i32;  // Doesn't explicitly require `A` or `B`.
}

impl Contains&lt;i32, i32&gt; for Container {
    // True if the numbers stored are equal.
    fn contains(&amp;self, number_1: &amp;i32, number_2: &amp;i32) -&gt; bool {
        (&amp;self.0 == number_1) &amp;&amp; (&amp;self.1 == number_2)
    }

    // Grab the first number.
    fn first(&amp;self) -&gt; i32 { self.0 }

    // Grab the last number.
    fn last(&amp;self) -&gt; i32 { self.1 }
}

// `C` contains `A` and `B`. In light of that, having to express `A` and
// `B` again is a nuisance.
fn difference&lt;A, B, C&gt;(container: &amp;C) -&gt; i32 where
    C: Contains&lt;A, B&gt; {
    container.last() - container.first()
}

fn main() {
    let number_1 = 3;
    let number_2 = 10;

    let container = Container(number_1, number_2);

    println!(&quot;Does container contain {} and {}: {}&quot;,
        &amp;number_1, &amp;number_2,
        container.contains(&amp;number_1, &amp;number_2));
    println!(&quot;First number: {}&quot;, container.first());
    println!(&quot;Last number: {}&quot;, container.last());

    println!(&quot;The difference is: {}&quot;, difference(&amp;container));
}
</code></pre></pre>
<h3 id="see-also-42"><a class="header" href="#see-also-42">See also:</a></h3>
<p><a href="generics/assoc_items/../../custom_types/structs.html"><code>struct</code>s</a>, and <a href="generics/assoc_items/../../trait.html"><code>trait</code>s</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="associated-types"><a class="header" href="#associated-types">Associated types</a></h1>
<p>The use of &quot;Associated types&quot; improves the overall readability of code 
by moving inner types locally into a trait as <em>output</em> types. Syntax
for the <code>trait</code> definition is as follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `A` and `B` are defined in the trait via the `type` keyword.
// (Note: `type` in this context is different from `type` when used for
// aliases).
trait Contains {
    type A;
    type B;

    // Updated syntax to refer to these new types generically.
    fn contains(&amp;self, &amp;Self::A, &amp;Self::B) -&gt; bool;
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that functions that use the <code>trait</code> <code>Contains</code> are no longer required
to express <code>A</code> or <code>B</code> at all:</p>
<pre><code class="language-rust ignore">// Without using associated types
fn difference&lt;A, B, C&gt;(container: &amp;C) -&gt; i32 where
    C: Contains&lt;A, B&gt; { ... }

// Using associated types
fn difference&lt;C: Contains&gt;(container: &amp;C) -&gt; i32 { ... }
</code></pre>
<p>Let's rewrite the example from the previous section using associated types:</p>
<pre><pre class="playground"><code class="language-rust editable">struct Container(i32, i32);

// A trait which checks if 2 items are stored inside of container.
// Also retrieves first or last value.
trait Contains {
    // Define generic types here which methods will be able to utilize.
    type A;
    type B;

    fn contains(&amp;self, _: &amp;Self::A, _: &amp;Self::B) -&gt; bool;
    fn first(&amp;self) -&gt; i32;
    fn last(&amp;self) -&gt; i32;
}

impl Contains for Container {
    // Specify what types `A` and `B` are. If the `input` type
    // is `Container(i32, i32)`, the `output` types are determined
    // as `i32` and `i32`.
    type A = i32;
    type B = i32;

    // `&amp;Self::A` and `&amp;Self::B` are also valid here.
    fn contains(&amp;self, number_1: &amp;i32, number_2: &amp;i32) -&gt; bool {
        (&amp;self.0 == number_1) &amp;&amp; (&amp;self.1 == number_2)
    }
    // Grab the first number.
    fn first(&amp;self) -&gt; i32 { self.0 }

    // Grab the last number.
    fn last(&amp;self) -&gt; i32 { self.1 }
}

fn difference&lt;C: Contains&gt;(container: &amp;C) -&gt; i32 {
    container.last() - container.first()
}

fn main() {
    let number_1 = 3;
    let number_2 = 10;

    let container = Container(number_1, number_2);

    println!(&quot;Does container contain {} and {}: {}&quot;,
        &amp;number_1, &amp;number_2,
        container.contains(&amp;number_1, &amp;number_2));
    println!(&quot;First number: {}&quot;, container.first());
    println!(&quot;Last number: {}&quot;, container.last());
    
    println!(&quot;The difference is: {}&quot;, difference(&amp;container));
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="phantom-type-parameters"><a class="header" href="#phantom-type-parameters">Phantom type parameters</a></h1>
<p>A phantom type parameter is one that doesn't show up at runtime,
but is checked statically (and only) at compile time.</p>
<p>Data types can use extra generic type parameters to act as markers
or to perform type checking at compile time. These extra parameters 
hold no storage values, and have no runtime behavior.</p>
<p>In the following example, we combine <a href="https://doc.rust-lang.org/std/marker/struct.PhantomData.html">std::marker::PhantomData</a>
with the phantom type parameter concept to create tuples containing
different data types.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::marker::PhantomData;

// A phantom tuple struct which is generic over `A` with hidden parameter `B`.
#[derive(PartialEq)] // Allow equality test for this type.
struct PhantomTuple&lt;A, B&gt;(A,PhantomData&lt;B&gt;);

// A phantom type struct which is generic over `A` with hidden parameter `B`.
#[derive(PartialEq)] // Allow equality test for this type.
struct PhantomStruct&lt;A, B&gt; { first: A, phantom: PhantomData&lt;B&gt; }

// Note: Storage is allocated for generic type `A`, but not for `B`.
//       Therefore, `B` cannot be used in computations.

fn main() {
    // Here, `f32` and `f64` are the hidden parameters.
    // PhantomTuple type specified as `&lt;char, f32&gt;`.
    let _tuple1: PhantomTuple&lt;char, f32&gt; = PhantomTuple('Q', PhantomData);
    // PhantomTuple type specified as `&lt;char, f64&gt;`.
    let _tuple2: PhantomTuple&lt;char, f64&gt; = PhantomTuple('Q', PhantomData);

    // Type specified as `&lt;char, f32&gt;`.
    let _struct1: PhantomStruct&lt;char, f32&gt; = PhantomStruct {
        first: 'Q',
        phantom: PhantomData,
    };
    // Type specified as `&lt;char, f64&gt;`.
    let _struct2: PhantomStruct&lt;char, f64&gt; = PhantomStruct {
        first: 'Q',
        phantom: PhantomData,
    };
    
    // Compile-time Error! Type mismatch so these cannot be compared:
    //println!(&quot;_tuple1 == _tuple2 yields: {}&quot;,
    //          _tuple1 == _tuple2);
    
    // Compile-time Error! Type mismatch so these cannot be compared:
    //println!(&quot;_struct1 == _struct2 yields: {}&quot;,
    //          _struct1 == _struct2);
}
</code></pre></pre>
<h3 id="see-also-43"><a class="header" href="#see-also-43">See also:</a></h3>
<p><a href="generics/../trait/derive.html">Derive</a>, <a href="generics/../custom_types/structs.html">struct</a>, and <a href="generics/../custom_types/structs.html">TupleStructs</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="testcase-unit-clarification"><a class="header" href="#testcase-unit-clarification">Testcase: unit clarification</a></h1>
<p>A useful method of unit conversions can be examined by implementing <code>Add</code>
with a phantom type parameter. The <code>Add</code> <code>trait</code> is examined below:</p>
<pre><code class="language-rust ignore">// This construction would impose: `Self + RHS = Output`
// where RHS defaults to Self if not specified in the implementation.
pub trait Add&lt;RHS = Self&gt; {
    type Output;

    fn add(self, rhs: RHS) -&gt; Self::Output;
}

// `Output` must be `T&lt;U&gt;` so that `T&lt;U&gt; + T&lt;U&gt; = T&lt;U&gt;`.
impl&lt;U&gt; Add for T&lt;U&gt; {
    type Output = T&lt;U&gt;;
    ...
}
</code></pre>
<p>The whole implementation:</p>
<pre><pre class="playground"><code class="language-rust editable">use std::ops::Add;
use std::marker::PhantomData;

/// Create void enumerations to define unit types.
#[derive(Debug, Clone, Copy)]
enum Inch {}
#[derive(Debug, Clone, Copy)]
enum Mm {}

/// `Length` is a type with phantom type parameter `Unit`,
/// and is not generic over the length type (that is `f64`).
///
/// `f64` already implements the `Clone` and `Copy` traits.
#[derive(Debug, Clone, Copy)]
struct Length&lt;Unit&gt;(f64, PhantomData&lt;Unit&gt;);

/// The `Add` trait defines the behavior of the `+` operator.
impl&lt;Unit&gt; Add for Length&lt;Unit&gt; {
     type Output = Length&lt;Unit&gt;;

    // add() returns a new `Length` struct containing the sum.
    fn add(self, rhs: Length&lt;Unit&gt;) -&gt; Length&lt;Unit&gt; {
        // `+` calls the `Add` implementation for `f64`.
        Length(self.0 + rhs.0, PhantomData)
    }
}

fn main() {
    // Specifies `one_foot` to have phantom type parameter `Inch`.
    let one_foot:  Length&lt;Inch&gt; = Length(12.0, PhantomData);
    // `one_meter` has phantom type parameter `Mm`.
    let one_meter: Length&lt;Mm&gt;   = Length(1000.0, PhantomData);

    // `+` calls the `add()` method we implemented for `Length&lt;Unit&gt;`.
    //
    // Since `Length` implements `Copy`, `add()` does not consume
    // `one_foot` and `one_meter` but copies them into `self` and `rhs`.
    let two_feet = one_foot + one_foot;
    let two_meters = one_meter + one_meter;

    // Addition works.
    println!(&quot;one foot + one_foot = {:?} in&quot;, two_feet.0);
    println!(&quot;one meter + one_meter = {:?} mm&quot;, two_meters.0);

    // Nonsensical operations fail as they should:
    // Compile-time Error: type mismatch.
    //let one_feter = one_foot + one_meter;
}
</code></pre></pre>
<h3 id="see-also-44"><a class="header" href="#see-also-44">See also:</a></h3>
<p><a href="generics/phantom/../../scope/borrow.html">Borrowing (<code>&amp;</code>)</a>, <a href="generics/phantom/../../generics/bounds.html">Bounds (<code>X: Y</code>)</a>, <a href="generics/phantom/../../custom_types/enum.html">enum</a>, <a href="generics/phantom/../../fn/methods.html">impl &amp; self</a>,
<a href="generics/phantom/../../trait/ops.html">Overloading</a>, <a href="generics/phantom/../../scope/borrow/ref.html">ref</a>, <a href="generics/phantom/../../trait.html">Traits (<code>X for Y</code>)</a>, and <a href="generics/phantom/../../custom_types/structs.html">TupleStructs</a>.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="scoping-rules"><a class="header" href="#scoping-rules">Scoping rules</a></h1>
<p>Scopes play an important part in ownership, borrowing, and lifetimes.
That is, they indicate to the compiler when borrows are valid, when 
resources can be freed, and when variables are created or destroyed.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="raii"><a class="header" href="#raii">RAII</a></h1>
<p>Variables in Rust do more than just hold data in the stack: they also <em>own</em>
resources, e.g. <code>Box&lt;T&gt;</code> owns memory in the heap. Rust enforces <a href="https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">RAII</a>
(Resource Acquisition Is Initialization), so whenever an object goes out of
scope, its destructor is called and its owned resources are freed.</p>
<p>This behavior shields against <em>resource leak</em> bugs, so you'll never have to
manually free memory or worry about memory leaks again! Here's a quick showcase:</p>
<pre><pre class="playground"><code class="language-rust editable">// raii.rs
fn create_box() {
    // Allocate an integer on the heap
    let _box1 = Box::new(3i32);

    // `_box1` is destroyed here, and memory gets freed
}

fn main() {
    // Allocate an integer on the heap
    let _box2 = Box::new(5i32);

    // A nested scope:
    {
        // Allocate an integer on the heap
        let _box3 = Box::new(4i32);

        // `_box3` is destroyed here, and memory gets freed
    }

    // Creating lots of boxes just for fun
    // There's no need to manually free memory!
    for _ in 0u32..1_000 {
        create_box();
    }

    // `_box2` is destroyed here, and memory gets freed
}
</code></pre></pre>
<p>Of course, we can double check for memory errors using <a href="http://valgrind.org/info/"><code>valgrind</code></a>:</p>
<pre><code class="language-shell">$ rustc raii.rs &amp;&amp; valgrind ./raii
==26873== Memcheck, a memory error detector
==26873== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al.
==26873== Using Valgrind-3.9.0 and LibVEX; rerun with -h for copyright info
==26873== Command: ./raii
==26873==
==26873==
==26873== HEAP SUMMARY:
==26873==     in use at exit: 0 bytes in 0 blocks
==26873==   total heap usage: 1,013 allocs, 1,013 frees, 8,696 bytes allocated
==26873==
==26873== All heap blocks were freed -- no leaks are possible
==26873==
==26873== For counts of detected and suppressed errors, rerun with: -v
==26873== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 2 from 2)
</code></pre>
<p>No leaks here!</p>
<h2 id="destructor"><a class="header" href="#destructor">Destructor</a></h2>
<p>The notion of a destructor in Rust is provided through the <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a> trait. The
destructor is called when the resource goes out of scope. This trait is not
required to be implemented for every type, only implement it for your type if
you require its own destructor logic.</p>
<p>Run the below example to see how the <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a> trait works. When the variable in
the <code>main</code> function goes out of scope the custom destructor will be invoked.</p>
<pre><pre class="playground"><code class="language-rust editable">struct ToDrop;

impl Drop for ToDrop {
    fn drop(&amp;mut self) {
        println!(&quot;ToDrop is being dropped&quot;);
    }
}

fn main() {
    let x = ToDrop;
    println!(&quot;Made a ToDrop!&quot;);
}
</code></pre></pre>
<h3 id="see-also-45"><a class="header" href="#see-also-45">See also:</a></h3>
<p><a href="scope/../std/box.html">Box</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="ownership-and-moves"><a class="header" href="#ownership-and-moves">Ownership and moves</a></h1>
<p>Because variables are in charge of freeing their own resources, 
<strong>resources can only have one owner</strong>. This also prevents resources 
from being freed more than once. Note that not all variables own 
resources (e.g. <a href="scope/../flow_control/match/destructuring/destructure_pointers.html">references</a>).</p>
<p>When doing assignments (<code>let x = y</code>) or passing function arguments by value
(<code>foo(x)</code>), the <em>ownership</em> of the resources is transferred. In Rust-speak, 
this is known as a <em>move</em>.</p>
<p>After moving resources, the previous owner can no longer be used. This avoids
creating dangling pointers.</p>
<pre><pre class="playground"><code class="language-rust editable">// This function takes ownership of the heap allocated memory
fn destroy_box(c: Box&lt;i32&gt;) {
    println!(&quot;Destroying a box that contains {}&quot;, c);

    // `c` is destroyed and the memory freed
}

fn main() {
    // _Stack_ allocated integer
    let x = 5u32;

    // *Copy* `x` into `y` - no resources are moved
    let y = x;

    // Both values can be independently used
    println!(&quot;x is {}, and y is {}&quot;, x, y);

    // `a` is a pointer to a _heap_ allocated integer
    let a = Box::new(5i32);

    println!(&quot;a contains: {}&quot;, a);

    // *Move* `a` into `b`
    let b = a;
    // The pointer address of `a` is copied (not the data) into `b`.
    // Both are now pointers to the same heap allocated data, but
    // `b` now owns it.
    
    // Error! `a` can no longer access the data, because it no longer owns the
    // heap memory
    //println!(&quot;a contains: {}&quot;, a);
    // TODO ^ Try uncommenting this line

    // This function takes ownership of the heap allocated memory from `b`
    destroy_box(b);

    // Since the heap memory has been freed at this point, this action would
    // result in dereferencing freed memory, but it's forbidden by the compiler
    // Error! Same reason as the previous Error
    //println!(&quot;b contains: {}&quot;, b);
    // TODO ^ Try uncommenting this line
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="mutability"><a class="header" href="#mutability">Mutability</a></h1>
<p>Mutability of data can be changed when ownership is transferred.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let immutable_box = Box::new(5u32);

    println!(&quot;immutable_box contains {}&quot;, immutable_box);

    // Mutability error
    //*immutable_box = 4;

    // *Move* the box, changing the ownership (and mutability)
    let mut mutable_box = immutable_box;

    println!(&quot;mutable_box contains {}&quot;, mutable_box);

    // Modify the contents of the box
    *mutable_box = 4;

    println!(&quot;mutable_box now contains {}&quot;, mutable_box);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="partial-moves"><a class="header" href="#partial-moves">Partial moves</a></h1>
<p>Within the <a href="scope/move/../../flow_control/match/destructuring.html">destructuring</a> of a single variable, both <code>by-move</code> and 
<code>by-reference</code> pattern bindings can be used at the same time. Doing 
this will result in a <em>partial move</em> of the variable, which means 
that parts of the variable will be moved while other parts stay. In 
such a case, the parent variable cannot be used afterwards as a 
whole, however the parts that are only referenced (and not moved) 
can still be used.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    #[derive(Debug)]
    struct Person {
        name: String,
        age: u8,
    }

    let person = Person {
        name: String::from(&quot;Alice&quot;),
        age: 20,
    };

    // `name` is moved out of person, but `age` is referenced
    let Person { name, ref age } = person;

    println!(&quot;The person's age is {}&quot;, age);

    println!(&quot;The person's name is {}&quot;, name);

    // Error! borrow of partially moved value: `person` partial move occurs
    //println!(&quot;The person struct is {:?}&quot;, person);

    // `person` cannot be used but `person.age` can be used as it is not moved
    println!(&quot;The person's age from person struct is {}&quot;, person.age);
}
</code></pre></pre>
<h3 id="see-also-46"><a class="header" href="#see-also-46">See also:</a></h3>
<p><a href="scope/move/../../flow_control/match/destructuring.html">destructuring</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="borrowing"><a class="header" href="#borrowing">Borrowing</a></h1>
<p>Most of the time, we'd like to access data without taking ownership over
it. To accomplish this, Rust uses a <em>borrowing</em> mechanism. Instead of
passing objects by value (<code>T</code>), objects can be passed by reference (<code>&amp;T</code>).</p>
<p>The compiler statically guarantees (via its borrow checker) that references 
<em>always</em> point to valid objects. That is, while references to an object
exist, the object cannot be destroyed.</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">// This function takes ownership of a box and destroys it
fn eat_box_i32(boxed_i32: Box&lt;i32&gt;) {
    println!(&quot;Destroying box that contains {}&quot;, boxed_i32);
}

// This function borrows an i32
fn borrow_i32(borrowed_i32: &amp;i32) {
    println!(&quot;This int is: {}&quot;, borrowed_i32);
}

fn main() {
    // Create a boxed i32, and a stacked i32
    let boxed_i32 = Box::new(5_i32);
    let stacked_i32 = 6_i32;

    // Borrow the contents of the box. Ownership is not taken,
    // so the contents can be borrowed again.
    borrow_i32(&amp;boxed_i32);
    borrow_i32(&amp;stacked_i32);

    {
        // Take a reference to the data contained inside the box
        let _ref_to_i32: &amp;i32 = &amp;boxed_i32;

        // Error!
        // Can't destroy `boxed_i32` while the inner value is borrowed later in scope.
        eat_box_i32(boxed_i32);
        // FIXME ^ Comment out this line

        // Attempt to borrow `_ref_to_i32` after inner value is destroyed
        borrow_i32(_ref_to_i32);
        // `_ref_to_i32` goes out of scope and is no longer borrowed.
    }

    // `boxed_i32` can now give up ownership to `eat_box` and be destroyed
    eat_box_i32(boxed_i32);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="mutability-1"><a class="header" href="#mutability-1">Mutability</a></h1>
<p>Mutable data can be mutably borrowed using <code>&amp;mut T</code>. This is called 
a <em>mutable reference</em> and gives read/write access to the borrower.
In contrast, <code>&amp;T</code> borrows the data via an immutable reference, and 
the borrower can read the data but not modify it:</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">#[allow(dead_code)]
#[derive(Clone, Copy)]
struct Book {
    // `&amp;'static str` is a reference to a string allocated in read only memory
    author: &amp;'static str,
    title: &amp;'static str,
    year: u32,
}

// This function takes a reference to a book
fn borrow_book(book: &amp;Book) {
    println!(&quot;I immutably borrowed {} - {} edition&quot;, book.title, book.year);
}

// This function takes a reference to a mutable book and changes `year` to 2014
fn new_edition(book: &amp;mut Book) {
    book.year = 2014;
    println!(&quot;I mutably borrowed {} - {} edition&quot;, book.title, book.year);
}

fn main() {
    // Create an immutable Book named `immutabook`
    let immutabook = Book {
        // string literals have type `&amp;'static str`
        author: &quot;Douglas Hofstadter&quot;,
        title: &quot;Gödel, Escher, Bach&quot;,
        year: 1979,
    };

    // Create a mutable copy of `immutabook` and call it `mutabook`
    let mut mutabook = immutabook;
    
    // Immutably borrow an immutable object
    borrow_book(&amp;immutabook);

    // Immutably borrow a mutable object
    borrow_book(&amp;mutabook);
    
    // Borrow a mutable object as mutable
    new_edition(&amp;mut mutabook);
    
    // Error! Cannot borrow an immutable object as mutable
    new_edition(&amp;mut immutabook);
    // FIXME ^ Comment out this line
}
</code></pre></pre>
<h3 id="see-also-47"><a class="header" href="#see-also-47">See also:</a></h3>
<p><a href="scope/borrow/../lifetime/static_lifetime.html"><code>static</code></a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="aliasing"><a class="header" href="#aliasing">Aliasing</a></h1>
<p>Data can be immutably borrowed any number of times, but while immutably
borrowed, the original data can't be mutably borrowed. On the other hand, only
<em>one</em> mutable borrow is allowed at a time. The original data can be borrowed
again only <em>after</em> the mutable reference has been used for the last time.</p>
<pre><pre class="playground"><code class="language-rust editable">struct Point { x: i32, y: i32, z: i32 }

fn main() {
    let mut point = Point { x: 0, y: 0, z: 0 };

    let borrowed_point = &amp;point;
    let another_borrow = &amp;point;

    // Data can be accessed via the references and the original owner
    println!(&quot;Point has coordinates: ({}, {}, {})&quot;,
                borrowed_point.x, another_borrow.y, point.z);

    // Error! Can't borrow `point` as mutable because it's currently
    // borrowed as immutable.
    // let mutable_borrow = &amp;mut point;
    // TODO ^ Try uncommenting this line

    // The borrowed values are used again here
    println!(&quot;Point has coordinates: ({}, {}, {})&quot;,
                borrowed_point.x, another_borrow.y, point.z);

    // The immutable references are no longer used for the rest of the code so
    // it is possible to reborrow with a mutable reference.
    let mutable_borrow = &amp;mut point;

    // Change data via mutable reference
    mutable_borrow.x = 5;
    mutable_borrow.y = 2;
    mutable_borrow.z = 1;

    // Error! Can't borrow `point` as immutable because it's currently
    // borrowed as mutable.
    // let y = &amp;point.y;
    // TODO ^ Try uncommenting this line

    // Error! Can't print because `println!` takes an immutable reference.
    // println!(&quot;Point Z coordinate is {}&quot;, point.z);
    // TODO ^ Try uncommenting this line

    // Ok! Mutable references can be passed as immutable to `println!`
    println!(&quot;Point has coordinates: ({}, {}, {})&quot;,
                mutable_borrow.x, mutable_borrow.y, mutable_borrow.z);

    // The mutable reference is no longer used for the rest of the code so it
    // is possible to reborrow
    let new_borrowed_point = &amp;point;
    println!(&quot;Point now has coordinates: ({}, {}, {})&quot;,
             new_borrowed_point.x, new_borrowed_point.y, new_borrowed_point.z);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="the-ref-pattern"><a class="header" href="#the-ref-pattern">The ref pattern</a></h1>
<p>When doing pattern matching or destructuring via the <code>let</code> binding, the <code>ref</code>
keyword can be used to take references to the fields of a struct/tuple. The 
example below shows a few instances where this can be useful:</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Clone, Copy)]
struct Point { x: i32, y: i32 }

fn main() {
    let c = 'Q';

    // A `ref` borrow on the left side of an assignment is equivalent to
    // an `&amp;` borrow on the right side.
    let ref ref_c1 = c;
    let ref_c2 = &amp;c;

    println!(&quot;ref_c1 equals ref_c2: {}&quot;, *ref_c1 == *ref_c2);

    let point = Point { x: 0, y: 0 };

    // `ref` is also valid when destructuring a struct.
    let _copy_of_x = {
        // `ref_to_x` is a reference to the `x` field of `point`.
        let Point { x: ref ref_to_x, y: _ } = point;

        // Return a copy of the `x` field of `point`.
        *ref_to_x
    };

    // A mutable copy of `point`
    let mut mutable_point = point;

    {
        // `ref` can be paired with `mut` to take mutable references.
        let Point { x: _, y: ref mut mut_ref_to_y } = mutable_point;

        // Mutate the `y` field of `mutable_point` via a mutable reference.
        *mut_ref_to_y = 1;
    }

    println!(&quot;point is ({}, {})&quot;, point.x, point.y);
    println!(&quot;mutable_point is ({}, {})&quot;, mutable_point.x, mutable_point.y);

    // A mutable tuple that includes a pointer
    let mut mutable_tuple = (Box::new(5u32), 3u32);
    
    {
        // Destructure `mutable_tuple` to change the value of `last`.
        let (_, ref mut last) = mutable_tuple;
        *last = 2u32;
    }
    
    println!(&quot;tuple is {:?}&quot;, mutable_tuple);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="lifetimes"><a class="header" href="#lifetimes">Lifetimes</a></h1>
<p>A <em>lifetime</em> is a construct the compiler (or more specifically, its <em>borrow
checker</em>) uses to ensure all borrows are valid. Specifically, a variable's
lifetime begins when it is created and ends when it is destroyed. While
lifetimes and scopes are often referred to together, they are not the same.</p>
<p>Take, for example, the case where we borrow a variable via <code>&amp;</code>. The
borrow has a lifetime that is determined by where it is declared. As a result,
the borrow is valid as long as it ends before the lender is destroyed. However,
the scope of the borrow is determined by where the reference is used.</p>
<p>In the following example and in the rest of this section, we will see how
lifetimes relate to scopes, as well as how the two differ.</p>
<pre><pre class="playground"><code class="language-rust editable">// Lifetimes are annotated below with lines denoting the creation
// and destruction of each variable.
// `i` has the longest lifetime because its scope entirely encloses 
// both `borrow1` and `borrow2`. The duration of `borrow1` compared 
// to `borrow2` is irrelevant since they are disjoint.
fn main() {
    let i = 3; // Lifetime for `i` starts. ────────────────┐
    //                                                     │
    { //                                                   │
        let borrow1 = &amp;i; // `borrow1` lifetime starts. ──┐│
        //                                                ││
        println!(&quot;borrow1: {}&quot;, borrow1); //              ││
    } // `borrow1 ends. ──────────────────────────────────┘│
    //                                                     │
    //                                                     │
    { //                                                   │
        let borrow2 = &amp;i; // `borrow2` lifetime starts. ──┐│
        //                                                ││
        println!(&quot;borrow2: {}&quot;, borrow2); //              ││
    } // `borrow2` ends. ─────────────────────────────────┘│
    //                                                     │
}   // Lifetime ends. ─────────────────────────────────────┘
</code></pre></pre>
<p>Note that no names or types are assigned to label lifetimes.
This restricts how lifetimes will be able to be used as we will see.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="explicit-annotation"><a class="header" href="#explicit-annotation">Explicit annotation</a></h1>
<p>The borrow checker uses explicit lifetime annotations to determine
how long references should be valid. In cases where lifetimes are not
elided<sup class="footnote-reference"><a href="#1">1</a></sup>, Rust requires explicit annotations to determine what the 
lifetime of a reference should be. The syntax for explicitly annotating 
a lifetime uses an apostrophe character as follows: </p>
<pre><code class="language-rust ignore">foo&lt;'a&gt;
// `foo` has a lifetime parameter `'a`
</code></pre>
<p>Similar to <a href="scope/lifetime/../../fn/closures/anonymity.html">closures</a>, using lifetimes requires generics. 
Additionally, this lifetime syntax indicates that the lifetime of <code>foo</code> 
may not exceed that of <code>'a</code>. Explicit annotation of a type has the form 
<code>&amp;'a T</code> where <code>'a</code> has already been introduced.</p>
<p>In cases with multiple lifetimes, the syntax is similar:</p>
<pre><code class="language-rust ignore">foo&lt;'a, 'b&gt;
// `foo` has lifetime parameters `'a` and `'b`
</code></pre>
<p>In this case, the lifetime of <code>foo</code> cannot exceed that of either <code>'a</code> <em>or</em> <code>'b</code>.</p>
<p>See the following example for explicit lifetime annotation in use:</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">// `print_refs` takes two references to `i32` which have different
// lifetimes `'a` and `'b`. These two lifetimes must both be at
// least as long as the function `print_refs`.
fn print_refs&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32) {
    println!(&quot;x is {} and y is {}&quot;, x, y);
}

// A function which takes no arguments, but has a lifetime parameter `'a`.
fn failed_borrow&lt;'a&gt;() {
    let _x = 12;

    // ERROR: `_x` does not live long enough
    let y: &amp;'a i32 = &amp;_x;
    // Attempting to use the lifetime `'a` as an explicit type annotation 
    // inside the function will fail because the lifetime of `&amp;_x` is shorter
    // than that of `y`. A short lifetime cannot be coerced into a longer one.
}

fn main() {
    // Create variables to be borrowed below.
    let (four, nine) = (4, 9);
    
    // Borrows (`&amp;`) of both variables are passed into the function.
    print_refs(&amp;four, &amp;nine);
    // Any input which is borrowed must outlive the borrower. 
    // In other words, the lifetime of `four` and `nine` must 
    // be longer than that of `print_refs`.
    
    failed_borrow();
    // `failed_borrow` contains no references to force `'a` to be 
    // longer than the lifetime of the function, but `'a` is longer.
    // Because the lifetime is never constrained, it defaults to `'static`.
}
</code></pre></pre>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p><a href="scope/lifetime/elision.html">elision</a> implicitly annotates lifetimes and so is different.</p>
</div>
<h3 id="see-also-48"><a class="header" href="#see-also-48">See also:</a></h3>
<p><a href="scope/lifetime/../../generics.html">generics</a> and <a href="scope/lifetime/../../fn/closures.html">closures</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="functions-2"><a class="header" href="#functions-2">Functions</a></h1>
<p>Ignoring <a href="scope/lifetime/elision.html">elision</a>, function signatures with lifetimes have a few constraints: </p>
<ul>
<li>any reference <em>must</em> have an annotated lifetime.</li>
<li>any reference being returned <em>must</em> have the same lifetime as an input or
be <code>static</code>.</li>
</ul>
<p>Additionally, note that returning references without input is banned if it
would result in returning references to invalid data. The following example shows
off some valid forms of functions with lifetimes:</p>
<pre><pre class="playground"><code class="language-rust editable">// One input reference with lifetime `'a` which must live
// at least as long as the function.
fn print_one&lt;'a&gt;(x: &amp;'a i32) {
    println!(&quot;`print_one`: x is {}&quot;, x);
}

// Mutable references are possible with lifetimes as well.
fn add_one&lt;'a&gt;(x: &amp;'a mut i32) {
    *x += 1;
}

// Multiple elements with different lifetimes. In this case, it
// would be fine for both to have the same lifetime `'a`, but
// in more complex cases, different lifetimes may be required.
fn print_multi&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32) {
    println!(&quot;`print_multi`: x is {}, y is {}&quot;, x, y);
}

// Returning references that have been passed in is acceptable.
// However, the correct lifetime must be returned.
fn pass_x&lt;'a, 'b&gt;(x: &amp;'a i32, _: &amp;'b i32) -&gt; &amp;'a i32 { x }

//fn invalid_output&lt;'a&gt;() -&gt; &amp;'a String { &amp;String::from(&quot;foo&quot;) }
// The above is invalid: `'a` must live longer than the function.
// Here, `&amp;String::from(&quot;foo&quot;)` would create a `String`, followed by a
// reference. Then the data is dropped upon exiting the scope, leaving
// a reference to invalid data to be returned.

fn main() {
    let x = 7;
    let y = 9;
    
    print_one(&amp;x);
    print_multi(&amp;x, &amp;y);
    
    let z = pass_x(&amp;x, &amp;y);
    print_one(z);

    let mut t = 3;
    add_one(&amp;mut t);
    print_one(&amp;t);
}
</code></pre></pre>
<h3 id="see-also-49"><a class="header" href="#see-also-49">See also:</a></h3>
<p><a href="scope/lifetime/fn.html">functions</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="methods-1"><a class="header" href="#methods-1">Methods</a></h1>
<p>Methods are annotated similarly to functions:</p>
<pre><pre class="playground"><code class="language-rust editable">struct Owner(i32);

impl Owner {
    // Annotate lifetimes as in a standalone function.
    fn add_one&lt;'a&gt;(&amp;'a mut self) { self.0 += 1; }
    fn print&lt;'a&gt;(&amp;'a self) {
        println!(&quot;`print`: {}&quot;, self.0);
    }
}

fn main() {
    let mut owner = Owner(18);

    owner.add_one();
    owner.print();
}
</code></pre></pre>
<h3 id="see-also-50"><a class="header" href="#see-also-50">See also:</a></h3>
<p><a href="scope/lifetime/../../fn/methods.html">methods</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="structs"><a class="header" href="#structs">Structs</a></h1>
<p>Annotation of lifetimes in structures are also similar to functions:</p>
<pre><pre class="playground"><code class="language-rust editable">// A type `Borrowed` which houses a reference to an
// `i32`. The reference to `i32` must outlive `Borrowed`.
#[derive(Debug)]
struct Borrowed&lt;'a&gt;(&amp;'a i32);

// Similarly, both references here must outlive this structure.
#[derive(Debug)]
struct NamedBorrowed&lt;'a&gt; {
    x: &amp;'a i32,
    y: &amp;'a i32,
}

// An enum which is either an `i32` or a reference to one.
#[derive(Debug)]
enum Either&lt;'a&gt; {
    Num(i32),
    Ref(&amp;'a i32),
}

fn main() {
    let x = 18;
    let y = 15;

    let single = Borrowed(&amp;x);
    let double = NamedBorrowed { x: &amp;x, y: &amp;y };
    let reference = Either::Ref(&amp;x);
    let number    = Either::Num(y);

    println!(&quot;x is borrowed in {:?}&quot;, single);
    println!(&quot;x and y are borrowed in {:?}&quot;, double);
    println!(&quot;x is borrowed in {:?}&quot;, reference);
    println!(&quot;y is *not* borrowed in {:?}&quot;, number);
}
</code></pre></pre>
<h3 id="see-also-51"><a class="header" href="#see-also-51">See also:</a></h3>
<p><a href="scope/lifetime/../../custom_types/structs.html"><code>struct</code>s</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="traits-1"><a class="header" href="#traits-1">Traits</a></h1>
<p>Annotation of lifetimes in trait methods basically are similar to functions.
Note that <code>impl</code> may have annotation of lifetimes too.</p>
<pre><pre class="playground"><code class="language-rust editable">// A struct with annotation of lifetimes.
#[derive(Debug)]
struct Borrowed&lt;'a&gt; {
    x: &amp;'a i32,
}

// Annotate lifetimes to impl.
impl&lt;'a&gt; Default for Borrowed&lt;'a&gt; {
    fn default() -&gt; Self {
        Self {
            x: &amp;10,
        }
    }
}

fn main() {
    let b: Borrowed = Default::default();
    println!(&quot;b is {:?}&quot;, b);
}
</code></pre></pre>
<h3 id="see-also-52"><a class="header" href="#see-also-52">See also:</a></h3>
<p><a href="scope/lifetime/../../trait.html"><code>trait</code>s</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="bounds-1"><a class="header" href="#bounds-1">Bounds</a></h1>
<p>Just like generic types can be bounded, lifetimes (themselves generic)
use bounds as well. The <code>:</code> character has a slightly different meaning here, 
but <code>+</code> is the same. Note how the following read:</p>
<ol>
<li><code>T: 'a</code>: <em>All</em> references in <code>T</code> must outlive lifetime <code>'a</code>.</li>
<li><code>T: Trait + 'a</code>: Type <code>T</code> must implement trait <code>Trait</code> and <em>all</em> references
in <code>T</code> must outlive <code>'a</code>.</li>
</ol>
<p>The example below shows the above syntax in action used after keyword <code>where</code>:</p>
<pre><pre class="playground"><code class="language-rust editable">use std::fmt::Debug; // Trait to bound with.

#[derive(Debug)]
struct Ref&lt;'a, T: 'a&gt;(&amp;'a T);
// `Ref` contains a reference to a generic type `T` that has
// an unknown lifetime `'a`. `T` is bounded such that any
// *references* in `T` must outlive `'a`. Additionally, the lifetime
// of `Ref` may not exceed `'a`.

// A generic function which prints using the `Debug` trait.
fn print&lt;T&gt;(t: T) where
    T: Debug {
    println!(&quot;`print`: t is {:?}&quot;, t);
}

// Here a reference to `T` is taken where `T` implements
// `Debug` and all *references* in `T` outlive `'a`. In
// addition, `'a` must outlive the function.
fn print_ref&lt;'a, T&gt;(t: &amp;'a T) where
    T: Debug + 'a {
    println!(&quot;`print_ref`: t is {:?}&quot;, t);
}

fn main() {
    let x = 7;
    let ref_x = Ref(&amp;x);

    print_ref(&amp;ref_x);
    print(ref_x);
}
</code></pre></pre>
<h3 id="see-also-53"><a class="header" href="#see-also-53">See also:</a></h3>
<p><a href="scope/lifetime/../../generics.html">generics</a>, <a href="scope/lifetime/../../generics/bounds.html">bounds in generics</a>, and 
<a href="scope/lifetime/../../generics/multi_bounds.html">multiple bounds in generics</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="coercion"><a class="header" href="#coercion">Coercion</a></h1>
<p>A longer lifetime can be coerced into a shorter one 
so that it works inside a scope it normally wouldn't work in.
This comes in the form of inferred coercion by the Rust compiler,
and also in the form of declaring a lifetime difference:</p>
<pre><pre class="playground"><code class="language-rust editable">// Here, Rust infers a lifetime that is as short as possible.
// The two references are then coerced to that lifetime.
fn multiply&lt;'a&gt;(first: &amp;'a i32, second: &amp;'a i32) -&gt; i32 {
    first * second
}

// `&lt;'a: 'b, 'b&gt;` reads as lifetime `'a` is at least as long as `'b`.
// Here, we take in an `&amp;'a i32` and return a `&amp;'b i32` as a result of coercion.
fn choose_first&lt;'a: 'b, 'b&gt;(first: &amp;'a i32, _: &amp;'b i32) -&gt; &amp;'b i32 {
    first
}

fn main() {
    let first = 2; // Longer lifetime
    
    {
        let second = 3; // Shorter lifetime
        
        println!(&quot;The product is {}&quot;, multiply(&amp;first, &amp;second));
        println!(&quot;{} is the first&quot;, choose_first(&amp;first, &amp;second));
    };
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="static"><a class="header" href="#static">Static</a></h1>
<p>Rust has a few reserved lifetime names. One of those is <code>'static</code>. You
might encounter it in two situations:</p>
<pre><pre class="playground"><code class="language-rust editable">// A reference with 'static lifetime:
let s: &amp;'static str = &quot;hello world&quot;;

// 'static as part of a trait bound:
fn generic&lt;T&gt;(x: T) where T: 'static {}
</code></pre></pre>
<p>Both are related but subtly different and this is a common source for
confusion when learning Rust. Here are some examples for each situation:</p>
<h2 id="reference-lifetime"><a class="header" href="#reference-lifetime">Reference lifetime</a></h2>
<p>As a reference lifetime <code>'static</code> indicates that the data pointed to by
the reference lives for the entire lifetime of the running program.
It can still be coerced to a shorter lifetime.</p>
<p>There are two ways to make a variable with <code>'static</code> lifetime, and both
are stored in the read-only memory of the binary:</p>
<ul>
<li>Make a constant with the <code>static</code> declaration.</li>
<li>Make a <code>string</code> literal which has type: <code>&amp;'static str</code>.</li>
</ul>
<p>See the following example for a display of each method:</p>
<pre><pre class="playground"><code class="language-rust editable">// Make a constant with `'static` lifetime.
static NUM: i32 = 18;

// Returns a reference to `NUM` where its `'static`
// lifetime is coerced to that of the input argument.
fn coerce_static&lt;'a&gt;(_: &amp;'a i32) -&gt; &amp;'a i32 {
    &amp;NUM
}

fn main() {
    {
        // Make a `string` literal and print it:
        let static_string = &quot;I'm in read-only memory&quot;;
        println!(&quot;static_string: {}&quot;, static_string);

        // When `static_string` goes out of scope, the reference
        // can no longer be used, but the data remains in the binary.
    }

    {
        // Make an integer to use for `coerce_static`:
        let lifetime_num = 9;

        // Coerce `NUM` to lifetime of `lifetime_num`:
        let coerced_static = coerce_static(&amp;lifetime_num);

        println!(&quot;coerced_static: {}&quot;, coerced_static);
    }

    println!(&quot;NUM: {} stays accessible!&quot;, NUM);
}
</code></pre></pre>
<h2 id="trait-bound"><a class="header" href="#trait-bound">Trait bound</a></h2>
<p>As a trait bound, it means the type does not contain any non-static
references. Eg. the receiver can hold on to the type for as long as
they want and it will never become invalid until they drop it.</p>
<p>It's important to understand this means that any owned data always passes
a <code>'static</code> lifetime bound, but a reference to that owned data generally
does not:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use std::fmt::Debug;

fn print_it( input: impl Debug + 'static ) {
    println!( &quot;'static value passed in is: {:?}&quot;, input );
}

fn main() {
    // i is owned and contains no references, thus it's 'static:
    let i = 5;
    print_it(i);

    // oops, &amp;i only has the lifetime defined by the scope of
    // main(), so it's not 'static:
    print_it(&amp;i);
}
</code></pre></pre>
<p>The compiler will tell you:</p>
<pre><code class="language-ignore">error[E0597]: `i` does not live long enough
  --&gt; src/lib.rs:15:15
   |
15 |     print_it(&amp;i);
   |     ---------^^--
   |     |         |
   |     |         borrowed value does not live long enough
   |     argument requires that `i` is borrowed for `'static`
16 | }
   | - `i` dropped here while still borrowed
</code></pre>
<h3 id="see-also-54"><a class="header" href="#see-also-54">See also:</a></h3>
<p><a href="scope/lifetime/../../custom_types/constants.html"><code>'static</code> constants</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="elision"><a class="header" href="#elision">Elision</a></h1>
<p>Some lifetime patterns are overwhelmingly common and so the borrow checker
will allow you to omit them to save typing and to improve readability.
This is known as elision. Elision exists in Rust solely because these patterns
are common.</p>
<p>The following code shows a few examples of elision. For a more comprehensive
description of elision, see <a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-elision">lifetime elision</a> in the book.</p>
<pre><pre class="playground"><code class="language-rust editable">// `elided_input` and `annotated_input` essentially have identical signatures
// because the lifetime of `elided_input` is inferred by the compiler:
fn elided_input(x: &amp;i32) {
    println!(&quot;`elided_input`: {}&quot;, x);
}

fn annotated_input&lt;'a&gt;(x: &amp;'a i32) {
    println!(&quot;`annotated_input`: {}&quot;, x);
}

// Similarly, `elided_pass` and `annotated_pass` have identical signatures
// because the lifetime is added implicitly to `elided_pass`:
fn elided_pass(x: &amp;i32) -&gt; &amp;i32 { x }

fn annotated_pass&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32 { x }

fn main() {
    let x = 3;

    elided_input(&amp;x);
    annotated_input(&amp;x);

    println!(&quot;`elided_pass`: {}&quot;, elided_pass(&amp;x));
    println!(&quot;`annotated_pass`: {}&quot;, annotated_pass(&amp;x));
}
</code></pre></pre>
<h3 id="see-also-55"><a class="header" href="#see-also-55">See also:</a></h3>
<p><a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-elision">elision</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="traits-2"><a class="header" href="#traits-2">Traits</a></h1>
<p>A <code>trait</code> is a collection of methods defined for an unknown type:
<code>Self</code>. They can access other methods declared in the same trait.</p>
<p>Traits can be implemented for any data type. In the example below,
we define <code>Animal</code>, a group of methods. The <code>Animal</code> <code>trait</code> is 
then implemented for the <code>Sheep</code> data type, allowing the use of 
methods from <code>Animal</code> with a <code>Sheep</code>.</p>
<pre><pre class="playground"><code class="language-rust editable">struct Sheep { naked: bool, name: &amp;'static str }

trait Animal {
    // Static method signature; `Self` refers to the implementor type.
    fn new(name: &amp;'static str) -&gt; Self;

    // Instance method signatures; these will return a string.
    fn name(&amp;self) -&gt; &amp;'static str;
    fn noise(&amp;self) -&gt; &amp;'static str;

    // Traits can provide default method definitions.
    fn talk(&amp;self) {
        println!(&quot;{} says {}&quot;, self.name(), self.noise());
    }
}

impl Sheep {
    fn is_naked(&amp;self) -&gt; bool {
        self.naked
    }

    fn shear(&amp;mut self) {
        if self.is_naked() {
            // Implementor methods can use the implementor's trait methods.
            println!(&quot;{} is already naked...&quot;, self.name());
        } else {
            println!(&quot;{} gets a haircut!&quot;, self.name);

            self.naked = true;
        }
    }
}

// Implement the `Animal` trait for `Sheep`.
impl Animal for Sheep {
    // `Self` is the implementor type: `Sheep`.
    fn new(name: &amp;'static str) -&gt; Sheep {
        Sheep { name: name, naked: false }
    }

    fn name(&amp;self) -&gt; &amp;'static str {
        self.name
    }

    fn noise(&amp;self) -&gt; &amp;'static str {
        if self.is_naked() {
            &quot;baaaaah?&quot;
        } else {
            &quot;baaaaah!&quot;
        }
    }
    
    // Default trait methods can be overridden.
    fn talk(&amp;self) {
        // For example, we can add some quiet contemplation.
        println!(&quot;{} pauses briefly... {}&quot;, self.name, self.noise());
    }
}

fn main() {
    // Type annotation is necessary in this case.
    let mut dolly: Sheep = Animal::new(&quot;Dolly&quot;);
    // TODO ^ Try removing the type annotations.

    dolly.talk();
    dolly.shear();
    dolly.talk();
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="derive"><a class="header" href="#derive">Derive</a></h1>
<p>The compiler is capable of providing basic implementations for some traits via
the <code>#[derive]</code> <a href="trait/../attribute.html">attribute</a>. These traits can still be
manually implemented if a more complex behavior is required.</p>
<p>The following is a list of derivable traits:</p>
<ul>
<li>Comparison traits:
<a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html"><code>Eq</code></a>, <a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html"><code>PartialEq</code></a>, <a href="https://doc.rust-lang.org/std/cmp/trait.Ord.html"><code>Ord</code></a>, <a href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html"><code>PartialOrd</code></a>.</li>
<li><a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a>, to create <code>T</code> from <code>&amp;T</code> via a copy.</li>
<li><a href="https://doc.rust-lang.org/core/marker/trait.Copy.html"><code>Copy</code></a>, to give a type 'copy semantics' instead of 'move semantics'.</li>
<li><a href="https://doc.rust-lang.org/std/hash/trait.Hash.html"><code>Hash</code></a>, to compute a hash from <code>&amp;T</code>.</li>
<li><a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a>, to create an empty instance of a data type.</li>
<li><a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a>, to format a value using the <code>{:?}</code> formatter.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">// `Centimeters`, a tuple struct that can be compared
#[derive(PartialEq, PartialOrd)]
struct Centimeters(f64);

// `Inches`, a tuple struct that can be printed
#[derive(Debug)]
struct Inches(i32);

impl Inches {
    fn to_centimeters(&amp;self) -&gt; Centimeters {
        let &amp;Inches(inches) = self;

        Centimeters(inches as f64 * 2.54)
    }
}

// `Seconds`, a tuple struct with no additional attributes
struct Seconds(i32);

fn main() {
    let _one_second = Seconds(1);

    // Error: `Seconds` can't be printed; it doesn't implement the `Debug` trait
    //println!(&quot;One second looks like: {:?}&quot;, _one_second);
    // TODO ^ Try uncommenting this line

    // Error: `Seconds` can't be compared; it doesn't implement the `PartialEq` trait
    //let _this_is_true = (_one_second == _one_second);
    // TODO ^ Try uncommenting this line

    let foot = Inches(12);

    println!(&quot;One foot equals {:?}&quot;, foot);

    let meter = Centimeters(100.0);

    let cmp =
        if foot.to_centimeters() &lt; meter {
            &quot;smaller&quot;
        } else {
            &quot;bigger&quot;
        };

    println!(&quot;One foot is {} than one meter.&quot;, cmp);
}
</code></pre></pre>
<h3 id="see-also-56"><a class="header" href="#see-also-56">See also:</a></h3>
<p><a href="https://doc.rust-lang.org/reference/attributes.html#derive"><code>derive</code></a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="returning-traits-with-dyn"><a class="header" href="#returning-traits-with-dyn">Returning Traits with <code>dyn</code></a></h1>
<p>The Rust compiler needs to know how much space every function's return type requires. This means all your functions have to return a concrete type. Unlike other languages, if you have a trait like <code>Animal</code>, you can't write a function that returns <code>Animal</code>, because its different implementations will need different amounts of memory. </p>
<p>However, there's an easy workaround. Instead of returning a trait object directly, our functions return a <code>Box</code> which <em>contains</em> some <code>Animal</code>. A <code>box</code> is just a reference to some memory in the heap. Because a reference has a statically-known size, and the compiler can guarantee it points to a heap-allocated <code>Animal</code>, we can return a trait from our function!</p>
<p>Rust tries to be as explicit as possible whenever it allocates memory on the heap. So if your function returns a pointer-to-trait-on-heap in this way, you need to write the return type with the <code>dyn</code> keyword, e.g. <code>Box&lt;dyn Animal&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust editable">struct Sheep {}
struct Cow {}

trait Animal {
    // Instance method signature
    fn noise(&amp;self) -&gt; &amp;'static str;
}

// Implement the `Animal` trait for `Sheep`.
impl Animal for Sheep {
    fn noise(&amp;self) -&gt; &amp;'static str {
        &quot;baaaaah!&quot;
    }
}

// Implement the `Animal` trait for `Cow`.
impl Animal for Cow {
    fn noise(&amp;self) -&gt; &amp;'static str {
        &quot;moooooo!&quot;
    }
}

// Returns some struct that implements Animal, but we don't know which one at compile time.
fn random_animal(random_number: f64) -&gt; Box&lt;dyn Animal&gt; {
    if random_number &lt; 0.5 {
        Box::new(Sheep {})
    } else {
        Box::new(Cow {})
    }
}

fn main() {
    let random_number = 0.234;
    let animal = random_animal(random_number);
    println!(&quot;You've randomly chosen an animal, and it says {}&quot;, animal.noise());
}

</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="operator-overloading"><a class="header" href="#operator-overloading">Operator Overloading</a></h1>
<p>In Rust, many of the operators can be overloaded via traits. That is, some operators can
be used to accomplish different tasks based on their input arguments. This is possible
because operators are syntactic sugar for method calls. For example, the <code>+</code> operator in
<code>a + b</code> calls the <code>add</code> method (as in <code>a.add(b)</code>). This <code>add</code> method is part of the <code>Add</code>
trait. Hence, the <code>+</code> operator can be used by any implementor of the <code>Add</code> trait.</p>
<p>A list of the traits, such as <code>Add</code>, that overload operators can be found in <a href="https://doc.rust-lang.org/core/ops/"><code>core::ops</code></a>.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::ops;

struct Foo;
struct Bar;

#[derive(Debug)]
struct FooBar;

#[derive(Debug)]
struct BarFoo;

// The `std::ops::Add` trait is used to specify the functionality of `+`.
// Here, we make `Add&lt;Bar&gt;` - the trait for addition with a RHS of type `Bar`.
// The following block implements the operation: Foo + Bar = FooBar
impl ops::Add&lt;Bar&gt; for Foo {
    type Output = FooBar;

    fn add(self, _rhs: Bar) -&gt; FooBar {
        println!(&quot;&gt; Foo.add(Bar) was called&quot;);

        FooBar
    }
}

// By reversing the types, we end up implementing non-commutative addition.
// Here, we make `Add&lt;Foo&gt;` - the trait for addition with a RHS of type `Foo`.
// This block implements the operation: Bar + Foo = BarFoo
impl ops::Add&lt;Foo&gt; for Bar {
    type Output = BarFoo;

    fn add(self, _rhs: Foo) -&gt; BarFoo {
        println!(&quot;&gt; Bar.add(Foo) was called&quot;);

        BarFoo
    }
}

fn main() {
    println!(&quot;Foo + Bar = {:?}&quot;, Foo + Bar);
    println!(&quot;Bar + Foo = {:?}&quot;, Bar + Foo);
}
</code></pre></pre>
<h3 id="see-also-57"><a class="header" href="#see-also-57">See Also</a></h3>
<p><a href="https://doc.rust-lang.org/core/ops/trait.Add.html">Add</a>, <a href="https://doc.rust-lang.org/book/appendix-02-operators.html">Syntax Index</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="drop"><a class="header" href="#drop">Drop</a></h1>
<p>The <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a> trait only has one method: <code>drop</code>, which is called automatically 
when an object goes out of scope. The main use of the <code>Drop</code> trait is to free the
resources that the implementor instance owns.</p>
<p><code>Box</code>, <code>Vec</code>, <code>String</code>, <code>File</code>, and <code>Process</code> are some examples of types that
implement the <code>Drop</code> trait to free resources. The <code>Drop</code> trait can also be
manually implemented for any custom data type.</p>
<p>The following example adds a print to console to the <code>drop</code> function to announce
when it is called.</p>
<pre><pre class="playground"><code class="language-rust editable">struct Droppable {
    name: &amp;'static str,
}

// This trivial implementation of `drop` adds a print to console.
impl Drop for Droppable {
    fn drop(&amp;mut self) {
        println!(&quot;&gt; Dropping {}&quot;, self.name);
    }
}

fn main() {
    let _a = Droppable { name: &quot;a&quot; };

    // block A
    {
        let _b = Droppable { name: &quot;b&quot; };

        // block B
        {
            let _c = Droppable { name: &quot;c&quot; };
            let _d = Droppable { name: &quot;d&quot; };

            println!(&quot;Exiting block B&quot;);
        }
        println!(&quot;Just exited block B&quot;);

        println!(&quot;Exiting block A&quot;);
    }
    println!(&quot;Just exited block A&quot;);

    // Variable can be manually dropped using the `drop` function
    drop(_a);
    // TODO ^ Try commenting this line

    println!(&quot;end of the main function&quot;);

    // `_a` *won't* be `drop`ed again here, because it already has been
    // (manually) `drop`ed
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="iterators"><a class="header" href="#iterators">Iterators</a></h1>
<p>The <a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html"><code>Iterator</code></a> trait is used to implement iterators over collections such as arrays.</p>
<p>The trait requires only a method to be defined for the <code>next</code> element, 
which may be manually defined in an <code>impl</code> block or automatically 
defined (as in arrays and ranges).</p>
<p>As a point of convenience for common situations, the <code>for</code> construct 
turns some collections into iterators using the <a href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html"><code>.into_iter()</code></a> method.</p>
<pre><pre class="playground"><code class="language-rust editable">struct Fibonacci {
    curr: u32,
    next: u32,
}

// Implement `Iterator` for `Fibonacci`.
// The `Iterator` trait only requires a method to be defined for the `next` element.
impl Iterator for Fibonacci {
    // We can refer to this type using Self::Item
    type Item = u32;
    
    // Here, we define the sequence using `.curr` and `.next`.
    // The return type is `Option&lt;T&gt;`:
    //     * When the `Iterator` is finished, `None` is returned.
    //     * Otherwise, the next value is wrapped in `Some` and returned.
    // We use Self::Item in the return type, so we can change
    // the type without having to update the function signatures.
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let new_next = self.curr + self.next;

        self.curr = self.next;
        self.next = new_next;

        // Since there's no endpoint to a Fibonacci sequence, the `Iterator` 
        // will never return `None`, and `Some` is always returned.
        Some(self.curr)
    }
}

// Returns a Fibonacci sequence generator
fn fibonacci() -&gt; Fibonacci {
    Fibonacci { curr: 0, next: 1 }
}

fn main() {
    // `0..3` is an `Iterator` that generates: 0, 1, and 2.
    let mut sequence = 0..3;

    println!(&quot;Four consecutive `next` calls on 0..3&quot;);
    println!(&quot;&gt; {:?}&quot;, sequence.next());
    println!(&quot;&gt; {:?}&quot;, sequence.next());
    println!(&quot;&gt; {:?}&quot;, sequence.next());
    println!(&quot;&gt; {:?}&quot;, sequence.next());

    // `for` works through an `Iterator` until it returns `None`.
    // Each `Some` value is unwrapped and bound to a variable (here, `i`).
    println!(&quot;Iterate through 0..3 using `for`&quot;);
    for i in 0..3 {
        println!(&quot;&gt; {}&quot;, i);
    }

    // The `take(n)` method reduces an `Iterator` to its first `n` terms.
    println!(&quot;The first four terms of the Fibonacci sequence are: &quot;);
    for i in fibonacci().take(4) {
        println!(&quot;&gt; {}&quot;, i);
    }

    // The `skip(n)` method shortens an `Iterator` by dropping its first `n` terms.
    println!(&quot;The next four terms of the Fibonacci sequence are: &quot;);
    for i in fibonacci().skip(4).take(4) {
        println!(&quot;&gt; {}&quot;, i);
    }

    let array = [1u32, 3, 3, 7];

    // The `iter` method produces an `Iterator` over an array/slice.
    println!(&quot;Iterate the following array {:?}&quot;, &amp;array);
    for i in array.iter() {
        println!(&quot;&gt; {}&quot;, i);
    }
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="impl-trait"><a class="header" href="#impl-trait"><code>impl Trait</code></a></h1>
<p>If your function returns a type that implements <code>MyTrait</code>, you can write its
return type as <code>-&gt; impl MyTrait</code>. This can help simplify your type signatures quite a lot!</p>
<pre><pre class="playground"><code class="language-rust editable">use std::iter;
use std::vec::IntoIter;

// This function combines two `Vec&lt;i32&gt;` and returns an iterator over it.
// Look how complicated its return type is!
fn combine_vecs_explicit_return_type(
    v: Vec&lt;i32&gt;,
    u: Vec&lt;i32&gt;,
) -&gt; iter::Cycle&lt;iter::Chain&lt;IntoIter&lt;i32&gt;, IntoIter&lt;i32&gt;&gt;&gt; {
    v.into_iter().chain(u.into_iter()).cycle()
}

// This is the exact same function, but its return type uses `impl Trait`.
// Look how much simpler it is!
fn combine_vecs(
    v: Vec&lt;i32&gt;,
    u: Vec&lt;i32&gt;,
) -&gt; impl Iterator&lt;Item=i32&gt; {
    v.into_iter().chain(u.into_iter()).cycle()
}

fn main() {
    let v1 = vec![1, 2, 3];
    let v2 = vec![4, 5];
    let mut v3 = combine_vecs(v1, v2);
    assert_eq!(Some(1), v3.next());
    assert_eq!(Some(2), v3.next());
    assert_eq!(Some(3), v3.next());
    assert_eq!(Some(4), v3.next());
    assert_eq!(Some(5), v3.next());
    println!(&quot;all done&quot;);
}
</code></pre></pre>
<p>More importantly, some Rust types can't be written out. For example, every
closure has its own unnamed concrete type. Before <code>impl Trait</code> syntax, you had
to allocate on the heap in order to return a closure. But now you can do it all
statically, like this:</p>
<pre><pre class="playground"><code class="language-rust editable">// Returns a function that adds `y` to its input
fn make_adder_function(y: i32) -&gt; impl Fn(i32) -&gt; i32 {
    let closure = move |x: i32| { x + y };
    closure
}

fn main() {
    let plus_one = make_adder_function(1);
    assert_eq!(plus_one(2), 3);
}
</code></pre></pre>
<p>You can also use <code>impl Trait</code> to return an iterator that uses <code>map</code> or <code>filter</code>
closures! This makes using <code>map</code> and <code>filter</code> easier. Because closure types don't
have names, you can't write out an explicit return type if your function returns
iterators with closures. But with <code>impl Trait</code> you can do this easily:</p>
<pre><pre class="playground"><code class="language-rust editable">fn double_positives&lt;'a&gt;(numbers: &amp;'a Vec&lt;i32&gt;) -&gt; impl Iterator&lt;Item = i32&gt; + 'a {
    numbers
        .iter()
        .filter(|x| x &gt; &amp;&amp;0)
        .map(|x| x * 2)
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="clone"><a class="header" href="#clone">Clone</a></h1>
<p>When dealing with resources, the default behavior is to transfer them during
assignments or function calls. However, sometimes we need to make a
copy of the resource as well.</p>
<p>The <a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a> trait helps us do exactly this. Most commonly, we can
use the <code>.clone()</code> method defined by the <code>Clone</code> trait.</p>
<pre><pre class="playground"><code class="language-rust editable">// A unit struct without resources
#[derive(Debug, Clone, Copy)]
struct Unit;

// A tuple struct with resources that implements the `Clone` trait
#[derive(Clone, Debug)]
struct Pair(Box&lt;i32&gt;, Box&lt;i32&gt;);

fn main() {
    // Instantiate `Unit`
    let unit = Unit;
    // Copy `Unit`, there are no resources to move
    let copied_unit = unit;

    // Both `Unit`s can be used independently
    println!(&quot;original: {:?}&quot;, unit);
    println!(&quot;copy: {:?}&quot;, copied_unit);

    // Instantiate `Pair`
    let pair = Pair(Box::new(1), Box::new(2));
    println!(&quot;original: {:?}&quot;, pair);

    // Move `pair` into `moved_pair`, moves resources
    let moved_pair = pair;
    println!(&quot;moved: {:?}&quot;, moved_pair);

    // Error! `pair` has lost its resources
    //println!(&quot;original: {:?}&quot;, pair);
    // TODO ^ Try uncommenting this line

    // Clone `moved_pair` into `cloned_pair` (resources are included)
    let cloned_pair = moved_pair.clone();
    // Drop the original pair using std::mem::drop
    drop(moved_pair);

    // Error! `moved_pair` has been dropped
    //println!(&quot;copy: {:?}&quot;, moved_pair);
    // TODO ^ Try uncommenting this line

    // The result from .clone() can still be used!
    println!(&quot;clone: {:?}&quot;, cloned_pair);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="supertraits"><a class="header" href="#supertraits">Supertraits</a></h1>
<p>Rust doesn't have &quot;inheritance&quot;, but you can define a trait as being a superset
of another trait. For example:</p>
<pre><pre class="playground"><code class="language-rust editable">trait Person {
    fn name(&amp;self) -&gt; String;
}

// Person is a supertrait of Student.
// Implementing Student requires you to also impl Person.
trait Student: Person {
    fn university(&amp;self) -&gt; String;
}

trait Programmer {
    fn fav_language(&amp;self) -&gt; String;
}

// CompSciStudent (computer science student) is a subtrait of both Programmer 
// and Student. Implementing CompSciStudent requires you to impl both supertraits.
trait CompSciStudent: Programmer + Student {
    fn git_username(&amp;self) -&gt; String;
}

fn comp_sci_student_greeting(student: &amp;dyn CompSciStudent) -&gt; String {
    format!(
        &quot;My name is {} and I attend {}. My favorite language is {}. My Git username is {}&quot;,
        student.name(),
        student.university(),
        student.fav_language(),
        student.git_username()
    )
}

fn main() {}
</code></pre></pre>
<h3 id="see-also-58"><a class="header" href="#see-also-58">See also:</a></h3>
<p><a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#using-supertraits-to-require-one-traits-functionality-within-another-trait">The Rust Programming Language chapter on supertraits</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="disambiguating-overlapping-traits"><a class="header" href="#disambiguating-overlapping-traits">Disambiguating overlapping traits</a></h1>
<p>A type can implement many different traits. What if two traits both require the same name? For example, many traits might have a method named <code>get()</code>. They might even have different return types! </p>
<p>Good news: because each trait implementation gets its own <code>impl</code> block, it's 
clear which trait's <code>get</code> method you're implementing. </p>
<p>What about when it comes time to <em>call</em> those methods? To disambiguate between
them, we have to use Fully Qualified Syntax.</p>
<pre><pre class="playground"><code class="language-rust editable">trait UsernameWidget {
    // Get the selected username out of this widget
    fn get(&amp;self) -&gt; String;
}

trait AgeWidget {
    // Get the selected age out of this widget
    fn get(&amp;self) -&gt; u8;
}

// A form with both a UsernameWidget and an AgeWidget
struct Form {
    username: String,
    age: u8,
}

impl UsernameWidget for Form {
    fn get(&amp;self) -&gt; String {
        self.username.clone()
    }
}

impl AgeWidget for Form {
    fn get(&amp;self) -&gt; u8 {
        self.age
    }
}

fn main() {
    let form = Form{
        username: &quot;rustacean&quot;.to_owned(),
        age: 28,
    };

    // If you uncomment this line, you'll get an error saying 
    // &quot;multiple `get` found&quot;. Because, after all, there are multiple methods
    // named `get`.
    // println!(&quot;{}&quot;, form.get());

    let username = &lt;Form as UsernameWidget&gt;::get(&amp;form);
    assert_eq!(&quot;rustacean&quot;.to_owned(), username);
    let age = &lt;Form as AgeWidget&gt;::get(&amp;form);
    assert_eq!(28, age);
}
</code></pre></pre>
<h3 id="see-also-59"><a class="header" href="#see-also-59">See also:</a></h3>
<p><a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name">The Rust Programming Language chapter on Fully Qualified syntax</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="macro_rules"><a class="header" href="#macro_rules">macro_rules!</a></h1>
<p>Rust provides a powerful macro system that allows metaprogramming. As you've
seen in previous chapters, macros look like functions, except that their name
ends with a bang <code>!</code>, but instead of generating a function call, macros are
expanded into source code that gets compiled with the rest of the program.
However, unlike macros in C and other languages, Rust macros are expanded into
abstract syntax trees, rather than string preprocessing, so you don't get
unexpected precedence bugs.</p>
<p>Macros are created using the <code>macro_rules!</code> macro.</p>
<pre><pre class="playground"><code class="language-rust editable">// This is a simple macro named `say_hello`.
macro_rules! say_hello {
    // `()` indicates that the macro takes no argument.
    () =&gt; {
        // The macro will expand into the contents of this block.
        println!(&quot;Hello!&quot;);
    };
}

fn main() {
    // This call will expand into `println!(&quot;Hello&quot;);`
    say_hello!()
}
</code></pre></pre>
<p>So why are macros useful?</p>
<ol>
<li>
<p>Don't repeat yourself. There are many cases where you may need similar
functionality in multiple places but with different types. Often, writing a
macro is a useful way to avoid repeating code. (More on this later)</p>
</li>
<li>
<p>Domain-specific languages. Macros allow you to define special syntax for a
specific purpose. (More on this later)</p>
</li>
<li>
<p>Variadic interfaces. Sometimes you want to define an interface that takes a
variable number of arguments. An example is <code>println!</code> which could take any
number of arguments, depending on the format string!. (More on this later)</p>
</li>
</ol>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="syntax"><a class="header" href="#syntax">Syntax</a></h1>
<p>In following subsections, we will show how to define macros in Rust.
There are three basic ideas:</p>
<ul>
<li><a href="macros/designators.html">Patterns and Designators</a></li>
<li><a href="macros/overload.html">Overloading</a></li>
<li><a href="macros/repeat.html">Repetition</a></li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="designators"><a class="header" href="#designators">Designators</a></h1>
<p>The arguments of a macro are prefixed by a dollar sign <code>$</code> and type annotated
with a <em>designator</em>:</p>
<pre><pre class="playground"><code class="language-rust editable">macro_rules! create_function {
    // This macro takes an argument of designator `ident` and
    // creates a function named `$func_name`.
    // The `ident` designator is used for variable/function names.
    ($func_name:ident) =&gt; {
        fn $func_name() {
            // The `stringify!` macro converts an `ident` into a string.
            println!(&quot;You called {:?}()&quot;,
                     stringify!($func_name));
        }
    };
}

// Create functions named `foo` and `bar` with the above macro.
create_function!(foo);
create_function!(bar);

macro_rules! print_result {
    // This macro takes an expression of type `expr` and prints
    // it as a string along with its result.
    // The `expr` designator is used for expressions.
    ($expression:expr) =&gt; {
        // `stringify!` will convert the expression *as it is* into a string.
        println!(&quot;{:?} = {:?}&quot;,
                 stringify!($expression),
                 $expression);
    };
}

fn main() {
    foo();
    bar();

    print_result!(1u32 + 1);

    // Recall that blocks are expressions too!
    print_result!({
        let x = 1u32;

        x * x + 2 * x - 1
    });
}
</code></pre></pre>
<p>These are some of the available designators:</p>
<ul>
<li><code>block</code></li>
<li><code>expr</code> is used for expressions</li>
<li><code>ident</code> is used for variable/function names</li>
<li><code>item</code></li>
<li><code>literal</code> is used for literal constants</li>
<li><code>pat</code> (<em>pattern</em>)</li>
<li><code>path</code></li>
<li><code>stmt</code> (<em>statement</em>)</li>
<li><code>tt</code> (<em>token tree</em>)</li>
<li><code>ty</code> (<em>type</em>)</li>
<li><code>vis</code> (<em>visibility qualifier</em>)</li>
</ul>
<p>For a complete list, see the <a href="https://doc.rust-lang.org/reference/macros-by-example.html">Rust Reference</a>.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="overload"><a class="header" href="#overload">Overload</a></h1>
<p>Macros can be overloaded to accept different combinations of arguments. 
In that regard, <code>macro_rules!</code> can work similarly to a match block:</p>
<pre><pre class="playground"><code class="language-rust editable">// `test!` will compare `$left` and `$right`
// in different ways depending on how you invoke it:
macro_rules! test {
    // Arguments don't need to be separated by a comma.
    // Any template can be used!
    ($left:expr; and $right:expr) =&gt; {
        println!(&quot;{:?} and {:?} is {:?}&quot;,
                 stringify!($left),
                 stringify!($right),
                 $left &amp;&amp; $right)
    };
    // ^ each arm must end with a semicolon.
    ($left:expr; or $right:expr) =&gt; {
        println!(&quot;{:?} or {:?} is {:?}&quot;,
                 stringify!($left),
                 stringify!($right),
                 $left || $right)
    };
}

fn main() {
    test!(1i32 + 1 == 2i32; and 2i32 * 2 == 4i32);
    test!(true; or false);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="repeat"><a class="header" href="#repeat">Repeat</a></h1>
<p>Macros can use <code>+</code> in the argument list to indicate that an argument may
repeat at least once, or <code>*</code>, to indicate that the argument may repeat zero or
more times.</p>
<p>In the following example, surrounding the matcher with <code>$(...),+</code> will
match one or more expression, separated by commas.
Also note that the semicolon is optional on the last case.</p>
<pre><pre class="playground"><code class="language-rust editable">// `find_min!` will calculate the minimum of any number of arguments.
macro_rules! find_min {
    // Base case:
    ($x:expr) =&gt; ($x);
    // `$x` followed by at least one `$y,`
    ($x:expr, $($y:expr),+) =&gt; (
        // Call `find_min!` on the tail `$y`
        std::cmp::min($x, find_min!($($y),+))
    )
}

fn main() {
    println!(&quot;{}&quot;, find_min!(1u32));
    println!(&quot;{}&quot;, find_min!(1u32 + 2, 2u32));
    println!(&quot;{}&quot;, find_min!(5u32, 2u32 * 3, 4u32));
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="dry-dont-repeat-yourself"><a class="header" href="#dry-dont-repeat-yourself">DRY (Don't Repeat Yourself)</a></h1>
<p>Macros allow writing DRY code by factoring out the common parts of functions
and/or test suites. Here is an example that implements and tests the <code>+=</code>, <code>*=</code>
and <code>-=</code> operators on <code>Vec&lt;T&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust editable">use std::ops::{Add, Mul, Sub};

macro_rules! assert_equal_len {
    // The `tt` (token tree) designator is used for
    // operators and tokens.
    ($a:expr, $b:expr, $func:ident, $op:tt) =&gt; {
        assert!($a.len() == $b.len(),
                &quot;{:?}: dimension mismatch: {:?} {:?} {:?}&quot;,
                stringify!($func),
                ($a.len(),),
                stringify!($op),
                ($b.len(),));
    };
}

macro_rules! op {
    ($func:ident, $bound:ident, $op:tt, $method:ident) =&gt; {
        fn $func&lt;T: $bound&lt;T, Output=T&gt; + Copy&gt;(xs: &amp;mut Vec&lt;T&gt;, ys: &amp;Vec&lt;T&gt;) {
            assert_equal_len!(xs, ys, $func, $op);

            for (x, y) in xs.iter_mut().zip(ys.iter()) {
                *x = $bound::$method(*x, *y);
                // *x = x.$method(*y);
            }
        }
    };
}

// Implement `add_assign`, `mul_assign`, and `sub_assign` functions.
op!(add_assign, Add, +=, add);
op!(mul_assign, Mul, *=, mul);
op!(sub_assign, Sub, -=, sub);

mod test {
    use std::iter;
    macro_rules! test {
        ($func:ident, $x:expr, $y:expr, $z:expr) =&gt; {
            #[test]
            fn $func() {
                for size in 0usize..10 {
                    let mut x: Vec&lt;_&gt; = iter::repeat($x).take(size).collect();
                    let y: Vec&lt;_&gt; = iter::repeat($y).take(size).collect();
                    let z: Vec&lt;_&gt; = iter::repeat($z).take(size).collect();

                    super::$func(&amp;mut x, &amp;y);

                    assert_eq!(x, z);
                }
            }
        };
    }

    // Test `add_assign`, `mul_assign`, and `sub_assign`.
    test!(add_assign, 1u32, 2u32, 3u32);
    test!(mul_assign, 2u32, 3u32, 6u32);
    test!(sub_assign, 3u32, 2u32, 1u32);
}
</code></pre></pre>
<pre><code class="language-shell">$ rustc --test dry.rs &amp;&amp; ./dry
running 3 tests
test test::mul_assign ... ok
test test::add_assign ... ok
test test::sub_assign ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="domain-specific-languages-dsls"><a class="header" href="#domain-specific-languages-dsls">Domain Specific Languages (DSLs)</a></h1>
<p>A DSL is a mini &quot;language&quot; embedded in a Rust macro. It is completely valid
Rust because the macro system expands into normal Rust constructs, but it looks
like a small language. This allows you to define concise or intuitive syntax for
some special functionality (within bounds).</p>
<p>Suppose that I want to define a little calculator API. I would like to supply
an expression and have the output printed to console.</p>
<pre><pre class="playground"><code class="language-rust editable">macro_rules! calculate {
    (eval $e:expr) =&gt; {{
        {
            let val: usize = $e; // Force types to be integers
            println!(&quot;{} = {}&quot;, stringify!{$e}, val);
        }
    }};
}

fn main() {
    calculate! {
        eval 1 + 2 // hehehe `eval` is _not_ a Rust keyword!
    }

    calculate! {
        eval (1 + 2) * (3 / 4)
    }
}
</code></pre></pre>
<p>Output:</p>
<pre><code class="language-txt">1 + 2 = 3
(1 + 2) * (3 / 4) = 0
</code></pre>
<p>This was a very simple example, but much more complex interfaces have been
developed, such as <a href="https://crates.io/crates/lazy_static"><code>lazy_static</code></a> or
<a href="https://crates.io/crates/clap"><code>clap</code></a>.</p>
<p>Also, note the two pairs of braces in the macro. The outer ones are
part of the syntax of <code>macro_rules!</code>, in addition to <code>()</code> or <code>[]</code>.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="variadic-interfaces"><a class="header" href="#variadic-interfaces">Variadic Interfaces</a></h1>
<p>A <em>variadic</em> interface takes an arbitrary number of arguments. For example,
<code>println!</code> can take an arbitrary number of arguments, as determined by the
format string.</p>
<p>We can extend our <code>calculate!</code> macro from the previous section to be variadic:</p>
<pre><pre class="playground"><code class="language-rust editable">macro_rules! calculate {
    // The pattern for a single `eval`
    (eval $e:expr) =&gt; {{
        {
            let val: usize = $e; // Force types to be integers
            println!(&quot;{} = {}&quot;, stringify!{$e}, val);
        }
    }};

    // Decompose multiple `eval`s recursively
    (eval $e:expr, $(eval $es:expr),+) =&gt; {{
        calculate! { eval $e }
        calculate! { $(eval $es),+ }
    }};
}

fn main() {
    calculate! { // Look ma! Variadic `calculate!`!
        eval 1 + 2,
        eval 3 + 4,
        eval (2 * 3) + 1
    }
}
</code></pre></pre>
<p>Output:</p>
<pre><code class="language-txt">1 + 2 = 3
3 + 4 = 7
(2 * 3) + 1 = 7
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="error-handling"><a class="header" href="#error-handling">Error handling</a></h1>
<p>Error handling is the process of handling the possibility of failure. For
example, failing to read a file and then continuing to use that <em>bad</em> input
would clearly be problematic. Noticing and explicitly managing those errors
saves the rest of the program from various pitfalls.</p>
<p>There are various ways to deal with errors in Rust, which are described in the
following subchapters. They all have more or less subtle differences and different
use cases. As a rule of thumb:</p>
<p>An explicit <code>panic</code> is mainly useful for tests and dealing with unrecoverable errors.
For prototyping it can be useful, for example when dealing with functions that
haven't been implemented yet, but in those cases the more descriptive <code>unimplemented</code>
is better. In tests <code>panic</code> is a reasonable way to explicitly fail.</p>
<p>The <code>Option</code> type is for when a value is optional or when the lack of a value is
not an error condition. For example the parent of a directory - <code>/</code> and <code>C:</code> don't
have one. When dealing with <code>Option</code>s, <code>unwrap</code> is fine for prototyping and cases
where it's absolutely certain that there is guaranteed to be a value. However <code>expect</code>
is more useful since it lets you specify an error message in case something goes
wrong anyway.</p>
<p>When there is a chance that things do go wrong and the caller has to deal with the
problem, use <code>Result</code>. You can <code>unwrap</code> and <code>expect</code> them as well (please don't
do that unless it's a test or quick prototype).</p>
<p>For a more rigorous discussion of error handling, refer to the error
handling section in the <a href="https://doc.rust-lang.org/book/ch09-00-error-handling.html">official book</a>.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="panic"><a class="header" href="#panic"><code>panic</code></a></h1>
<p>The simplest error handling mechanism we will see is <code>panic</code>. It prints an
error message, starts unwinding the stack, and usually exits the program.
Here, we explicitly call <code>panic</code> on our error condition:</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">fn drink(beverage: &amp;str) {
    // You shouldn't drink too much sugary beverages.
    if beverage == &quot;lemonade&quot; { panic!(&quot;AAAaaaaa!!!!&quot;); }

    println!(&quot;Some refreshing {} is all I need.&quot;, beverage);
}

fn main() {
    drink(&quot;water&quot;);
    drink(&quot;lemonade&quot;);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="option--unwrap"><a class="header" href="#option--unwrap"><code>Option</code> &amp; <code>unwrap</code></a></h1>
<p>In the last example, we showed that we can induce program failure at will.
We told our program to <code>panic</code> if we drink a sugary lemonade.
But what if we expect <em>some</em> drink but don't receive one?
That case would be just as bad, so it needs to be handled!</p>
<p>We <em>could</em> test this against the null string (<code>&quot;&quot;</code>) as we do with a lemonade.
Since we're using Rust, let's instead have the compiler point out cases
where there's no drink.</p>
<p>An <code>enum</code> called <code>Option&lt;T&gt;</code> in the <code>std</code> library is used when absence is a
possibility. It manifests itself as one of two &quot;options&quot;:</p>
<ul>
<li><code>Some(T)</code>: An element of type <code>T</code> was found</li>
<li><code>None</code>: No element was found</li>
</ul>
<p>These cases can either be explicitly handled via <code>match</code> or implicitly with
<code>unwrap</code>. Implicit handling will either return the inner element or <code>panic</code>.</p>
<p>Note that it's possible to manually customize <code>panic</code> with <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.expect">expect</a>,
but <code>unwrap</code> otherwise leaves us with a less meaningful output than explicit
handling. In the following example, explicit handling yields a more
controlled result while retaining the option to <code>panic</code> if desired.</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">// The adult has seen it all, and can handle any drink well.
// All drinks are handled explicitly using `match`.
fn give_adult(drink: Option&lt;&amp;str&gt;) {
    // Specify a course of action for each case.
    match drink {
        Some(&quot;lemonade&quot;) =&gt; println!(&quot;Yuck! Too sugary.&quot;),
        Some(inner)   =&gt; println!(&quot;{}? How nice.&quot;, inner),
        None          =&gt; println!(&quot;No drink? Oh well.&quot;),
    }
}

// Others will `panic` before drinking sugary drinks.
// All drinks are handled implicitly using `unwrap`.
fn drink(drink: Option&lt;&amp;str&gt;) {
    // `unwrap` returns a `panic` when it receives a `None`.
    let inside = drink.unwrap();
    if inside == &quot;lemonade&quot; { panic!(&quot;AAAaaaaa!!!!&quot;); }

    println!(&quot;I love {}s!!!!!&quot;, inside);
}

fn main() {
    let water  = Some(&quot;water&quot;);
    let lemonade = Some(&quot;lemonade&quot;);
    let void  = None;

    give_adult(water);
    give_adult(lemonade);
    give_adult(void);

    let coffee = Some(&quot;coffee&quot;);
    let nothing = None;

    drink(coffee);
    drink(nothing);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="unpacking-options-with-"><a class="header" href="#unpacking-options-with-">Unpacking options with <code>?</code></a></h1>
<p>You can unpack <code>Option</code>s by using <code>match</code> statements, but it's often easier to
use the <code>?</code> operator. If <code>x</code> is an <code>Option</code>, then evaluating <code>x?</code> will return
the underlying value if <code>x</code> is <code>Some</code>, otherwise it will terminate whatever
function is being executed and return <code>None</code>.</p>
<pre><pre class="playground"><code class="language-rust editable">fn next_birthday(current_age: Option&lt;u8&gt;) -&gt; Option&lt;String&gt; {
	// If `current_age` is `None`, this returns `None`.
	// If `current_age` is `Some`, the inner `u8` gets assigned to `next_age`
    let next_age: u8 = current_age?;
    Some(format!(&quot;Next year I will be {}&quot;, next_age))
}
</code></pre></pre>
<p>You can chain many <code>?</code>s together to make your code much more readable.</p>
<pre><pre class="playground"><code class="language-rust editable">struct Person {
    job: Option&lt;Job&gt;,
}

#[derive(Clone, Copy)]
struct Job {
    phone_number: Option&lt;PhoneNumber&gt;,
}

#[derive(Clone, Copy)]
struct PhoneNumber {
    area_code: Option&lt;u8&gt;,
    number: u32,
}

impl Person {

    // Gets the area code of the phone number of the person's job, if it exists.
    fn work_phone_area_code(&amp;self) -&gt; Option&lt;u8&gt; {
        // This would need many nested `match` statements without the `?` operator.
        // It would take a lot more code - try writing it yourself and see which
        // is easier.
        self.job?.phone_number?.area_code
    }
}

fn main() {
    let p = Person {
        job: Some(Job {
            phone_number: Some(PhoneNumber {
                area_code: Some(61),
                number: 439222222,
            }),
        }),
    };

    assert_eq!(p.work_phone_area_code(), Some(61));
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="combinators-map"><a class="header" href="#combinators-map">Combinators: <code>map</code></a></h1>
<p><code>match</code> is a valid method for handling <code>Option</code>s. However, you may 
eventually find heavy usage tedious, especially with operations only valid 
with an input. In these cases, <a href="https://doc.rust-lang.org/reference/glossary.html#combinator">combinators</a> can be used to 
manage control flow in a modular fashion.</p>
<p><code>Option</code> has a built in method called <code>map()</code>, a combinator for the simple 
mapping of <code>Some -&gt; Some</code> and <code>None -&gt; None</code>. Multiple <code>map()</code> calls can be 
chained together for even more flexibility.</p>
<p>In the following example, <code>process()</code> replaces all functions previous
to it while staying compact.</p>
<pre><pre class="playground"><code class="language-rust editable">#![allow(dead_code)]

#[derive(Debug)] enum Food { Apple, Carrot, Potato }

#[derive(Debug)] struct Peeled(Food);
#[derive(Debug)] struct Chopped(Food);
#[derive(Debug)] struct Cooked(Food);

// Peeling food. If there isn't any, then return `None`.
// Otherwise, return the peeled food.
fn peel(food: Option&lt;Food&gt;) -&gt; Option&lt;Peeled&gt; {
    match food {
        Some(food) =&gt; Some(Peeled(food)),
        None       =&gt; None,
    }
}

// Chopping food. If there isn't any, then return `None`.
// Otherwise, return the chopped food.
fn chop(peeled: Option&lt;Peeled&gt;) -&gt; Option&lt;Chopped&gt; {
    match peeled {
        Some(Peeled(food)) =&gt; Some(Chopped(food)),
        None               =&gt; None,
    }
}

// Cooking food. Here, we showcase `map()` instead of `match` for case handling.
fn cook(chopped: Option&lt;Chopped&gt;) -&gt; Option&lt;Cooked&gt; {
    chopped.map(|Chopped(food)| Cooked(food))
}

// A function to peel, chop, and cook food all in sequence.
// We chain multiple uses of `map()` to simplify the code.
fn process(food: Option&lt;Food&gt;) -&gt; Option&lt;Cooked&gt; {
    food.map(|f| Peeled(f))
        .map(|Peeled(f)| Chopped(f))
        .map(|Chopped(f)| Cooked(f))
}

// Check whether there's food or not before trying to eat it!
fn eat(food: Option&lt;Cooked&gt;) {
    match food {
        Some(food) =&gt; println!(&quot;Mmm. I love {:?}&quot;, food),
        None       =&gt; println!(&quot;Oh no! It wasn't edible.&quot;),
    }
}

fn main() {
    let apple = Some(Food::Apple);
    let carrot = Some(Food::Carrot);
    let potato = None;

    let cooked_apple = cook(chop(peel(apple)));
    let cooked_carrot = cook(chop(peel(carrot)));
    // Let's try the simpler looking `process()` now.
    let cooked_potato = process(potato);

    eat(cooked_apple);
    eat(cooked_carrot);
    eat(cooked_potato);
}
</code></pre></pre>
<h3 id="see-also-60"><a class="header" href="#see-also-60">See also:</a></h3>
<p><a href="error/option_unwrap/../../fn/closures.html">closures</a>, <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a>, <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.map"><code>Option::map()</code></a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="combinators-and_then"><a class="header" href="#combinators-and_then">Combinators: <code>and_then</code></a></h1>
<p><code>map()</code> was described as a chainable way to simplify <code>match</code> statements. 
However, using <code>map()</code> on a function that returns an <code>Option&lt;T&gt;</code> results 
in the nested <code>Option&lt;Option&lt;T&gt;&gt;</code>. Chaining multiple calls together can 
then become confusing. That's where another combinator called <code>and_then()</code>, 
known in some languages as flatmap, comes in.</p>
<p><code>and_then()</code> calls its function input with the wrapped value and returns the result. If the <code>Option</code> is <code>None</code>, then it returns <code>None</code> instead.</p>
<p>In the following example, <code>cookable_v2()</code> results in an <code>Option&lt;Food&gt;</code>. 
Using <code>map()</code> instead of <code>and_then()</code> would have given an 
<code>Option&lt;Option&lt;Food&gt;&gt;</code>, which is an invalid type for <code>eat()</code>.</p>
<pre><pre class="playground"><code class="language-rust editable">#![allow(dead_code)]

#[derive(Debug)] enum Food { CordonBleu, Steak, Sushi }
#[derive(Debug)] enum Day { Monday, Tuesday, Wednesday }

// We don't have the ingredients to make Sushi.
fn have_ingredients(food: Food) -&gt; Option&lt;Food&gt; {
    match food {
        Food::Sushi =&gt; None,
        _           =&gt; Some(food),
    }
}

// We have the recipe for everything except Cordon Bleu.
fn have_recipe(food: Food) -&gt; Option&lt;Food&gt; {
    match food {
        Food::CordonBleu =&gt; None,
        _                =&gt; Some(food),
    }
}

// To make a dish, we need both the recipe and the ingredients.
// We can represent the logic with a chain of `match`es:
fn cookable_v1(food: Food) -&gt; Option&lt;Food&gt; {
    match have_recipe(food) {
        None       =&gt; None,
        Some(food) =&gt; match have_ingredients(food) {
            None       =&gt; None,
            Some(food) =&gt; Some(food),
        },
    }
}

// This can conveniently be rewritten more compactly with `and_then()`:
fn cookable_v2(food: Food) -&gt; Option&lt;Food&gt; {
    have_recipe(food).and_then(have_ingredients)
}

fn eat(food: Food, day: Day) {
    match cookable_v2(food) {
        Some(food) =&gt; println!(&quot;Yay! On {:?} we get to eat {:?}.&quot;, day, food),
        None       =&gt; println!(&quot;Oh no. We don't get to eat on {:?}?&quot;, day),
    }
}

fn main() {
    let (cordon_bleu, steak, sushi) = (Food::CordonBleu, Food::Steak, Food::Sushi);

    eat(cordon_bleu, Day::Monday);
    eat(steak, Day::Tuesday);
    eat(sushi, Day::Wednesday);
}
</code></pre></pre>
<h3 id="see-also-61"><a class="header" href="#see-also-61">See also:</a></h3>
<p><a href="error/option_unwrap/../../fn/closures.html">closures</a>, <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a>, and <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.and_then"><code>Option::and_then()</code></a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="result"><a class="header" href="#result"><code>Result</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> is a richer version of the <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a> type that
describes possible <em>error</em> instead of possible <em>absence</em>.</p>
<p>That is, <code>Result&lt;T, E&gt;</code> could have one of two outcomes:</p>
<ul>
<li><code>Ok(T)</code>: An element <code>T</code> was found</li>
<li><code>Err(E)</code>: An error was found with element <code>E</code></li>
</ul>
<p>By convention, the expected outcome is <code>Ok</code> while the unexpected outcome is <code>Err</code>.</p>
<p>Like <code>Option</code>, <code>Result</code> has many methods associated with it. <code>unwrap()</code>, for
example, either yields the element <code>T</code> or <code>panic</code>s. For case handling,
there are many combinators between <code>Result</code> and <code>Option</code> that overlap.</p>
<p>In working with Rust, you will likely encounter methods that return the
<code>Result</code> type, such as the <a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse"><code>parse()</code></a> method. It might not always
be possible to parse a string into the other type, so <code>parse()</code> returns a
<code>Result</code> indicating possible failure.</p>
<p>Let's see what happens when we successfully and unsuccessfully <code>parse()</code> a string:</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; i32 {
    // Let's try using `unwrap()` to get the number out. Will it bite us?
    let first_number = first_number_str.parse::&lt;i32&gt;().unwrap();
    let second_number = second_number_str.parse::&lt;i32&gt;().unwrap();
    first_number * second_number
}

fn main() {
    let twenty = multiply(&quot;10&quot;, &quot;2&quot;);
    println!(&quot;double is {}&quot;, twenty);

    let tt = multiply(&quot;t&quot;, &quot;2&quot;);
    println!(&quot;double is {}&quot;, tt);
}
</code></pre></pre>
<p>In the unsuccessful case, <code>parse()</code> leaves us with an error for <code>unwrap()</code>
to <code>panic</code> on. Additionally, the <code>panic</code> exits our program and provides an
unpleasant error message.</p>
<p>To improve the quality of our error message, we should be more specific
about the return type and consider explicitly handling the error.</p>
<h2 id="using-result-in-main"><a class="header" href="#using-result-in-main">Using <code>Result</code> in <code>main</code></a></h2>
<p>The <code>Result</code> type can also be the return type of the <code>main</code> function if
specified explicitly. Typically the <code>main</code> function will be of the form:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello World!&quot;);
}
</code></pre></pre>
<p>However <code>main</code> is also able to have a return type of <code>Result</code>. If an error
occurs within the <code>main</code> function it will return an error code and print a debug
representation of the error (using the <a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a> trait). The following example
shows such a scenario and touches on aspects covered in <a href="error/result/early_returns.html">the following section</a>.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::num::ParseIntError;

fn main() -&gt; Result&lt;(), ParseIntError&gt; {
    let number_str = &quot;10&quot;;
    let number = match number_str.parse::&lt;i32&gt;() {
        Ok(number)  =&gt; number,
        Err(e) =&gt; return Err(e),
    };
    println!(&quot;{}&quot;, number);
    Ok(())
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="map-for-result"><a class="header" href="#map-for-result"><code>map</code> for <code>Result</code></a></h1>
<p>Panicking in the previous example's <code>multiply</code> does not make for robust code.
Generally, we want to return the error to the caller so it can decide what is
the right way to respond to errors.</p>
<p>We first need to know what kind of error type we are dealing with. To determine
the <code>Err</code> type, we look to <a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse"><code>parse()</code></a>, which is implemented with the
<a href="https://doc.rust-lang.org/std/str/trait.FromStr.html"><code>FromStr</code></a> trait for <a href="https://doc.rust-lang.org/std/primitive.i32.html"><code>i32</code></a>. As a result, the <code>Err</code> type is
specified as <a href="https://doc.rust-lang.org/std/num/struct.ParseIntError.html"><code>ParseIntError</code></a>.</p>
<p>In the example below, the straightforward <code>match</code> statement leads to code
that is overall more cumbersome.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::num::ParseIntError;

// With the return type rewritten, we use pattern matching without `unwrap()`.
fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    match first_number_str.parse::&lt;i32&gt;() {
        Ok(first_number)  =&gt; {
            match second_number_str.parse::&lt;i32&gt;() {
                Ok(second_number)  =&gt; {
                    Ok(first_number * second_number)
                },
                Err(e) =&gt; Err(e),
            }
        },
        Err(e) =&gt; Err(e),
    }
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    // This still presents a reasonable answer.
    let twenty = multiply(&quot;10&quot;, &quot;2&quot;);
    print(twenty);

    // The following now provides a much more helpful error message.
    let tt = multiply(&quot;t&quot;, &quot;2&quot;);
    print(tt);
}
</code></pre></pre>
<p>Luckily, <code>Option</code>'s <code>map</code>, <code>and_then</code>, and many other combinators are also
implemented for <code>Result</code>. <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> contains a complete listing.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::num::ParseIntError;

// As with `Option`, we can use combinators such as `map()`.
// This function is otherwise identical to the one above and reads:
// Modify n if the value is valid, otherwise pass on the error.
fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    first_number_str.parse::&lt;i32&gt;().and_then(|first_number| {
        second_number_str.parse::&lt;i32&gt;().map(|second_number| first_number * second_number)
    })
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    // This still presents a reasonable answer.
    let twenty = multiply(&quot;10&quot;, &quot;2&quot;);
    print(twenty);

    // The following now provides a much more helpful error message.
    let tt = multiply(&quot;t&quot;, &quot;2&quot;);
    print(tt);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="aliases-for-result"><a class="header" href="#aliases-for-result">aliases for <code>Result</code></a></h1>
<p>How about when we want to reuse a specific <code>Result</code> type many times?
Recall that Rust allows us to create <a href="error/result/../../types/alias.html">aliases</a>. Conveniently,
we can define one for the specific <code>Result</code> in question.</p>
<p>At a module level, creating aliases can be particularly helpful. Errors
found in a specific module often have the same <code>Err</code> type, so a single alias
can succinctly define <em>all</em> associated <code>Results</code>. This is so useful that the
<code>std</code> library even supplies one: <a href="https://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code></a>!</p>
<p>Here's a quick example to show off the syntax:</p>
<pre><pre class="playground"><code class="language-rust editable">use std::num::ParseIntError;

// Define a generic alias for a `Result` with the error type `ParseIntError`.
type AliasedResult&lt;T&gt; = Result&lt;T, ParseIntError&gt;;

// Use the above alias to refer to our specific `Result` type.
fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; AliasedResult&lt;i32&gt; {
    first_number_str.parse::&lt;i32&gt;().and_then(|first_number| {
        second_number_str.parse::&lt;i32&gt;().map(|second_number| first_number * second_number)
    })
}

// Here, the alias again allows us to save some space.
fn print(result: AliasedResult&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    print(multiply(&quot;10&quot;, &quot;2&quot;));
    print(multiply(&quot;t&quot;, &quot;2&quot;));
}
</code></pre></pre>
<h3 id="see-also-62"><a class="header" href="#see-also-62">See also:</a></h3>
<p><a href="https://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code></a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="early-returns"><a class="header" href="#early-returns">Early returns</a></h1>
<p>In the previous example, we explicitly handled the errors using combinators.
Another way to deal with this case analysis is to use a combination of
<code>match</code> statements and <em>early returns</em>.</p>
<p>That is, we can simply stop executing the function and return the error if
one occurs. For some, this form of code can be easier to both read and
write. Consider this version of the previous example, rewritten using early returns:</p>
<pre><pre class="playground"><code class="language-rust editable">use std::num::ParseIntError;

fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let first_number = match first_number_str.parse::&lt;i32&gt;() {
        Ok(first_number)  =&gt; first_number,
        Err(e) =&gt; return Err(e),
    };

    let second_number = match second_number_str.parse::&lt;i32&gt;() {
        Ok(second_number)  =&gt; second_number,
        Err(e) =&gt; return Err(e),
    };

    Ok(first_number * second_number)
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    print(multiply(&quot;10&quot;, &quot;2&quot;));
    print(multiply(&quot;t&quot;, &quot;2&quot;));
}
</code></pre></pre>
<p>At this point, we've learned to explicitly handle errors using combinators
and early returns. While we generally want to avoid panicking, explicitly
handling all of our errors is cumbersome.</p>
<p>In the next section, we'll introduce <code>?</code> for the cases where we simply
need to <code>unwrap</code> without possibly inducing <code>panic</code>.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="introducing-"><a class="header" href="#introducing-">Introducing <code>?</code></a></h1>
<p>Sometimes we just want the simplicity of <code>unwrap</code> without the possibility of
a <code>panic</code>. Until now, <code>unwrap</code> has forced us to nest deeper and deeper when
what we really wanted was to get the variable <em>out</em>. This is exactly the purpose of <code>?</code>.</p>
<p>Upon finding an <code>Err</code>, there are two valid actions to take:</p>
<ol>
<li><code>panic!</code> which we already decided to try to avoid if possible</li>
<li><code>return</code> because an <code>Err</code> means it cannot be handled</li>
</ol>
<p><code>?</code> is <em>almost</em><sup class="footnote-reference"><a href="#†">1</a></sup> exactly equivalent to an <code>unwrap</code> which <code>return</code>s
instead of <code>panic</code>king on <code>Err</code>s. Let's see how we can simplify the earlier
example that used combinators:</p>
<pre><pre class="playground"><code class="language-rust editable">use std::num::ParseIntError;

fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let first_number = first_number_str.parse::&lt;i32&gt;()?;
    let second_number = second_number_str.parse::&lt;i32&gt;()?;

    Ok(first_number * second_number)
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    print(multiply(&quot;10&quot;, &quot;2&quot;));
    print(multiply(&quot;t&quot;, &quot;2&quot;));
}
</code></pre></pre>
<h2 id="the-try-macro"><a class="header" href="#the-try-macro">The <code>try!</code> macro</a></h2>
<p>Before there was <code>?</code>, the same functionality was achieved with the <code>try!</code> macro.
The <code>?</code> operator is now recommended, but you may still find <code>try!</code> when looking
at older code. The same <code>multiply</code> function from the previous example
would look like this using <code>try!</code>:</p>
<pre><pre class="playground"><code class="language-rust editable">// To compile and run this example without errors, while using Cargo, change the value 
// of the `edition` field, in the `[package]` section of the `Cargo.toml` file, to &quot;2015&quot;.

use std::num::ParseIntError;

fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let first_number = try!(first_number_str.parse::&lt;i32&gt;());
    let second_number = try!(second_number_str.parse::&lt;i32&gt;());

    Ok(first_number * second_number)
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    print(multiply(&quot;10&quot;, &quot;2&quot;));
    print(multiply(&quot;t&quot;, &quot;2&quot;));
}
</code></pre></pre>
<div class="footnote-definition" id="†"><sup class="footnote-definition-label">1</sup>
<p>See <a href="error/result/../multiple_error_types/reenter_question_mark.html">re-enter ?</a> for more details.</p>
</div>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="multiple-error-types"><a class="header" href="#multiple-error-types">Multiple error types</a></h1>
<p>The previous examples have always been very convenient; <code>Result</code>s interact
with other <code>Result</code>s and <code>Option</code>s interact with other <code>Option</code>s.</p>
<p>Sometimes an <code>Option</code> needs to interact with a <code>Result</code>, or a
<code>Result&lt;T, Error1&gt;</code> needs to interact with a <code>Result&lt;T, Error2&gt;</code>. In those
cases, we want to manage our different error types in a way that makes them
composable and easy to interact with.</p>
<p>In the following code, two instances of <code>unwrap</code> generate different error
types. <code>Vec::first</code> returns an <code>Option</code>, while <code>parse::&lt;i32&gt;</code> returns a
<code>Result&lt;i32, ParseIntError&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; i32 {
    let first = vec.first().unwrap(); // Generate error 1
    2 * first.parse::&lt;i32&gt;().unwrap() // Generate error 2
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    println!(&quot;The first doubled is {}&quot;, double_first(numbers));

    println!(&quot;The first doubled is {}&quot;, double_first(empty));
    // Error 1: the input vector is empty

    println!(&quot;The first doubled is {}&quot;, double_first(strings));
    // Error 2: the element doesn't parse to a number
}
</code></pre></pre>
<p>Over the next sections, we'll see several strategies for handling these kind of problems.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="pulling-results-out-of-options"><a class="header" href="#pulling-results-out-of-options">Pulling <code>Result</code>s out of <code>Option</code>s</a></h1>
<p>The most basic way of handling mixed error types is to just embed them in each
other.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::num::ParseIntError;

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Option&lt;Result&lt;i32, ParseIntError&gt;&gt; {
    vec.first().map(|first| {
        first.parse::&lt;i32&gt;().map(|n| 2 * n)
    })
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    println!(&quot;The first doubled is {:?}&quot;, double_first(numbers));

    println!(&quot;The first doubled is {:?}&quot;, double_first(empty));
    // Error 1: the input vector is empty

    println!(&quot;The first doubled is {:?}&quot;, double_first(strings));
    // Error 2: the element doesn't parse to a number
}
</code></pre></pre>
<p>There are times when we'll want to stop processing on errors (like with
<a href="error/multiple_error_types/../result/enter_question_mark.html"><code>?</code></a>) but keep going when the <code>Option</code> is <code>None</code>. A
couple of combinators come in handy to swap the <code>Result</code> and <code>Option</code>.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::num::ParseIntError;

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;Option&lt;i32&gt;, ParseIntError&gt; {
    let opt = vec.first().map(|first| {
        first.parse::&lt;i32&gt;().map(|n| 2 * n)
    });

    opt.map_or(Ok(None), |r| r.map(Some))
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    println!(&quot;The first doubled is {:?}&quot;, double_first(numbers));
    println!(&quot;The first doubled is {:?}&quot;, double_first(empty));
    println!(&quot;The first doubled is {:?}&quot;, double_first(strings));
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="defining-an-error-type"><a class="header" href="#defining-an-error-type">Defining an error type</a></h1>
<p>Sometimes it simplifies the code to mask all of the different errors with a
single type of error.  We'll show this with a custom error.</p>
<p>Rust allows us to define our own error types. In general, a &quot;good&quot; error type:</p>
<ul>
<li>Represents different errors with the same type</li>
<li>Presents nice error messages to the user</li>
<li>Is easy to compare with other types
<ul>
<li>Good: <code>Err(EmptyVec)</code></li>
<li>Bad: <code>Err(&quot;Please use a vector with at least one element&quot;.to_owned())</code></li>
</ul>
</li>
<li>Can hold information about the error
<ul>
<li>Good: <code>Err(BadChar(c, position))</code></li>
<li>Bad: <code>Err(&quot;+ cannot be used here&quot;.to_owned())</code></li>
</ul>
</li>
<li>Composes well with other errors</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">use std::fmt;

type Result&lt;T&gt; = std::result::Result&lt;T, DoubleError&gt;;

// Define our error types. These may be customized for our error handling cases.
// Now we will be able to write our own errors, defer to an underlying error
// implementation, or do something in between.
#[derive(Debug, Clone)]
struct DoubleError;

// Generation of an error is completely separate from how it is displayed.
// There's no need to be concerned about cluttering complex logic with the display style.
//
// Note that we don't store any extra info about the errors. This means we can't state
// which string failed to parse without modifying our types to carry that information.
impl fmt::Display for DoubleError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;invalid first item to double&quot;)
    }
}

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    vec.first()
        // Change the error to our new type.
        .ok_or(DoubleError)
        .and_then(|s| {
            s.parse::&lt;i32&gt;()
                // Update to the new error type here also.
                .map_err(|_| DoubleError)
                .map(|i| 2 * i)
        })
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n) =&gt; println!(&quot;The first doubled is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="boxing-errors"><a class="header" href="#boxing-errors"><code>Box</code>ing errors</a></h1>
<p>A way to write simple code while preserving the original errors is to <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html"><code>Box</code></a>
them.  The drawback is that the underlying error type is only known at runtime and not
<a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html#trait-objects-perform-dynamic-dispatch">statically determined</a>.</p>
<p>The stdlib helps in boxing our errors by having <code>Box</code> implement conversion from
any type that implements the <code>Error</code> trait into the trait object <code>Box&lt;Error&gt;</code>,
via <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a>.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::error;
use std::fmt;

// Change the alias to `Box&lt;error::Error&gt;`.
type Result&lt;T&gt; = std::result::Result&lt;T, Box&lt;dyn error::Error&gt;&gt;;

#[derive(Debug, Clone)]
struct EmptyVec;

impl fmt::Display for EmptyVec {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;invalid first item to double&quot;)
    }
}

impl error::Error for EmptyVec {}

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    vec.first()
        .ok_or_else(|| EmptyVec.into()) // Converts to Box
        .and_then(|s| {
            s.parse::&lt;i32&gt;()
                .map_err(|e| e.into()) // Converts to Box
                .map(|i| 2 * i)
        })
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n) =&gt; println!(&quot;The first doubled is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}
</code></pre></pre>
<h3 id="see-also-63"><a class="header" href="#see-also-63">See also:</a></h3>
<p><a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html#trait-objects-perform-dynamic-dispatch">Dynamic dispatch</a> and <a href="https://doc.rust-lang.org/std/error/trait.Error.html"><code>Error</code> trait</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="other-uses-of-"><a class="header" href="#other-uses-of-">Other uses of <code>?</code></a></h1>
<p>Notice in the previous example that our immediate reaction to calling
<code>parse</code> is to <code>map</code> the error from a library error into a boxed
error:</p>
<pre><code class="language-rust ignore">.and_then(|s| s.parse::&lt;i32&gt;()
    .map_err(|e| e.into())
</code></pre>
<p>Since this is a simple and common operation, it would be convenient if it
could be elided. Alas, because <code>and_then</code> is not sufficiently flexible, it
cannot. However, we can instead use <code>?</code>.</p>
<p><code>?</code> was previously explained as either <code>unwrap</code> or <code>return Err(err)</code>.
This is only mostly true. It actually means <code>unwrap</code> or
<code>return Err(From::from(err))</code>. Since <code>From::from</code> is a conversion utility
between different types, this means that if you <code>?</code> where the error is
convertible to the return type, it will convert automatically.</p>
<p>Here, we rewrite the previous example using <code>?</code>. As a result, the
<code>map_err</code> will go away when <code>From::from</code> is implemented for our error type:</p>
<pre><pre class="playground"><code class="language-rust editable">use std::error;
use std::fmt;

// Change the alias to `Box&lt;dyn error::Error&gt;`.
type Result&lt;T&gt; = std::result::Result&lt;T, Box&lt;dyn error::Error&gt;&gt;;

#[derive(Debug)]
struct EmptyVec;

impl fmt::Display for EmptyVec {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;invalid first item to double&quot;)
    }
}

impl error::Error for EmptyVec {}

// The same structure as before but rather than chain all `Results`
// and `Options` along, we `?` to get the inner value out immediately.
fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    let first = vec.first().ok_or(EmptyVec)?;
    let parsed = first.parse::&lt;i32&gt;()?;
    Ok(2 * parsed)
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;The first doubled is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}
</code></pre></pre>
<p>This is actually fairly clean now. Compared with the original <code>panic</code>, it
is very similar to replacing the <code>unwrap</code> calls with <code>?</code> except that the
return types are <code>Result</code>. As a result, they must be destructured at the
top level.</p>
<h3 id="see-also-64"><a class="header" href="#see-also-64">See also:</a></h3>
<p><a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From::from</code></a> and <a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#the-question-mark-operator"><code>?</code></a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="wrapping-errors"><a class="header" href="#wrapping-errors">Wrapping errors</a></h1>
<p>An alternative to boxing errors is to wrap them in your own error type.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::error;
use std::error::Error as _;
use std::num::ParseIntError;
use std::fmt;

type Result&lt;T&gt; = std::result::Result&lt;T, DoubleError&gt;;

#[derive(Debug)]
enum DoubleError {
    EmptyVec,
    // We will defer to the parse error implementation for their error.
    // Supplying extra info requires adding more data to the type.
    Parse(ParseIntError),
}

impl fmt::Display for DoubleError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        match *self {
            DoubleError::EmptyVec =&gt;
                write!(f, &quot;please use a vector with at least one element&quot;),
            // The wrapped error contains additional information and is available
            // via the source() method.
            DoubleError::Parse(..) =&gt;
                write!(f, &quot;the provided string could not be parsed as int&quot;),
        }
    }
}

impl error::Error for DoubleError {
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn error::Error + 'static)&gt; {
        match *self {
            DoubleError::EmptyVec =&gt; None,
            // The cause is the underlying implementation error type. Is implicitly
            // cast to the trait object `&amp;error::Error`. This works because the
            // underlying type already implements the `Error` trait.
            DoubleError::Parse(ref e) =&gt; Some(e),
        }
    }
}

// Implement the conversion from `ParseIntError` to `DoubleError`.
// This will be automatically called by `?` if a `ParseIntError`
// needs to be converted into a `DoubleError`.
impl From&lt;ParseIntError&gt; for DoubleError {
    fn from(err: ParseIntError) -&gt; DoubleError {
        DoubleError::Parse(err)
    }
}

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    let first = vec.first().ok_or(DoubleError::EmptyVec)?;
    // Here we implicitly use the `ParseIntError` implementation of `From` (which
    // we defined above) in order to create a `DoubleError`.
    let parsed = first.parse::&lt;i32&gt;()?;

    Ok(2 * parsed)
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;The first doubled is {}&quot;, n),
        Err(e) =&gt; {
            println!(&quot;Error: {}&quot;, e);
            if let Some(source) = e.source() {
                println!(&quot;  Caused by: {}&quot;, source);
            }
        },
    }
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}
</code></pre></pre>
<p>This adds a bit more boilerplate for handling errors and might not be needed in
all applications. There are some libraries that can take care of the boilerplate
for you.</p>
<h3 id="see-also-65"><a class="header" href="#see-also-65">See also:</a></h3>
<p><a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From::from</code></a> and <a href="error/multiple_error_types/../../custom_types/enum.html"><code>Enums</code></a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="iterating-over-results"><a class="header" href="#iterating-over-results">Iterating over <code>Result</code>s</a></h1>
<p>An <code>Iter::map</code> operation might fail, for example:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let numbers: Vec&lt;_&gt; = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .collect();
    println!(&quot;Results: {:?}&quot;, numbers);
}
</code></pre></pre>
<p>Let's step through strategies for handling this.</p>
<h2 id="ignore-the-failed-items-with-filter_map"><a class="header" href="#ignore-the-failed-items-with-filter_map">Ignore the failed items with <code>filter_map()</code></a></h2>
<p><code>filter_map</code> calls a function and filters out the results that are <code>None</code>.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let numbers: Vec&lt;_&gt; = strings
        .into_iter()
        .filter_map(|s| s.parse::&lt;i32&gt;().ok())
        .collect();
    println!(&quot;Results: {:?}&quot;, numbers);
}
</code></pre></pre>
<h2 id="fail-the-entire-operation-with-collect"><a class="header" href="#fail-the-entire-operation-with-collect">Fail the entire operation with <code>collect()</code></a></h2>
<p><code>Result</code> implements <code>FromIter</code> so that a vector of results (<code>Vec&lt;Result&lt;T, E&gt;&gt;</code>)
can be turned into a result with a vector (<code>Result&lt;Vec&lt;T&gt;, E&gt;</code>). Once an
<code>Result::Err</code> is found, the iteration will terminate.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let numbers: Result&lt;Vec&lt;_&gt;, _&gt; = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .collect();
    println!(&quot;Results: {:?}&quot;, numbers);
}
</code></pre></pre>
<p>This same technique can be used with <code>Option</code>.</p>
<h2 id="collect-all-valid-values-and-failures-with-partition"><a class="header" href="#collect-all-valid-values-and-failures-with-partition">Collect all valid values and failures with <code>partition()</code></a></h2>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let (numbers, errors): (Vec&lt;_&gt;, Vec&lt;_&gt;) = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .partition(Result::is_ok);
    println!(&quot;Numbers: {:?}&quot;, numbers);
    println!(&quot;Errors: {:?}&quot;, errors);
}
</code></pre></pre>
<p>When you look at the results, you'll note that everything is still wrapped in
<code>Result</code>.  A little more boilerplate is needed for this.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let (numbers, errors): (Vec&lt;_&gt;, Vec&lt;_&gt;) = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .partition(Result::is_ok);
    let numbers: Vec&lt;_&gt; = numbers.into_iter().map(Result::unwrap).collect();
    let errors: Vec&lt;_&gt; = errors.into_iter().map(Result::unwrap_err).collect();
    println!(&quot;Numbers: {:?}&quot;, numbers);
    println!(&quot;Errors: {:?}&quot;, errors);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="std-library-types"><a class="header" href="#std-library-types">Std library types</a></h1>
<p>The <code>std</code> library provides many custom types which expands drastically on
the <code>primitives</code>. Some of these include:</p>
<ul>
<li>growable <code>String</code>s like: <code>&quot;hello world&quot;</code></li>
<li>growable vectors: <code>[1, 2, 3]</code></li>
<li>optional types: <code>Option&lt;i32&gt;</code></li>
<li>error handling types: <code>Result&lt;i32, i32&gt;</code></li>
<li>heap allocated pointers: <code>Box&lt;i32&gt;</code></li>
</ul>
<h3 id="see-also-66"><a class="header" href="#see-also-66">See also:</a></h3>
<p><a href="primitives.html">primitives</a> and <a href="https://doc.rust-lang.org/std/">the std library</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="box-stack-and-heap"><a class="header" href="#box-stack-and-heap">Box, stack and heap</a></h1>
<p>All values in Rust are stack allocated by default. Values can be <em>boxed</em>
(allocated on the heap) by creating a <code>Box&lt;T&gt;</code>. A box is a smart pointer to a
heap allocated value of type <code>T</code>. When a box goes out of scope, its destructor
is called, the inner object is destroyed, and the memory on the heap is freed.</p>
<p>Boxed values can be dereferenced using the <code>*</code> operator; this removes one layer
of indirection. </p>
<pre><pre class="playground"><code class="language-rust editable">use std::mem;

#[allow(dead_code)]
#[derive(Debug, Clone, Copy)]
struct Point {
    x: f64,
    y: f64,
}

// A Rectangle can be specified by where its top left and bottom right 
// corners are in space
#[allow(dead_code)]
struct Rectangle {
    top_left: Point,
    bottom_right: Point,
}

fn origin() -&gt; Point {
    Point { x: 0.0, y: 0.0 }
}

fn boxed_origin() -&gt; Box&lt;Point&gt; {
    // Allocate this point on the heap, and return a pointer to it
    Box::new(Point { x: 0.0, y: 0.0 })
}

fn main() {
    // (all the type annotations are superfluous)
    // Stack allocated variables
    let point: Point = origin();
    let rectangle: Rectangle = Rectangle {
        top_left: origin(),
        bottom_right: Point { x: 3.0, y: -4.0 }
    };

    // Heap allocated rectangle
    let boxed_rectangle: Box&lt;Rectangle&gt; = Box::new(Rectangle {
        top_left: origin(),
        bottom_right: Point { x: 3.0, y: -4.0 },
    });

    // The output of functions can be boxed
    let boxed_point: Box&lt;Point&gt; = Box::new(origin());

    // Double indirection
    let box_in_a_box: Box&lt;Box&lt;Point&gt;&gt; = Box::new(boxed_origin());

    println!(&quot;Point occupies {} bytes on the stack&quot;,
             mem::size_of_val(&amp;point));
    println!(&quot;Rectangle occupies {} bytes on the stack&quot;,
             mem::size_of_val(&amp;rectangle));

    // box size == pointer size
    println!(&quot;Boxed point occupies {} bytes on the stack&quot;,
             mem::size_of_val(&amp;boxed_point));
    println!(&quot;Boxed rectangle occupies {} bytes on the stack&quot;,
             mem::size_of_val(&amp;boxed_rectangle));
    println!(&quot;Boxed box occupies {} bytes on the stack&quot;,
             mem::size_of_val(&amp;box_in_a_box));

    // Copy the data contained in `boxed_point` into `unboxed_point`
    let unboxed_point: Point = *boxed_point;
    println!(&quot;Unboxed point occupies {} bytes on the stack&quot;,
             mem::size_of_val(&amp;unboxed_point));
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="vectors"><a class="header" href="#vectors">Vectors</a></h1>
<p>Vectors are re-sizable arrays. Like slices, their size is not known at compile
time, but they can grow or shrink at any time. A vector is represented using
3 parameters: </p>
<ul>
<li>pointer to the data</li>
<li>length</li>
<li>capacity </li>
</ul>
<p>The capacity indicates how much memory is reserved for the vector. The vector 
can grow as long as the length is smaller than the capacity. When this threshold 
needs to be surpassed, the vector is reallocated with a larger capacity.</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    // Iterators can be collected into vectors
    let collected_iterator: Vec&lt;i32&gt; = (0..10).collect();
    println!(&quot;Collected (0..10) into: {:?}&quot;, collected_iterator);

    // The `vec!` macro can be used to initialize a vector
    let mut xs = vec![1i32, 2, 3];
    println!(&quot;Initial vector: {:?}&quot;, xs);

    // Insert new element at the end of the vector
    println!(&quot;Push 4 into the vector&quot;);
    xs.push(4);
    println!(&quot;Vector: {:?}&quot;, xs);

    // Error! Immutable vectors can't grow
    collected_iterator.push(0);
    // FIXME ^ Comment out this line

    // The `len` method yields the number of elements currently stored in a vector
    println!(&quot;Vector length: {}&quot;, xs.len());

    // Indexing is done using the square brackets (indexing starts at 0)
    println!(&quot;Second element: {}&quot;, xs[1]);

    // `pop` removes the last element from the vector and returns it
    println!(&quot;Pop last element: {:?}&quot;, xs.pop());

    // Out of bounds indexing yields a panic
    println!(&quot;Fourth element: {}&quot;, xs[3]);
    // FIXME ^ Comment out this line

    // `Vector`s can be easily iterated over
    println!(&quot;Contents of xs:&quot;);
    for x in xs.iter() {
        println!(&quot;&gt; {}&quot;, x);
    }

    // A `Vector` can also be iterated over while the iteration
    // count is enumerated in a separate variable (`i`)
    for (i, x) in xs.iter().enumerate() {
        println!(&quot;In position {} we have value {}&quot;, i, x);
    }

    // Thanks to `iter_mut`, mutable `Vector`s can also be iterated
    // over in a way that allows modifying each value
    for x in xs.iter_mut() {
        *x *= 3;
    }
    println!(&quot;Updated vector: {:?}&quot;, xs);
}
</code></pre></pre>
<p>More <code>Vec</code> methods can be found under the
<a href="https://doc.rust-lang.org/std/vec/">std::vec</a> module</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="strings"><a class="header" href="#strings">Strings</a></h1>
<p>There are two types of strings in Rust: <code>String</code> and <code>&amp;str</code>.</p>
<p>A <code>String</code> is stored as a vector of bytes (<code>Vec&lt;u8&gt;</code>), but guaranteed to
always be a valid UTF-8 sequence. <code>String</code> is heap allocated, growable and not
null terminated.</p>
<p><code>&amp;str</code> is a slice (<code>&amp;[u8]</code>) that always points to a valid UTF-8 sequence, and
can be used to view into a <code>String</code>, just like <code>&amp;[T]</code> is a view into <code>Vec&lt;T&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    // (all the type annotations are superfluous)
    // A reference to a string allocated in read only memory
    let pangram: &amp;'static str = &quot;the quick brown fox jumps over the lazy dog&quot;;
    println!(&quot;Pangram: {}&quot;, pangram);

    // Iterate over words in reverse, no new string is allocated
    println!(&quot;Words in reverse&quot;);
    for word in pangram.split_whitespace().rev() {
        println!(&quot;&gt; {}&quot;, word);
    }

    // Copy chars into a vector, sort and remove duplicates
    let mut chars: Vec&lt;char&gt; = pangram.chars().collect();
    chars.sort();
    chars.dedup();

    // Create an empty and growable `String`
    let mut string = String::new();
    for c in chars {
        // Insert a char at the end of string
        string.push(c);
        // Insert a string at the end of string
        string.push_str(&quot;, &quot;);
    }

    // The trimmed string is a slice to the original string, hence no new
    // allocation is performed
    let chars_to_trim: &amp;[char] = &amp;[' ', ','];
    let trimmed_str: &amp;str = string.trim_matches(chars_to_trim);
    println!(&quot;Used characters: {}&quot;, trimmed_str);

    // Heap allocate a string
    let alice = String::from(&quot;I like dogs&quot;);
    // Allocate new memory and store the modified string there
    let bob: String = alice.replace(&quot;dog&quot;, &quot;cat&quot;);

    println!(&quot;Alice says: {}&quot;, alice);
    println!(&quot;Bob says: {}&quot;, bob);
}
</code></pre></pre>
<p>More <code>str</code>/<code>String</code> methods can be found under the
<a href="https://doc.rust-lang.org/std/str/">std::str</a> and
<a href="https://doc.rust-lang.org/std/string/">std::string</a>
modules</p>
<h2 id="literals-and-escapes"><a class="header" href="#literals-and-escapes">Literals and escapes</a></h2>
<p>There are multiple ways to write string literals with special characters in them.
All result in a similar <code>&amp;str</code> so it's best to use the form that is the most
convenient to write. Similarly there are multiple ways to write byte string literals,
which all result in <code>&amp;[u8; N]</code>.</p>
<p>Generally special characters are escaped with a backslash character: <code>\</code>.
This way you can add any character to your string, even unprintable ones
and ones that you don't know how to type. If you want a literal backslash,
escape it with another one: <code>\\</code></p>
<p>String or character literal delimiters occuring within a literal must be escaped: <code>&quot;\&quot;&quot;</code>, <code>'\''</code>.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    // You can use escapes to write bytes by their hexadecimal values...
    let byte_escape = &quot;I'm writing \x52\x75\x73\x74!&quot;;
    println!(&quot;What are you doing\x3F (\\x3F means ?) {}&quot;, byte_escape);

    // ...or Unicode code points.
    let unicode_codepoint = &quot;\u{211D}&quot;;
    let character_name = &quot;\&quot;DOUBLE-STRUCK CAPITAL R\&quot;&quot;;

    println!(&quot;Unicode character {} (U+211D) is called {}&quot;,
                unicode_codepoint, character_name );


    let long_string = &quot;String literals
                        can span multiple lines.
                        The linebreak and indentation here -&gt;\
                        &lt;- can be escaped too!&quot;;
    println!(&quot;{}&quot;, long_string);
}
</code></pre></pre>
<p>Sometimes there are just too many characters that need to be escaped or it's just
much more convenient to write a string out as-is. This is where raw string literals come into play.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let raw_str = r&quot;Escapes don't work here: \x3F \u{211D}&quot;;
    println!(&quot;{}&quot;, raw_str);

    // If you need quotes in a raw string, add a pair of #s
    let quotes = r#&quot;And then I said: &quot;There is no escape!&quot;&quot;#;
    println!(&quot;{}&quot;, quotes);

    // If you need &quot;# in your string, just use more #s in the delimiter.
    // There is no limit for the number of #s you can use.
    let longer_delimiter = r###&quot;A string with &quot;# in it. And even &quot;##!&quot;###;
    println!(&quot;{}&quot;, longer_delimiter);
}
</code></pre></pre>
<p>Want a string that's not UTF-8? (Remember, <code>str</code> and <code>String</code> must be valid UTF-8).
Or maybe you want an array of bytes that's mostly text? Byte strings to the rescue!</p>
<pre><pre class="playground"><code class="language-rust editable">use std::str;

fn main() {
    // Note that this is not actually a `&amp;str`
    let bytestring: &amp;[u8; 21] = b&quot;this is a byte string&quot;;

    // Byte arrays don't have the `Display` trait, so printing them is a bit limited
    println!(&quot;A byte string: {:?}&quot;, bytestring);

    // Byte strings can have byte escapes...
    let escaped = b&quot;\x52\x75\x73\x74 as bytes&quot;;
    // ...but no unicode escapes
    // let escaped = b&quot;\u{211D} is not allowed&quot;;
    println!(&quot;Some escaped bytes: {:?}&quot;, escaped);


    // Raw byte strings work just like raw strings
    let raw_bytestring = br&quot;\u{211D} is not escaped here&quot;;
    println!(&quot;{:?}&quot;, raw_bytestring);

    // Converting a byte array to `str` can fail
    if let Ok(my_str) = str::from_utf8(raw_bytestring) {
        println!(&quot;And the same as text: '{}'&quot;, my_str);
    }

    let _quotes = br#&quot;You can also use &quot;fancier&quot; formatting, \
                    like with normal raw strings&quot;#;

    // Byte strings don't have to be UTF-8
    let shift_jis = b&quot;\x82\xe6\x82\xa8\x82\xb1\x82\xbb&quot;; // &quot;ようこそ&quot; in SHIFT-JIS

    // But then they can't always be converted to `str`
    match str::from_utf8(shift_jis) {
        Ok(my_str) =&gt; println!(&quot;Conversion successful: '{}'&quot;, my_str),
        Err(e) =&gt; println!(&quot;Conversion failed: {:?}&quot;, e),
    };
}
</code></pre></pre>
<p>For conversions between character encodings check out the <a href="https://crates.io/crates/encoding">encoding</a> crate.</p>
<p>A more detailed listing of the ways to write string literals and escape characters
is given in the <a href="https://doc.rust-lang.org/reference/tokens.html">'Tokens' chapter</a> of the Rust Reference.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="option"><a class="header" href="#option"><code>Option</code></a></h1>
<p>Sometimes it's desirable to catch the failure of some parts of a program
instead of calling <code>panic!</code>; this can be accomplished using the <code>Option</code> enum.</p>
<p>The <code>Option&lt;T&gt;</code> enum has two variants:</p>
<ul>
<li><code>None</code>, to indicate failure or lack of value, and</li>
<li><code>Some(value)</code>, a tuple struct that wraps a <code>value</code> with type <code>T</code>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">// An integer division that doesn't `panic!`
fn checked_division(dividend: i32, divisor: i32) -&gt; Option&lt;i32&gt; {
    if divisor == 0 {
        // Failure is represented as the `None` variant
        None
    } else {
        // Result is wrapped in a `Some` variant
        Some(dividend / divisor)
    }
}

// This function handles a division that may not succeed
fn try_division(dividend: i32, divisor: i32) {
    // `Option` values can be pattern matched, just like other enums
    match checked_division(dividend, divisor) {
        None =&gt; println!(&quot;{} / {} failed!&quot;, dividend, divisor),
        Some(quotient) =&gt; {
            println!(&quot;{} / {} = {}&quot;, dividend, divisor, quotient)
        },
    }
}

fn main() {
    try_division(4, 2);
    try_division(1, 0);

    // Binding `None` to a variable needs to be type annotated
    let none: Option&lt;i32&gt; = None;
    let _equivalent_none = None::&lt;i32&gt;;

    let optional_float = Some(0f32);

    // Unwrapping a `Some` variant will extract the value wrapped.
    println!(&quot;{:?} unwraps to {:?}&quot;, optional_float, optional_float.unwrap());

    // Unwrapping a `None` variant will `panic!`
    println!(&quot;{:?} unwraps to {:?}&quot;, none, none.unwrap());
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="result-1"><a class="header" href="#result-1"><code>Result</code></a></h1>
<p>We've seen that the <code>Option</code> enum can be used as a return value from functions
that may fail, where <code>None</code> can be returned to indicate failure. However,
sometimes it is important to express <em>why</em> an operation failed. To do this we 
have the <code>Result</code> enum.</p>
<p>The <code>Result&lt;T, E&gt;</code> enum has two variants:</p>
<ul>
<li><code>Ok(value)</code> which indicates that the operation succeeded, and wraps the
<code>value</code> returned by the operation. (<code>value</code> has type <code>T</code>)</li>
<li><code>Err(why)</code>, which indicates that the operation failed, and wraps <code>why</code>,
which (hopefully) explains the cause of the failure. (<code>why</code> has type <code>E</code>)</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">mod checked {
    // Mathematical &quot;errors&quot; we want to catch
    #[derive(Debug)]
    pub enum MathError {
        DivisionByZero,
        NonPositiveLogarithm,
        NegativeSquareRoot,
    }

    pub type MathResult = Result&lt;f64, MathError&gt;;

    pub fn div(x: f64, y: f64) -&gt; MathResult {
        if y == 0.0 {
            // This operation would `fail`, instead let's return the reason of
            // the failure wrapped in `Err`
            Err(MathError::DivisionByZero)
        } else {
            // This operation is valid, return the result wrapped in `Ok`
            Ok(x / y)
        }
    }

    pub fn sqrt(x: f64) -&gt; MathResult {
        if x &lt; 0.0 {
            Err(MathError::NegativeSquareRoot)
        } else {
            Ok(x.sqrt())
        }
    }

    pub fn ln(x: f64) -&gt; MathResult {
        if x &lt;= 0.0 {
            Err(MathError::NonPositiveLogarithm)
        } else {
            Ok(x.ln())
        }
    }
}

// `op(x, y)` === `sqrt(ln(x / y))`
fn op(x: f64, y: f64) -&gt; f64 {
    // This is a three level match pyramid!
    match checked::div(x, y) {
        Err(why) =&gt; panic!(&quot;{:?}&quot;, why),
        Ok(ratio) =&gt; match checked::ln(ratio) {
            Err(why) =&gt; panic!(&quot;{:?}&quot;, why),
            Ok(ln) =&gt; match checked::sqrt(ln) {
                Err(why) =&gt; panic!(&quot;{:?}&quot;, why),
                Ok(sqrt) =&gt; sqrt,
            },
        },
    }
}

fn main() {
    // Will this fail?
    println!(&quot;{}&quot;, op(1.0, 10.0));
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id=""><a class="header" href="#"><code>?</code></a></h1>
<p>Chaining results using match can get pretty untidy; luckily, the <code>?</code> operator
can be used to make things pretty again. <code>?</code> is used at the end of an expression
returning a <code>Result</code>, and is equivalent to a match expression, where the 
<code>Err(err)</code> branch expands to an early <code>Err(From::from(err))</code>, and the <code>Ok(ok)</code>
branch expands to an <code>ok</code> expression.</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">mod checked {
    #[derive(Debug)]
    enum MathError {
        DivisionByZero,
        NonPositiveLogarithm,
        NegativeSquareRoot,
    }

    type MathResult = Result&lt;f64, MathError&gt;;

    fn div(x: f64, y: f64) -&gt; MathResult {
        if y == 0.0 {
            Err(MathError::DivisionByZero)
        } else {
            Ok(x / y)
        }
    }

    fn sqrt(x: f64) -&gt; MathResult {
        if x &lt; 0.0 {
            Err(MathError::NegativeSquareRoot)
        } else {
            Ok(x.sqrt())
        }
    }

    fn ln(x: f64) -&gt; MathResult {
        if x &lt;= 0.0 {
            Err(MathError::NonPositiveLogarithm)
        } else {
            Ok(x.ln())
        }
    }

    // Intermediate function
    fn op_(x: f64, y: f64) -&gt; MathResult {
        // if `div` &quot;fails&quot;, then `DivisionByZero` will be `return`ed
        let ratio = div(x, y)?;

        // if `ln` &quot;fails&quot;, then `NonPositiveLogarithm` will be `return`ed
        let ln = ln(ratio)?;

        sqrt(ln)
    }

    pub fn op(x: f64, y: f64) {
        match op_(x, y) {
            Err(why) =&gt; panic!(&quot;{}&quot;, match why {
                MathError::NonPositiveLogarithm
                    =&gt; &quot;logarithm of non-positive number&quot;,
                MathError::DivisionByZero
                    =&gt; &quot;division by zero&quot;,
                MathError::NegativeSquareRoot
                    =&gt; &quot;square root of negative number&quot;,
            }),
            Ok(value) =&gt; println!(&quot;{}&quot;, value),
        }
    }
}

fn main() {
    checked::op(1.0, 10.0);
}
</code></pre></pre>
<p>Be sure to check the <a href="https://doc.rust-lang.org/std/result/index.html">documentation</a>,
as there are many methods to map/compose <code>Result</code>.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="panic-1"><a class="header" href="#panic-1"><code>panic!</code></a></h1>
<p>The <code>panic!</code> macro can be used to generate a panic and start unwinding
its stack. While unwinding, the runtime will take care of freeing all the
resources <em>owned</em> by the thread by calling the destructor of all its objects.</p>
<p>Since we are dealing with programs with only one thread, <code>panic!</code> will cause the
program to report the panic message and exit.</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">// Re-implementation of integer division (/)
fn division(dividend: i32, divisor: i32) -&gt; i32 {
    if divisor == 0 {
        // Division by zero triggers a panic
        panic!(&quot;division by zero&quot;);
    } else {
        dividend / divisor
    }
}

// The `main` task
fn main() {
    // Heap allocated integer
    let _x = Box::new(0i32);

    // This operation will trigger a task failure
    division(3, 0);

    println!(&quot;This point won't be reached!&quot;);

    // `_x` should get destroyed at this point
}
</code></pre></pre>
<p>Let's check that <code>panic!</code> doesn't leak memory.</p>
<pre><code class="language-shell">$ rustc panic.rs &amp;&amp; valgrind ./panic
==4401== Memcheck, a memory error detector
==4401== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al.
==4401== Using Valgrind-3.10.0.SVN and LibVEX; rerun with -h for copyright info
==4401== Command: ./panic
==4401== 
thread '&lt;main&gt;' panicked at 'division by zero', panic.rs:5
==4401== 
==4401== HEAP SUMMARY:
==4401==     in use at exit: 0 bytes in 0 blocks
==4401==   total heap usage: 18 allocs, 18 frees, 1,648 bytes allocated
==4401== 
==4401== All heap blocks were freed -- no leaks are possible
==4401== 
==4401== For counts of detected and suppressed errors, rerun with: -v
==4401== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="hashmap"><a class="header" href="#hashmap">HashMap</a></h1>
<p>Where vectors store values by an integer index, <code>HashMap</code>s store values by key. 
<code>HashMap</code> keys can be booleans, integers, strings, 
or any other type that implements the <code>Eq</code> and <code>Hash</code> traits. 
More on this in the next section.</p>
<p>Like vectors, <code>HashMap</code>s are growable, but HashMaps can also shrink themselves 
when they have excess space. 
You can create a HashMap with a certain starting capacity using 
<code>HashMap::with_capacity(uint)</code>, or use <code>HashMap::new()</code> to get a HashMap 
with a default initial capacity (recommended).</p>
<pre><pre class="playground"><code class="language-rust editable">use std::collections::HashMap;

fn call(number: &amp;str) -&gt; &amp;str {
    match number {
        &quot;798-1364&quot; =&gt; &quot;We're sorry, the call cannot be completed as dialed. 
            Please hang up and try again.&quot;,
        &quot;645-7689&quot; =&gt; &quot;Hello, this is Mr. Awesome's Pizza. My name is Fred.
            What can I get for you today?&quot;,
        _ =&gt; &quot;Hi! Who is this again?&quot;
    }
}

fn main() { 
    let mut contacts = HashMap::new();

    contacts.insert(&quot;Daniel&quot;, &quot;798-1364&quot;);
    contacts.insert(&quot;Ashley&quot;, &quot;645-7689&quot;);
    contacts.insert(&quot;Katie&quot;, &quot;435-8291&quot;);
    contacts.insert(&quot;Robert&quot;, &quot;956-1745&quot;);

    // Takes a reference and returns Option&lt;&amp;V&gt;
    match contacts.get(&amp;&quot;Daniel&quot;) {
        Some(&amp;number) =&gt; println!(&quot;Calling Daniel: {}&quot;, call(number)),
        _ =&gt; println!(&quot;Don't have Daniel's number.&quot;),
    }

    // `HashMap::insert()` returns `None`
    // if the inserted value is new, `Some(value)` otherwise
    contacts.insert(&quot;Daniel&quot;, &quot;164-6743&quot;);

    match contacts.get(&amp;&quot;Ashley&quot;) {
        Some(&amp;number) =&gt; println!(&quot;Calling Ashley: {}&quot;, call(number)),
        _ =&gt; println!(&quot;Don't have Ashley's number.&quot;),
    }

    contacts.remove(&amp;&quot;Ashley&quot;); 

    // `HashMap::iter()` returns an iterator that yields 
    // (&amp;'a key, &amp;'a value) pairs in arbitrary order.
    for (contact, &amp;number) in contacts.iter() {
        println!(&quot;Calling {}: {}&quot;, contact, call(number)); 
    }
}
</code></pre></pre>
<p>For more information on how hashing and hash maps 
(sometimes called hash tables) work, have a look at 
<a href="https://en.wikipedia.org/wiki/Hash_table">Hash Table Wikipedia</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="alternatecustom-key-types"><a class="header" href="#alternatecustom-key-types">Alternate/custom key types</a></h1>
<p>Any type that implements the <code>Eq</code> and <code>Hash</code> traits can be a key in <code>HashMap</code>. 
This includes:</p>
<ul>
<li><code>bool</code> (though not very useful since there is only two possible keys)</li>
<li><code>int</code>, <code>uint</code>, and all variations thereof</li>
<li><code>String</code> and <code>&amp;str</code> (protip: you can have a <code>HashMap</code> keyed by <code>String</code>
and call <code>.get()</code> with an <code>&amp;str</code>)</li>
</ul>
<p>Note that <code>f32</code> and <code>f64</code> do <em>not</em> implement <code>Hash</code>,
likely because <a href="https://en.wikipedia.org/wiki/Floating_point#Accuracy_problems">floating-point precision errors</a>
would make using them as hashmap keys horribly error-prone.</p>
<p>All collection classes implement <code>Eq</code> and <code>Hash</code> 
if their contained type also respectively implements <code>Eq</code> and <code>Hash</code>. 
For example, <code>Vec&lt;T&gt;</code> will implement <code>Hash</code> if <code>T</code> implements <code>Hash</code>.</p>
<p>You can easily implement <code>Eq</code> and <code>Hash</code> for a custom type with just one line: 
<code>#[derive(PartialEq, Eq, Hash)]</code></p>
<p>The compiler will do the rest. If you want more control over the details, 
you can implement <code>Eq</code> and/or <code>Hash</code> yourself. 
This guide will not cover the specifics of implementing <code>Hash</code>. </p>
<p>To play around with using a <code>struct</code> in <code>HashMap</code>, 
let's try making a very simple user logon system:</p>
<pre><pre class="playground"><code class="language-rust editable">use std::collections::HashMap;

// Eq requires that you derive PartialEq on the type.
#[derive(PartialEq, Eq, Hash)]
struct Account&lt;'a&gt;{
    username: &amp;'a str,
    password: &amp;'a str,
}

struct AccountInfo&lt;'a&gt;{
    name: &amp;'a str,
    email: &amp;'a str,
}

type Accounts&lt;'a&gt; = HashMap&lt;Account&lt;'a&gt;, AccountInfo&lt;'a&gt;&gt;;

fn try_logon&lt;'a&gt;(accounts: &amp;Accounts&lt;'a&gt;,
        username: &amp;'a str, password: &amp;'a str){
    println!(&quot;Username: {}&quot;, username);
    println!(&quot;Password: {}&quot;, password);
    println!(&quot;Attempting logon...&quot;);

    let logon = Account {
        username,
        password,
    };

    match accounts.get(&amp;logon) {
        Some(account_info) =&gt; {
            println!(&quot;Successful logon!&quot;);
            println!(&quot;Name: {}&quot;, account_info.name);
            println!(&quot;Email: {}&quot;, account_info.email);
        },
        _ =&gt; println!(&quot;Login failed!&quot;),
    }
}

fn main(){
    let mut accounts: Accounts = HashMap::new();

    let account = Account {
        username: &quot;j.everyman&quot;,
        password: &quot;password123&quot;,
    };

    let account_info = AccountInfo {
        name: &quot;John Everyman&quot;,
        email: &quot;j.everyman@email.com&quot;,
    };

    accounts.insert(account, account_info);

    try_logon(&amp;accounts, &quot;j.everyman&quot;, &quot;psasword123&quot;);

    try_logon(&amp;accounts, &quot;j.everyman&quot;, &quot;password123&quot;);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="hashset"><a class="header" href="#hashset">HashSet</a></h1>
<p>Consider a <code>HashSet</code> as a <code>HashMap</code> where we just care about the keys (
<code>HashSet&lt;T&gt;</code> is, in actuality, just a wrapper around <code>HashMap&lt;T, ()&gt;</code>).</p>
<p>&quot;What's the point of that?&quot; you ask. &quot;I could just store the keys in a <code>Vec</code>.&quot;</p>
<p>A <code>HashSet</code>'s unique feature is that 
it is guaranteed to not have duplicate elements. 
That's the contract that any set collection fulfills. 
<code>HashSet</code> is just one implementation. (see also: <a href="https://doc.rust-lang.org/std/collections/struct.BTreeSet.html"><code>BTreeSet</code></a>)</p>
<p>If you insert a value that is already present in the <code>HashSet</code>, 
(i.e. the new value is equal to the existing and they both have the same hash), 
then the new value will replace the old.</p>
<p>This is great for when you never want more than one of something, 
or when you want to know if you've already got something.</p>
<p>But sets can do more than that. </p>
<p>Sets have 4 primary operations (all of the following calls return an iterator):</p>
<ul>
<li>
<p><code>union</code>: get all the unique elements in both sets.</p>
</li>
<li>
<p><code>difference</code>: get all the elements that are in the first set but not the second.</p>
</li>
<li>
<p><code>intersection</code>: get all the elements that are only in <em>both</em> sets.</p>
</li>
<li>
<p><code>symmetric_difference</code>: 
get all the elements that are in one set or the other, but <em>not</em> both.</p>
</li>
</ul>
<p>Try all of these in the following example:</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">use std::collections::HashSet;

fn main() {
    let mut a: HashSet&lt;i32&gt; = vec![1i32, 2, 3].into_iter().collect();
    let mut b: HashSet&lt;i32&gt; = vec![2i32, 3, 4].into_iter().collect();

    assert!(a.insert(4));
    assert!(a.contains(&amp;4));

    // `HashSet::insert()` returns false if
    // there was a value already present.
    assert!(b.insert(4), &quot;Value 4 is already in set B!&quot;);
    // FIXME ^ Comment out this line

    b.insert(5);

    // If a collection's element type implements `Debug`,
    // then the collection implements `Debug`.
    // It usually prints its elements in the format `[elem1, elem2, ...]`
    println!(&quot;A: {:?}&quot;, a);
    println!(&quot;B: {:?}&quot;, b);

    // Print [1, 2, 3, 4, 5] in arbitrary order
    println!(&quot;Union: {:?}&quot;, a.union(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());

    // This should print [1]
    println!(&quot;Difference: {:?}&quot;, a.difference(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());

    // Print [2, 3, 4] in arbitrary order.
    println!(&quot;Intersection: {:?}&quot;, a.intersection(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());

    // Print [1, 5]
    println!(&quot;Symmetric Difference: {:?}&quot;,
             a.symmetric_difference(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());
}
</code></pre></pre>
<p>(Examples are adapted from the <a href="https://doc.rust-lang.org/std/collections/struct.HashSet.html#method.difference">documentation.</a>)</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="rc"><a class="header" href="#rc"><code>Rc</code></a></h1>
<p>When multiple ownership is needed, <code>Rc</code>(Reference Counting) can be used. <code>Rc</code> keeps track of the number of the references which means the number of owners of the value wrapped inside an <code>Rc</code>. </p>
<p>Reference count of an <code>Rc</code> increases by 1 whenever an <code>Rc</code> is cloned, and decreases by 1 whenever one cloned <code>Rc</code> is dropped out of the scope. When an <code>Rc</code>'s reference count becomes zero, which means there are no owners remained, both the <code>Rc</code> and the value are all dropped. </p>
<p>Cloning an <code>Rc</code> never performs a deep copy. Cloning creates just another pointer to the wrapped value, and increments the count.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::rc::Rc;

fn main() {
    let rc_examples = &quot;Rc examples&quot;.to_string();
    {
        println!(&quot;--- rc_a is created ---&quot;);
        
        let rc_a: Rc&lt;String&gt; = Rc::new(rc_examples);
        println!(&quot;Reference Count of rc_a: {}&quot;, Rc::strong_count(&amp;rc_a));
        
        {
            println!(&quot;--- rc_a is cloned to rc_b ---&quot;);
            
            let rc_b: Rc&lt;String&gt; = Rc::clone(&amp;rc_a);
            println!(&quot;Reference Count of rc_b: {}&quot;, Rc::strong_count(&amp;rc_b));
            println!(&quot;Reference Count of rc_a: {}&quot;, Rc::strong_count(&amp;rc_a));
            
            // Two `Rc`s are equal if their inner values are equal
            println!(&quot;rc_a and rc_b are equal: {}&quot;, rc_a.eq(&amp;rc_b));
            
            // We can use methods of a value directly
            println!(&quot;Length of the value inside rc_a: {}&quot;, rc_a.len());
            println!(&quot;Value of rc_b: {}&quot;, rc_b);
            
            println!(&quot;--- rc_b is dropped out of scope ---&quot;);
        }
        
        println!(&quot;Reference Count of rc_a: {}&quot;, Rc::strong_count(&amp;rc_a));
        
        println!(&quot;--- rc_a is dropped out of scope ---&quot;);
    }
    
    // Error! `rc_examples` already moved into `rc_a`
    // And when `rc_a` is dropped, `rc_examples` is dropped together
    // println!(&quot;rc_examples: {}&quot;, rc_examples);
    // TODO ^ Try uncommenting this line
}
</code></pre></pre>
<h3 id="see-also-67"><a class="header" href="#see-also-67">See also:</a></h3>
<p><a href="https://doc.rust-lang.org/std/rc/index.html">std::rc</a> and <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html">std::sync::arc</a>.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="arc"><a class="header" href="#arc">Arc</a></h1>
<p>When shared ownership between threads is needed, <code>Arc</code>(Atomic Reference Counted) can be used. This struct, via the <code>Clone</code> implementation can create a reference pointer for the location of a value in the memory heap while increasing the reference counter. As it shares ownership between threads, when the last reference pointer to a value is out of scope, the variable is dropped.</p>
<pre><pre class="playground"><code class="language-rust editable">
fn main() {
use std::sync::Arc;
use std::thread;

// This variable declaration is where its value is specified.
let apple = Arc::new(&quot;the same apple&quot;);

for _ in 0..10 {
    // Here there is no value specification as it is a pointer to a reference
    // in the memory heap.
    let apple = Arc::clone(&amp;apple);

    thread::spawn(move || {
        // As Arc was used, threads can be spawned using the value allocated
        // in the Arc variable pointer's location.
        println!(&quot;{:?}&quot;, apple);
    });
}
}

</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="std-misc"><a class="header" href="#std-misc">Std misc</a></h1>
<p>Many other types are provided by the std library to support
things such as:</p>
<ul>
<li>Threads</li>
<li>Channels</li>
<li>File I/O</li>
</ul>
<p>These expand beyond what the <a href="primitives.html">primitives</a> provide.</p>
<h3 id="see-also-68"><a class="header" href="#see-also-68">See also:</a></h3>
<p><a href="primitives.html">primitives</a> and <a href="https://doc.rust-lang.org/std/">the std library</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="threads"><a class="header" href="#threads">Threads</a></h1>
<p>Rust provides a mechanism for spawning native OS threads via the <code>spawn</code>
function, the argument of this function is a moving closure.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::thread;

const NTHREADS: u32 = 10;

// This is the `main` thread
fn main() {
    // Make a vector to hold the children which are spawned.
    let mut children = vec![];

    for i in 0..NTHREADS {
        // Spin up another thread
        children.push(thread::spawn(move || {
            println!(&quot;this is thread number {}&quot;, i);
        }));
    }

    for child in children {
        // Wait for the thread to finish. Returns a result.
        let _ = child.join();
    }
}
</code></pre></pre>
<p>These threads will be scheduled by the OS.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="testcase-map-reduce"><a class="header" href="#testcase-map-reduce">Testcase: map-reduce</a></h1>
<p>Rust makes it very easy to parallelise data processing, without many of the headaches traditionally associated with such an attempt.</p>
<p>The standard library provides great threading primitives out of the box.
These, combined with Rust's concept of Ownership and aliasing rules, automatically prevent
data races.</p>
<p>The aliasing rules (one writable reference XOR many readable references) automatically prevent
you from manipulating state that is visible to other threads. (Where synchronisation is needed,
there are synchronisation
primitives like <code>Mutex</code>es or <code>Channel</code>s.)</p>
<p>In this example, we will calculate the sum of all digits in a block of numbers.
We will do this by parcelling out chunks of the block into different threads. Each thread will sum
its tiny block of digits, and subsequently we will sum the intermediate sums produced by each
thread.</p>
<p>Note that, although we're passing references across thread boundaries, Rust understands that we're
only passing read-only references, and that thus no unsafety or data races can occur. Because
we're <code>move</code>-ing the data segments into the thread, Rust will also ensure the data is kept alive
until the threads exit, so no dangling pointers occur.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::thread;

// This is the `main` thread
fn main() {

    // This is our data to process.
    // We will calculate the sum of all digits via a threaded  map-reduce algorithm.
    // Each whitespace separated chunk will be handled in a different thread.
    //
    // TODO: see what happens to the output if you insert spaces!
    let data = &quot;86967897737416471853297327050364959
11861322575564723963297542624962850
70856234701860851907960690014725639
38397966707106094172783238747669219
52380795257888236525459303330302837
58495327135744041048897885734297812
69920216438980873548808413720956532
16278424637452589860345374828574668&quot;;

    // Make a vector to hold the child-threads which we will spawn.
    let mut children = vec![];

    /*************************************************************************
     * &quot;Map&quot; phase
     *
     * Divide our data into segments, and apply initial processing
     ************************************************************************/

    // split our data into segments for individual calculation
    // each chunk will be a reference (&amp;str) into the actual data
    let chunked_data = data.split_whitespace();

    // Iterate over the data segments.
    // .enumerate() adds the current loop index to whatever is iterated
    // the resulting tuple &quot;(index, element)&quot; is then immediately
    // &quot;destructured&quot; into two variables, &quot;i&quot; and &quot;data_segment&quot; with a
    // &quot;destructuring assignment&quot;
    for (i, data_segment) in chunked_data.enumerate() {
        println!(&quot;data segment {} is \&quot;{}\&quot;&quot;, i, data_segment);

        // Process each data segment in a separate thread
        //
        // spawn() returns a handle to the new thread,
        // which we MUST keep to access the returned value
        //
        // 'move || -&gt; u32' is syntax for a closure that:
        // * takes no arguments ('||')
        // * takes ownership of its captured variables ('move') and
        // * returns an unsigned 32-bit integer ('-&gt; u32')
        //
        // Rust is smart enough to infer the '-&gt; u32' from
        // the closure itself so we could have left that out.
        //
        // TODO: try removing the 'move' and see what happens
        children.push(thread::spawn(move || -&gt; u32 {
            // Calculate the intermediate sum of this segment:
            let result = data_segment
                        // iterate over the characters of our segment..
                        .chars()
                        // .. convert text-characters to their number value..
                        .map(|c| c.to_digit(10).expect(&quot;should be a digit&quot;))
                        // .. and sum the resulting iterator of numbers
                        .sum();

            // println! locks stdout, so no text-interleaving occurs
            println!(&quot;processed segment {}, result={}&quot;, i, result);

            // &quot;return&quot; not needed, because Rust is an &quot;expression language&quot;, the
            // last evaluated expression in each block is automatically its value.
            result

        }));
    }


    /*************************************************************************
     * &quot;Reduce&quot; phase
     *
     * Collect our intermediate results, and combine them into a final result
     ************************************************************************/

    // combine each thread's intermediate results into a single final sum.
    //
    // we use the &quot;turbofish&quot; ::&lt;&gt; to provide sum() with a type hint.
    //
    // TODO: try without the turbofish, by instead explicitly
    // specifying the type of final_result
    let final_result = children.into_iter().map(|c| c.join().unwrap()).sum::&lt;u32&gt;();

    println!(&quot;Final sum result: {}&quot;, final_result);
}


</code></pre></pre>
<h3 id="assignments"><a class="header" href="#assignments">Assignments</a></h3>
<p>It is not wise to let our number of threads depend on user inputted data.
What if the user decides to insert a lot of spaces? Do we <em>really</em> want to spawn 2,000 threads?
Modify the program so that the data is always chunked into a limited number of chunks,
defined by a static constant at the beginning of the program.</p>
<h3 id="see-also-69"><a class="header" href="#see-also-69">See also:</a></h3>
<ul>
<li><a href="std_misc/threads/../threads.html">Threads</a></li>
<li><a href="std_misc/threads/../../std/vec.html">vectors</a> and <a href="std_misc/threads/../../trait/iter.html">iterators</a></li>
<li><a href="std_misc/threads/../../fn/closures.html">closures</a>, <a href="std_misc/threads/../../scope/move.html">move</a> semantics and <a href="https://doc.rust-lang.org/book/ch13-01-closures.html#closures-can-capture-their-environment"><code>move</code> closures</a></li>
<li><a href="https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html#destructuring-to-break-apart-values">destructuring</a> assignments</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect">turbofish notation</a> to help type inference</li>
<li><a href="std_misc/threads/../../error/option_unwrap.html">unwrap vs. expect</a></li>
<li><a href="https://doc.rust-lang.org/book/loops.html#enumerate">enumerate</a></li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="channels"><a class="header" href="#channels">Channels</a></h1>
<p>Rust provides asynchronous <code>channels</code> for communication between threads. Channels
allow a unidirectional flow of information between two end-points: the
<code>Sender</code> and the <code>Receiver</code>.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::sync::mpsc::{Sender, Receiver};
use std::sync::mpsc;
use std::thread;

static NTHREADS: i32 = 3;

fn main() {
    // Channels have two endpoints: the `Sender&lt;T&gt;` and the `Receiver&lt;T&gt;`,
    // where `T` is the type of the message to be transferred
    // (type annotation is superfluous)
    let (tx, rx): (Sender&lt;i32&gt;, Receiver&lt;i32&gt;) = mpsc::channel();
    let mut children = Vec::new();

    for id in 0..NTHREADS {
        // The sender endpoint can be copied
        let thread_tx = tx.clone();

        // Each thread will send its id via the channel
        let child = thread::spawn(move || {
            // The thread takes ownership over `thread_tx`
            // Each thread queues a message in the channel
            thread_tx.send(id).unwrap();

            // Sending is a non-blocking operation, the thread will continue
            // immediately after sending its message
            println!(&quot;thread {} finished&quot;, id);
        });

        children.push(child);
    }

    // Here, all the messages are collected
    let mut ids = Vec::with_capacity(NTHREADS as usize);
    for _ in 0..NTHREADS {
        // The `recv` method picks a message from the channel
        // `recv` will block the current thread if there are no messages available
        ids.push(rx.recv());
    }
    
    // Wait for the threads to complete any remaining work
    for child in children {
        child.join().expect(&quot;oops! the child thread panicked&quot;);
    }

    // Show the order in which the messages were sent
    println!(&quot;{:?}&quot;, ids);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="path"><a class="header" href="#path">Path</a></h1>
<p>The <code>Path</code> struct represents file paths in the underlying filesystem. There are
two flavors of <code>Path</code>: <code>posix::Path</code>, for UNIX-like systems, and
<code>windows::Path</code>, for Windows. The prelude exports the appropriate
platform-specific <code>Path</code> variant.</p>
<p>A <code>Path</code> can be created from an <code>OsStr</code>, and provides several methods to get
information from the file/directory the path points to.</p>
<p>Note that a <code>Path</code> is <em>not</em> internally represented as an UTF-8 string, but
instead is stored as a vector of bytes (<code>Vec&lt;u8&gt;</code>). Therefore, converting a
<code>Path</code> to a <code>&amp;str</code> is <em>not</em> free and may fail (an <code>Option</code> is returned).</p>
<pre><pre class="playground"><code class="language-rust editable">use std::path::Path;

fn main() {
    // Create a `Path` from an `&amp;'static str`
    let path = Path::new(&quot;.&quot;);

    // The `display` method returns a `Show`able structure
    let _display = path.display();

    // `join` merges a path with a byte container using the OS specific
    // separator, and returns the new path
    let new_path = path.join(&quot;a&quot;).join(&quot;b&quot;);

    // Convert the path into a string slice
    match new_path.to_str() {
        None =&gt; panic!(&quot;new path is not a valid UTF-8 sequence&quot;),
        Some(s) =&gt; println!(&quot;new path is {}&quot;, s),
    }
}

</code></pre></pre>
<p>Be sure to check at other <code>Path</code> methods (<code>posix::Path</code> or <code>windows::Path</code>) and
the <code>Metadata</code> struct.</p>
<h3 id="see-also-70"><a class="header" href="#see-also-70">See also:</a></h3>
<p><a href="https://doc.rust-lang.org/std/ffi/struct.OsStr.html">OsStr</a> and <a href="https://doc.rust-lang.org/std/fs/struct.Metadata.html">Metadata</a>.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="file-io"><a class="header" href="#file-io">File I/O</a></h1>
<p>The <code>File</code> struct represents a file that has been opened (it wraps a file
descriptor), and gives read and/or write access to the underlying file.</p>
<p>Since many things can go wrong when doing file I/O, all the <code>File</code> methods
return the <code>io::Result&lt;T&gt;</code> type, which is an alias for <code>Result&lt;T, io::Error&gt;</code>.</p>
<p>This makes the failure of all I/O operations <em>explicit</em>. Thanks to this, the
programmer can see all the failure paths, and is encouraged to handle them in
a proactive manner.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="open"><a class="header" href="#open"><code>open</code></a></h1>
<p>The <code>open</code> static method can be used to open a file in read-only mode.</p>
<p>A <code>File</code> owns a resource, the file descriptor and takes care of closing the
file when it is <code>drop</code>ed.</p>
<pre><code class="language-rust editable ignore">use std::fs::File;
use std::io::prelude::*;
use std::path::Path;

fn main() {
    // Create a path to the desired file
    let path = Path::new(&quot;hello.txt&quot;);
    let display = path.display();

    // Open the path in read-only mode, returns `io::Result&lt;File&gt;`
    let mut file = match File::open(&amp;path) {
        Err(why) =&gt; panic!(&quot;couldn't open {}: {}&quot;, display, why),
        Ok(file) =&gt; file,
    };

    // Read the file contents into a string, returns `io::Result&lt;usize&gt;`
    let mut s = String::new();
    match file.read_to_string(&amp;mut s) {
        Err(why) =&gt; panic!(&quot;couldn't read {}: {}&quot;, display, why),
        Ok(_) =&gt; print!(&quot;{} contains:\n{}&quot;, display, s),
    }

    // `file` goes out of scope, and the &quot;hello.txt&quot; file gets closed
}
</code></pre>
<p>Here's the expected successful output:</p>
<pre><code class="language-shell">$ echo &quot;Hello World!&quot; &gt; hello.txt
$ rustc open.rs &amp;&amp; ./open
hello.txt contains:
Hello World!
</code></pre>
<p>(You are encouraged to test the previous example under different failure
conditions: <code>hello.txt</code> doesn't exist, or <code>hello.txt</code> is not readable,
etc.)</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="create"><a class="header" href="#create"><code>create</code></a></h1>
<p>The <code>create</code> static method opens a file in write-only mode. If the file
already existed, the old content is destroyed. Otherwise, a new file is
created.</p>
<pre><code class="language-rust ignore">static LOREM_IPSUM: &amp;str =
    &quot;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,
quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non
proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
&quot;;

use std::fs::File;
use std::io::prelude::*;
use std::path::Path;

fn main() {
    let path = Path::new(&quot;lorem_ipsum.txt&quot;);
    let display = path.display();

    // Open a file in write-only mode, returns `io::Result&lt;File&gt;`
    let mut file = match File::create(&amp;path) {
        Err(why) =&gt; panic!(&quot;couldn't create {}: {}&quot;, display, why),
        Ok(file) =&gt; file,
    };

    // Write the `LOREM_IPSUM` string to `file`, returns `io::Result&lt;()&gt;`
    match file.write_all(LOREM_IPSUM.as_bytes()) {
        Err(why) =&gt; panic!(&quot;couldn't write to {}: {}&quot;, display, why),
        Ok(_) =&gt; println!(&quot;successfully wrote to {}&quot;, display),
    }
}
</code></pre>
<p>Here's the expected successful output:</p>
<pre><code class="language-shell">$ rustc create.rs &amp;&amp; ./create
successfully wrote to lorem_ipsum.txt
$ cat lorem_ipsum.txt
Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,
quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non
proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
</code></pre>
<p>(As in the previous example, you are encouraged to test this example under
failure conditions.)</p>
<p>There is <a href="https://doc.rust-lang.org/std/fs/struct.OpenOptions.html"><code>OpenOptions</code></a> struct that can be used to configure how a file is opened.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="read_lines"><a class="header" href="#read_lines"><code>read_lines</code></a></h1>
<p>The method <code>lines()</code> returns an iterator over the lines
of a file.</p>
<p><code>File::open</code> expects a generic, <code>AsRef&lt;Path&gt;</code>.  That's what
<code>read_lines()</code> expects as input.</p>
<pre><pre class="playground"><code class="language-rust no_run">use std::fs::File;
use std::io::{self, BufRead};
use std::path::Path;

fn main() {
    // File hosts must exist in current path before this produces output
    if let Ok(lines) = read_lines(&quot;./hosts&quot;) {
        // Consumes the iterator, returns an (Optional) String
        for line in lines {
            if let Ok(ip) = line {
                println!(&quot;{}&quot;, ip);
            }
        }
    }
}

// The output is wrapped in a Result to allow matching on errors
// Returns an Iterator to the Reader of the lines of the file.
fn read_lines&lt;P&gt;(filename: P) -&gt; io::Result&lt;io::Lines&lt;io::BufReader&lt;File&gt;&gt;&gt;
where P: AsRef&lt;Path&gt;, {
    let file = File::open(filename)?;
    Ok(io::BufReader::new(file).lines())
}
</code></pre></pre>
<p>Running this program simply prints the lines individually.</p>
<pre><code class="language-shell">$ echo -e &quot;127.0.0.1\n192.168.0.1\n&quot; &gt; hosts
$ rustc read_lines.rs &amp;&amp; ./read_lines
127.0.0.1
192.168.0.1
</code></pre>
<p>This process is more efficient than creating a <code>String</code> in memory
especially working with larger files.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="child-processes"><a class="header" href="#child-processes">Child processes</a></h1>
<p>The <code>process::Output</code> struct represents the output of a finished child process,
and the <code>process::Command</code> struct is a process builder.</p>
<pre><code class="language-rust editable ignore">use std::process::Command;

fn main() {
    let output = Command::new(&quot;rustc&quot;)
        .arg(&quot;--version&quot;)
        .output().unwrap_or_else(|e| {
            panic!(&quot;failed to execute process: {}&quot;, e)
    });

    if output.status.success() {
        let s = String::from_utf8_lossy(&amp;output.stdout);

        print!(&quot;rustc succeeded and stdout was:\n{}&quot;, s);
    } else {
        let s = String::from_utf8_lossy(&amp;output.stderr);

        print!(&quot;rustc failed and stderr was:\n{}&quot;, s);
    }
}
</code></pre>
<p>(You are encouraged to try the previous example with an incorrect flag passed
to <code>rustc</code>)</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="pipes"><a class="header" href="#pipes">Pipes</a></h1>
<p>The <code>std::Child</code> struct represents a running child process, and exposes the
<code>stdin</code>, <code>stdout</code> and <code>stderr</code> handles for interaction with the underlying
process via pipes.</p>
<pre><code class="language-rust ignore">use std::io::prelude::*;
use std::process::{Command, Stdio};

static PANGRAM: &amp;'static str =
&quot;the quick brown fox jumped over the lazy dog\n&quot;;

fn main() {
    // Spawn the `wc` command
    let process = match Command::new(&quot;wc&quot;)
                                .stdin(Stdio::piped())
                                .stdout(Stdio::piped())
                                .spawn() {
        Err(why) =&gt; panic!(&quot;couldn't spawn wc: {}&quot;, why),
        Ok(process) =&gt; process,
    };

    // Write a string to the `stdin` of `wc`.
    //
    // `stdin` has type `Option&lt;ChildStdin&gt;`, but since we know this instance
    // must have one, we can directly `unwrap` it.
    match process.stdin.unwrap().write_all(PANGRAM.as_bytes()) {
        Err(why) =&gt; panic!(&quot;couldn't write to wc stdin: {}&quot;, why),
        Ok(_) =&gt; println!(&quot;sent pangram to wc&quot;),
    }

    // Because `stdin` does not live after the above calls, it is `drop`ed,
    // and the pipe is closed.
    //
    // This is very important, otherwise `wc` wouldn't start processing the
    // input we just sent.

    // The `stdout` field also has type `Option&lt;ChildStdout&gt;` so must be unwrapped.
    let mut s = String::new();
    match process.stdout.unwrap().read_to_string(&amp;mut s) {
        Err(why) =&gt; panic!(&quot;couldn't read wc stdout: {}&quot;, why),
        Ok(_) =&gt; print!(&quot;wc responded with:\n{}&quot;, s),
    }
}
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="wait"><a class="header" href="#wait">Wait</a></h1>
<p>If you'd like to wait for a <code>process::Child</code> to finish, you must call
<code>Child::wait</code>, which will return a <code>process::ExitStatus</code>.</p>
<pre><code class="language-rust ignore">use std::process::Command;

fn main() {
    let mut child = Command::new(&quot;sleep&quot;).arg(&quot;5&quot;).spawn().unwrap();
    let _result = child.wait().unwrap();

    println!(&quot;reached end of main&quot;);
}
</code></pre>
<pre><code class="language-bash">$ rustc wait.rs &amp;&amp; ./wait
# `wait` keeps running for 5 seconds until the `sleep 5` command finishes
reached end of main
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="filesystem-operations"><a class="header" href="#filesystem-operations">Filesystem Operations</a></h1>
<p>The <code>std::fs</code> module contains several functions that deal with the filesystem.</p>
<pre><code class="language-rust ignore">use std::fs;
use std::fs::{File, OpenOptions};
use std::io;
use std::io::prelude::*;
use std::os::unix;
use std::path::Path;

// A simple implementation of `% cat path`
fn cat(path: &amp;Path) -&gt; io::Result&lt;String&gt; {
    let mut f = File::open(path)?;
    let mut s = String::new();
    match f.read_to_string(&amp;mut s) {
        Ok(_) =&gt; Ok(s),
        Err(e) =&gt; Err(e),
    }
}

// A simple implementation of `% echo s &gt; path`
fn echo(s: &amp;str, path: &amp;Path) -&gt; io::Result&lt;()&gt; {
    let mut f = File::create(path)?;

    f.write_all(s.as_bytes())
}

// A simple implementation of `% touch path` (ignores existing files)
fn touch(path: &amp;Path) -&gt; io::Result&lt;()&gt; {
    match OpenOptions::new().create(true).write(true).open(path) {
        Ok(_) =&gt; Ok(()),
        Err(e) =&gt; Err(e),
    }
}

fn main() {
    println!(&quot;`mkdir a`&quot;);
    // Create a directory, returns `io::Result&lt;()&gt;`
    match fs::create_dir(&quot;a&quot;) {
        Err(why) =&gt; println!(&quot;! {:?}&quot;, why.kind()),
        Ok(_) =&gt; {},
    }

    println!(&quot;`echo hello &gt; a/b.txt`&quot;);
    // The previous match can be simplified using the `unwrap_or_else` method
    echo(&quot;hello&quot;, &amp;Path::new(&quot;a/b.txt&quot;)).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
    });

    println!(&quot;`mkdir -p a/c/d`&quot;);
    // Recursively create a directory, returns `io::Result&lt;()&gt;`
    fs::create_dir_all(&quot;a/c/d&quot;).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
    });

    println!(&quot;`touch a/c/e.txt`&quot;);
    touch(&amp;Path::new(&quot;a/c/e.txt&quot;)).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
    });

    println!(&quot;`ln -s ../b.txt a/c/b.txt`&quot;);
    // Create a symbolic link, returns `io::Result&lt;()&gt;`
    if cfg!(target_family = &quot;unix&quot;) {
        unix::fs::symlink(&quot;../b.txt&quot;, &quot;a/c/b.txt&quot;).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
        });
    }

    println!(&quot;`cat a/c/b.txt`&quot;);
    match cat(&amp;Path::new(&quot;a/c/b.txt&quot;)) {
        Err(why) =&gt; println!(&quot;! {:?}&quot;, why.kind()),
        Ok(s) =&gt; println!(&quot;&gt; {}&quot;, s),
    }

    println!(&quot;`ls a`&quot;);
    // Read the contents of a directory, returns `io::Result&lt;Vec&lt;Path&gt;&gt;`
    match fs::read_dir(&quot;a&quot;) {
        Err(why) =&gt; println!(&quot;! {:?}&quot;, why.kind()),
        Ok(paths) =&gt; for path in paths {
            println!(&quot;&gt; {:?}&quot;, path.unwrap().path());
        },
    }

    println!(&quot;`rm a/c/e.txt`&quot;);
    // Remove a file, returns `io::Result&lt;()&gt;`
    fs::remove_file(&quot;a/c/e.txt&quot;).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
    });

    println!(&quot;`rmdir a/c/d`&quot;);
    // Remove an empty directory, returns `io::Result&lt;()&gt;`
    fs::remove_dir(&quot;a/c/d&quot;).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
    });
}

</code></pre>
<p>Here's the expected successful output:</p>
<pre><code class="language-shell">$ rustc fs.rs &amp;&amp; ./fs
`mkdir a`
`echo hello &gt; a/b.txt`
`mkdir -p a/c/d`
`touch a/c/e.txt`
`ln -s ../b.txt a/c/b.txt`
`cat a/c/b.txt`
&gt; hello
`ls a`
&gt; &quot;a/b.txt&quot;
&gt; &quot;a/c&quot;
`rm a/c/e.txt`
`rmdir a/c/d`
</code></pre>
<p>And the final state of the <code>a</code> directory is:</p>
<pre><code class="language-shell">$ tree a
a
|-- b.txt
`-- c
    `-- b.txt -&gt; ../b.txt

1 directory, 2 files
</code></pre>
<p>An alternative way to define the function <code>cat</code> is with <code>?</code> notation:</p>
<pre><code class="language-rust ignore">fn cat(path: &amp;Path) -&gt; io::Result&lt;String&gt; {
    let mut f = File::open(path)?;
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?;
    Ok(s)
}
</code></pre>
<h3 id="see-also-71"><a class="header" href="#see-also-71">See also:</a></h3>
<p><a href="std_misc/../attribute/cfg.html"><code>cfg!</code></a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="program-arguments"><a class="header" href="#program-arguments">Program arguments</a></h1>
<h2 id="standard-library"><a class="header" href="#standard-library">Standard Library</a></h2>
<p>The command line arguments can be accessed using <code>std::env::args</code>, which
returns an iterator that yields a <code>String</code> for each argument:</p>
<pre><pre class="playground"><code class="language-rust editable">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    // The first argument is the path that was used to call the program.
    println!(&quot;My path is {}.&quot;, args[0]);

    // The rest of the arguments are the passed command line parameters.
    // Call the program like this:
    //   $ ./args arg1 arg2
    println!(&quot;I got {:?} arguments: {:?}.&quot;, args.len() - 1, &amp;args[1..]);
}
</code></pre></pre>
<pre><code class="language-shell">$ ./args 1 2 3
My path is ./args.
I got 3 arguments: [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].
</code></pre>
<h2 id="crates-2"><a class="header" href="#crates-2">Crates</a></h2>
<p>Alternatively, there are numerous crates that can provide extra functionality
when creating command-line applications. The <a href="https://rust-lang-nursery.github.io/rust-cookbook/cli/arguments.html">Rust Cookbook</a> exhibits best
practices on how to use one of the more popular command line argument crates,
<code>clap</code>.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="argument-parsing"><a class="header" href="#argument-parsing">Argument parsing</a></h1>
<p>Matching can be used to parse simple arguments:</p>
<pre><pre class="playground"><code class="language-rust editable">use std::env;

fn increase(number: i32) {
    println!(&quot;{}&quot;, number + 1);
}

fn decrease(number: i32) {
    println!(&quot;{}&quot;, number - 1);
}

fn help() {
    println!(&quot;usage:
match_args &lt;string&gt;
    Check whether given string is the answer.
match_args {{increase|decrease}} &lt;integer&gt;
    Increase or decrease given integer by one.&quot;);
}

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    match args.len() {
        // no arguments passed
        1 =&gt; {
            println!(&quot;My name is 'match_args'. Try passing some arguments!&quot;);
        },
        // one argument passed
        2 =&gt; {
            match args[1].parse() {
                Ok(42) =&gt; println!(&quot;This is the answer!&quot;),
                _ =&gt; println!(&quot;This is not the answer.&quot;),
            }
        },
        // one command and one argument passed
        3 =&gt; {
            let cmd = &amp;args[1];
            let num = &amp;args[2];
            // parse the number
            let number: i32 = match num.parse() {
                Ok(n) =&gt; {
                    n
                },
                Err(_) =&gt; {
                    eprintln!(&quot;error: second argument not an integer&quot;);
                    help();
                    return;
                },
            };
            // parse the command
            match &amp;cmd[..] {
                &quot;increase&quot; =&gt; increase(number),
                &quot;decrease&quot; =&gt; decrease(number),
                _ =&gt; {
                    eprintln!(&quot;error: invalid command&quot;);
                    help();
                },
            }
        },
        // all the other cases
        _ =&gt; {
            // show a help message
            help();
        }
    }
}
</code></pre></pre>
<pre><code class="language-shell">$ ./match_args Rust
This is not the answer.
$ ./match_args 42
This is the answer!
$ ./match_args do something
error: second argument not an integer
usage:
match_args &lt;string&gt;
    Check whether given string is the answer.
match_args {increase|decrease} &lt;integer&gt;
    Increase or decrease given integer by one.
$ ./match_args do 42
error: invalid command
usage:
match_args &lt;string&gt;
    Check whether given string is the answer.
match_args {increase|decrease} &lt;integer&gt;
    Increase or decrease given integer by one.
$ ./match_args increase 42
43
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="foreign-function-interface"><a class="header" href="#foreign-function-interface">Foreign Function Interface</a></h1>
<p>Rust provides a Foreign Function Interface (FFI) to C libraries. Foreign
functions must be declared inside an <code>extern</code> block annotated with a <code>#[link]</code>
attribute containing the name of the foreign library.</p>
<pre><code class="language-rust ignore">use std::fmt;

// this extern block links to the libm library
#[link(name = &quot;m&quot;)]
extern {
    // this is a foreign function
    // that computes the square root of a single precision complex number
    fn csqrtf(z: Complex) -&gt; Complex;

    fn ccosf(z: Complex) -&gt; Complex;
}

// Since calling foreign functions is considered unsafe,
// it's common to write safe wrappers around them.
fn cos(z: Complex) -&gt; Complex {
    unsafe { ccosf(z) }
}

fn main() {
    // z = -1 + 0i
    let z = Complex { re: -1., im: 0. };

    // calling a foreign function is an unsafe operation
    let z_sqrt = unsafe { csqrtf(z) };

    println!(&quot;the square root of {:?} is {:?}&quot;, z, z_sqrt);

    // calling safe API wrapped around unsafe operation
    println!(&quot;cos({:?}) = {:?}&quot;, z, cos(z));
}

// Minimal implementation of single precision complex numbers
#[repr(C)]
#[derive(Clone, Copy)]
struct Complex {
    re: f32,
    im: f32,
}

impl fmt::Debug for Complex {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        if self.im &lt; 0. {
            write!(f, &quot;{}-{}i&quot;, self.re, -self.im)
        } else {
            write!(f, &quot;{}+{}i&quot;, self.re, self.im)
        }
    }
}
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="testing-1"><a class="header" href="#testing-1">Testing</a></h1>
<p>Rust is a programming language that cares a lot about correctness and it
includes support for writing software tests within the language itself.</p>
<p>Testing comes in three styles:</p>
<ul>
<li><a href="testing/unit_testing.html">Unit</a> testing.</li>
<li><a href="testing/doc_testing.html">Doc</a> testing.</li>
<li><a href="testing/integration_testing.html">Integration</a> testing.</li>
</ul>
<p>Also Rust has support for specifying additional dependencies for tests:</p>
<ul>
<li><a href="testing/dev_dependencies.html">Dev-dependencies</a></li>
</ul>
<h2 id="see-also-72"><a class="header" href="#see-also-72">See Also</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch11-00-testing.html">The Book</a> chapter on testing</li>
<li><a href="https://rust-lang-nursery.github.io/api-guidelines/documentation.html">API Guidelines</a> on doc-testing</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="unit-testing"><a class="header" href="#unit-testing">Unit testing</a></h1>
<p>Tests are Rust functions that verify that the non-test code is functioning in
the expected manner. The bodies of test functions typically perform some setup,
run the code we want to test, then assert whether the results are what we
expect.</p>
<p>Most unit tests go into a <code>tests</code> <a href="testing/../mod.html">mod</a> with the <code>#[cfg(test)]</code> <a href="testing/../attribute.html">attribute</a>.
Test functions are marked with the <code>#[test]</code> attribute.</p>
<p>Tests fail when something in the test function <a href="testing/../std/panic.html">panics</a>. There are some
helper <a href="testing/../macros.html">macros</a>:</p>
<ul>
<li><code>assert!(expression)</code> - panics if expression evaluates to <code>false</code>.</li>
<li><code>assert_eq!(left, right)</code> and <code>assert_ne!(left, right)</code> - testing left and
right expressions for equality and inequality respectively.</li>
</ul>
<pre><code class="language-rust ignore">pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

// This is a really bad adding function, its purpose is to fail in this
// example.
#[allow(dead_code)]
fn bad_add(a: i32, b: i32) -&gt; i32 {
    a - b
}

#[cfg(test)]
mod tests {
    // Note this useful idiom: importing names from outer (for mod tests) scope.
    use super::*;

    #[test]
    fn test_add() {
        assert_eq!(add(1, 2), 3);
    }

    #[test]
    fn test_bad_add() {
        // This assert would fire and test will fail.
        // Please note, that private functions can be tested too!
        assert_eq!(bad_add(1, 2), 3);
    }
}
</code></pre>
<p>Tests can be run with <code>cargo test</code>.</p>
<pre><code class="language-shell">$ cargo test

running 2 tests
test tests::test_bad_add ... FAILED
test tests::test_add ... ok

failures:

---- tests::test_bad_add stdout ----
        thread 'tests::test_bad_add' panicked at 'assertion failed: `(left == right)`
  left: `-1`,
 right: `3`', src/lib.rs:21:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.


failures:
    tests::test_bad_add

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h2 id="tests-and-"><a class="header" href="#tests-and-">Tests and <code>?</code></a></h2>
<p>None of the previous unit test examples had a return type. But in Rust 2018,
your unit tests can return <code>Result&lt;()&gt;</code>, which lets you use <code>?</code> in them! This
can make them much more concise.</p>
<pre><pre class="playground"><code class="language-rust editable">fn sqrt(number: f64) -&gt; Result&lt;f64, String&gt; {
    if number &gt;= 0.0 {
        Ok(number.powf(0.5))
    } else {
        Err(&quot;negative floats don't have square roots&quot;.to_owned())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sqrt() -&gt; Result&lt;(), String&gt; {
        let x = 4.0;
        assert_eq!(sqrt(x)?.powf(2.0), x);
        Ok(())
    }
}
</code></pre></pre>
<p>See <a href="https://doc.rust-lang.org/edition-guide/rust-2018/error-handling-and-panics/question-mark-in-main-and-tests.html">&quot;The Edition Guide&quot;</a> for more details.</p>
<h2 id="testing-panics"><a class="header" href="#testing-panics">Testing panics</a></h2>
<p>To check functions that should panic under certain circumstances, use attribute
<code>#[should_panic]</code>. This attribute accepts optional parameter <code>expected = </code> with
the text of the panic message. If your function can panic in multiple ways, it helps
make sure your test is testing the correct panic.</p>
<pre><code class="language-rust ignore">pub fn divide_non_zero_result(a: u32, b: u32) -&gt; u32 {
    if b == 0 {
        panic!(&quot;Divide-by-zero error&quot;);
    } else if a &lt; b {
        panic!(&quot;Divide result is zero&quot;);
    }
    a / b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_divide() {
        assert_eq!(divide_non_zero_result(10, 2), 5);
    }

    #[test]
    #[should_panic]
    fn test_any_panic() {
        divide_non_zero_result(1, 0);
    }

    #[test]
    #[should_panic(expected = &quot;Divide result is zero&quot;)]
    fn test_specific_panic() {
        divide_non_zero_result(1, 10);
    }
}
</code></pre>
<p>Running these tests gives us:</p>
<pre><code class="language-shell">$ cargo test

running 3 tests
test tests::test_any_panic ... ok
test tests::test_divide ... ok
test tests::test_specific_panic ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests tmp-test-should-panic

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h2 id="running-specific-tests"><a class="header" href="#running-specific-tests">Running specific tests</a></h2>
<p>To run specific tests one may specify the test name to <code>cargo test</code> command.</p>
<pre><code class="language-shell">$ cargo test test_any_panic
running 1 test
test tests::test_any_panic ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out

   Doc-tests tmp-test-should-panic

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>To run multiple tests one may specify part of a test name that matches all the
tests that should be run.</p>
<pre><code class="language-shell">$ cargo test panic
running 2 tests
test tests::test_any_panic ... ok
test tests::test_specific_panic ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out

   Doc-tests tmp-test-should-panic

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h2 id="ignoring-tests"><a class="header" href="#ignoring-tests">Ignoring tests</a></h2>
<p>Tests can be marked with the <code>#[ignore]</code> attribute to exclude some tests. Or to run
them with command <code>cargo test -- --ignored</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add() {
        assert_eq!(add(2, 2), 4);
    }

    #[test]
    fn test_add_hundred() {
        assert_eq!(add(100, 2), 102);
        assert_eq!(add(2, 100), 102);
    }

    #[test]
    #[ignore]
    fn ignored_test() {
        assert_eq!(add(0, 0), 0);
    }
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-shell">$ cargo test
running 3 tests
test tests::ignored_test ... ignored
test tests::test_add ... ok
test tests::test_add_hundred ... ok

test result: ok. 2 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out

   Doc-tests tmp-ignore

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

$ cargo test -- --ignored
running 1 test
test tests::ignored_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests tmp-ignore

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="documentation-testing"><a class="header" href="#documentation-testing">Documentation testing</a></h1>
<p>The primary way of documenting a Rust project is through annotating the source
code. Documentation comments are written in <a href="https://daringfireball.net/projects/markdown/">markdown</a> and support code
blocks in them. Rust takes care about correctness, so these code blocks are
compiled and used as tests.</p>
<pre><code class="language-rust ignore">/// First line is a short summary describing function.
///
/// The next lines present detailed documentation. Code blocks start with
/// triple backquotes and have implicit `fn main()` inside
/// and `extern crate &lt;cratename&gt;`. Assume we're testing `doccomments` crate:
///
/// ```
/// let result = doccomments::add(2, 3);
/// assert_eq!(result, 5);
/// ```
pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

/// Usually doc comments may include sections &quot;Examples&quot;, &quot;Panics&quot; and &quot;Failures&quot;.
///
/// The next function divides two numbers.
///
/// # Examples
///
/// ```
/// let result = doccomments::div(10, 2);
/// assert_eq!(result, 5);
/// ```
///
/// # Panics
///
/// The function panics if the second argument is zero.
///
/// ```rust,should_panic
/// // panics on division by zero
/// doccomments::div(10, 0);
/// ```
pub fn div(a: i32, b: i32) -&gt; i32 {
    if b == 0 {
        panic!(&quot;Divide-by-zero error&quot;);
    }

    a / b
}
</code></pre>
<p>Tests can be run with <code>cargo test</code>:</p>
<pre><code class="language-shell">$ cargo test
running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests doccomments

running 3 tests
test src/lib.rs - add (line 7) ... ok
test src/lib.rs - div (line 21) ... ok
test src/lib.rs - div (line 31) ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h2 id="motivation-behind-documentation-tests"><a class="header" href="#motivation-behind-documentation-tests">Motivation behind documentation tests</a></h2>
<p>The main purpose of documentation tests is to serve as examples that exercise
the functionality, which is one of the most important
<a href="https://rust-lang-nursery.github.io/api-guidelines/documentation.html#examples-use--not-try-not-unwrap-c-question-mark">guidelines</a>. It allows using examples from docs as
complete code snippets. But using <code>?</code> makes compilation fail since <code>main</code>
returns <code>unit</code>. The ability to hide some source lines from documentation comes
to the rescue: one may write <code>fn try_main() -&gt; Result&lt;(), ErrorType&gt;</code>, hide it and
<code>unwrap</code> it in hidden <code>main</code>. Sounds complicated? Here's an example:</p>
<pre><code class="language-rust ignore">/// Using hidden `try_main` in doc tests.
///
/// ```
/// # // hidden lines start with `#` symbol, but they're still compileable!
/// # fn try_main() -&gt; Result&lt;(), String&gt; { // line that wraps the body shown in doc
/// let res = try::try_div(10, 2)?;
/// # Ok(()) // returning from try_main
/// # }
/// # fn main() { // starting main that'll unwrap()
/// #    try_main().unwrap(); // calling try_main and unwrapping
/// #                         // so that test will panic in case of error
/// # }
/// ```
pub fn try_div(a: i32, b: i32) -&gt; Result&lt;i32, String&gt; {
    if b == 0 {
        Err(String::from(&quot;Divide-by-zero&quot;))
    } else {
        Ok(a / b)
    }
}
</code></pre>
<h2 id="see-also-73"><a class="header" href="#see-also-73">See Also</a></h2>
<ul>
<li><a href="https://github.com/rust-lang/rfcs/blob/master/text/0505-api-comment-conventions.md">RFC505</a> on documentation style</li>
<li><a href="https://rust-lang-nursery.github.io/api-guidelines/documentation.html">API Guidelines</a> on documentation guidelines</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="integration-testing"><a class="header" href="#integration-testing">Integration testing</a></h1>
<p><a href="testing/unit_testing.html">Unit tests</a> are testing one module in isolation at a time: they're small
and can test private code. Integration tests are external to your crate and use
only its public interface in the same way any other code would. Their purpose is
to test that many parts of your library work correctly together.</p>
<p>Cargo looks for integration tests in <code>tests</code> directory next to <code>src</code>.</p>
<p>File <code>src/lib.rs</code>:</p>
<pre><code class="language-rust ignore">// Define this in a crate called `adder`.
pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}
</code></pre>
<p>File with test: <code>tests/integration_test.rs</code>:</p>
<pre><code class="language-rust ignore">#[test]
fn test_add() {
    assert_eq!(adder::add(3, 2), 5);
}
</code></pre>
<p>Running tests with <code>cargo test</code> command:</p>
<pre><code class="language-shell">$ cargo test
running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/integration_test-bcd60824f5fbfe19

running 1 test
test test_add ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Each Rust source file in <code>tests</code> directory is compiled as a separate crate. One
way of sharing some code between integration tests is making module with public
functions, importing and using it within tests.</p>
<p>File <code>tests/common.rs</code>:</p>
<pre><code class="language-rust ignore">pub fn setup() {
    // some setup code, like creating required files/directories, starting
    // servers, etc.
}
</code></pre>
<p>File with test: <code>tests/integration_test.rs</code></p>
<pre><code class="language-rust ignore">// importing common module.
mod common;

#[test]
fn test_add() {
    // using common code.
    common::setup();
    assert_eq!(adder::add(3, 2), 5);
}
</code></pre>
<p>Modules with common code follow the ordinary <a href="testing/../mod.html">modules</a> rules, so it's ok to
create common module as <code>tests/common/mod.rs</code>.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="development-dependencies"><a class="header" href="#development-dependencies">Development dependencies</a></h1>
<p>Sometimes there is a need to have dependencies for tests (or examples,
or benchmarks) only. Such dependencies are added to <code>Cargo.toml</code> in the
<code>[dev-dependencies]</code> section. These dependencies are not propagated to other
packages which depend on this package.</p>
<p>One such example is using a crate that extends standard <code>assert!</code> macros.<br />
File <code>Cargo.toml</code>:</p>
<pre><code class="language-toml"># standard crate data is left out
[dev-dependencies]
pretty_assertions = &quot;0.4.0&quot;
</code></pre>
<p>File <code>src/lib.rs</code>:</p>
<pre><code class="language-rust ignore">// externing crate for test-only use
#[cfg(test)]
#[macro_use]
extern crate pretty_assertions;

pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add() {
        assert_eq!(add(2, 3), 5);
    }
}
</code></pre>
<h2 id="see-also-74"><a class="header" href="#see-also-74">See Also</a></h2>
<p><a href="http://doc.crates.io/specifying-dependencies.html">Cargo</a> docs on specifying dependencies.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="unsafe-operations"><a class="header" href="#unsafe-operations">Unsafe Operations</a></h1>
<p>As an introduction to this section, to borrow from <a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html">the official docs</a>,
&quot;one should try to minimize the amount of unsafe code in a code base.&quot; With that
in mind, let's get started! Unsafe annotations in Rust are used to bypass
protections put in place by the compiler; specifically, there are four primary
things that unsafe is used for:</p>
<ul>
<li>dereferencing raw pointers</li>
<li>calling functions or methods which are <code>unsafe</code> (including calling a function
over FFI, see <a href="std_misc/ffi.html">a previous chapter</a> of the book) </li>
<li>accessing or modifying static mutable variables</li>
<li>implementing unsafe traits</li>
</ul>
<h3 id="raw-pointers"><a class="header" href="#raw-pointers">Raw Pointers</a></h3>
<p>Raw pointers <code>*</code> and references <code>&amp;T</code> function similarly, but references are
always safe because they are guaranteed to point to valid data due to the
borrow checker. Dereferencing a raw pointer can only be done through an unsafe
block.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let raw_p: *const u32 = &amp;10;

    unsafe {
        assert!(*raw_p == 10);
    }
}
</code></pre></pre>
<h3 id="calling-unsafe-functions"><a class="header" href="#calling-unsafe-functions">Calling Unsafe Functions</a></h3>
<p>Some functions can be declared as <code>unsafe</code>, meaning it is the programmer's
responsibility to ensure correctness instead of the compiler's. One example
of this is <a href="https://doc.rust-lang.org/std/slice/fn.from_raw_parts.html"><code>std::slice::from_raw_parts</code></a> which will create a slice given a
pointer to the first element and a length.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::slice;

fn main() {
    let some_vector = vec![1, 2, 3, 4];

    let pointer = some_vector.as_ptr();
    let length = some_vector.len();

    unsafe {
        let my_slice: &amp;[u32] = slice::from_raw_parts(pointer, length);

        assert_eq!(some_vector.as_slice(), my_slice);
    }
}
</code></pre></pre>
<p>For <code>slice::from_raw_parts</code>, one of the assumptions which <em>must</em> be upheld is 
that the pointer passed in points to valid memory and that the memory pointed to
is of the correct type. If these invariants aren't upheld then the program's 
behaviour is undefined and there is no knowing what will happen.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="compatibility"><a class="header" href="#compatibility">Compatibility</a></h1>
<p>The Rust language is fastly evolving, and because of this certain compatibility
issues can arise, despite efforts to ensure forwards-compatibility wherever
possible.</p>
<ul>
<li><a href="compatibility/raw_identifiers.html">Raw identifiers</a></li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="raw-identifiers"><a class="header" href="#raw-identifiers">Raw identifiers</a></h1>
<p>Rust, like many programming languages, has the concept of &quot;keywords&quot;.
These identifiers mean something to the language, and so you cannot use them in
places like variable names, function names, and other places.
Raw identifiers let you use keywords where they would not normally be allowed.
This is particularly useful when Rust introduces new keywords, and a library
using an older edition of Rust has a variable or function with the same name
as a keyword introduced in a newer edition.</p>
<p>For example, consider a crate <code>foo</code> compiled with the 2015 edition of Rust that
exports a function named <code>try</code>. This keyword is reserved for a new feature in
the 2018 edition, so without raw identifiers, we would have no way to name the
function.</p>
<pre><code class="language-rust ignore">extern crate foo;

fn main() {
    foo::try();
}
</code></pre>
<p>You'll get this error:</p>
<pre><code class="language-text">error: expected identifier, found keyword `try`
 --&gt; src/main.rs:4:4
  |
4 | foo::try();
  |      ^^^ expected identifier, found keyword
</code></pre>
<p>You can write this with a raw identifier:</p>
<pre><code class="language-rust ignore">extern crate foo;

fn main() {
    foo::r#try();
}
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="meta"><a class="header" href="#meta">Meta</a></h1>
<p>Some topics aren't exactly relevant to how you program but provide you
tooling or infrastructure support which just makes things better for
everyone. These topics include:</p>
<ul>
<li><a href="meta/doc.html">Documentation</a>: Generate library documentation for users via the included
<code>rustdoc</code>.</li>
<li><a href="meta/playpen.html">Playpen</a>: Integrate the Rust Playpen(also known as the Rust Playground) in your documentation.</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="documentation"><a class="header" href="#documentation">Documentation</a></h1>
<p>Use <code>cargo doc</code> to build documentation in <code>target/doc</code>.</p>
<p>Use <code>cargo test</code> to run all tests (including documentation tests), and <code>cargo test --doc</code> to only run documentation tests.</p>
<p>These commands will appropriately invoke <code>rustdoc</code> (and <code>rustc</code>) as required.</p>
<h2 id="doc-comments"><a class="header" href="#doc-comments">Doc comments</a></h2>
<p>Doc comments are very useful for big projects that require documentation. When
running <code>rustdoc</code>, these are the comments that get compiled into
documentation. They are denoted by a <code>///</code>, and support <a href="https://en.wikipedia.org/wiki/Markdown">Markdown</a>.</p>
<pre><code class="language-rust editable ignore">#![crate_name = &quot;doc&quot;]

/// A human being is represented here
pub struct Person {
    /// A person must have a name, no matter how much Juliet may hate it
    name: String,
}

impl Person {
    /// Returns a person with the name given them
    ///
    /// # Arguments
    ///
    /// * `name` - A string slice that holds the name of the person
    ///
    /// # Examples
    ///
    /// ```
    /// // You can have rust code between fences inside the comments
    /// // If you pass --test to `rustdoc`, it will even test it for you!
    /// use doc::Person;
    /// let person = Person::new(&quot;name&quot;);
    /// ```
    pub fn new(name: &amp;str) -&gt; Person {
        Person {
            name: name.to_string(),
        }
    }

    /// Gives a friendly hello!
    ///
    /// Says &quot;Hello, [name]&quot; to the `Person` it is called on.
    pub fn hello(&amp; self) {
        println!(&quot;Hello, {}!&quot;, self.name);
    }
}

fn main() {
    let john = Person::new(&quot;John&quot;);

    john.hello();
}
</code></pre>
<p>To run the tests, first build the code as a library, then tell <code>rustdoc</code> where
to find the library so it can link it into each doctest program:</p>
<pre><code class="language-shell">$ rustc doc.rs --crate-type lib
$ rustdoc --test --extern doc=&quot;libdoc.rlib&quot; doc.rs
</code></pre>
<h2 id="doc-attributes"><a class="header" href="#doc-attributes">Doc attributes</a></h2>
<p>Below are a few examples of the most common <code>#[doc]</code> attributes used with <code>rustdoc</code>.</p>
<h3 id="inline"><a class="header" href="#inline"><code>inline</code></a></h3>
<p>Used to inline docs, instead of linking out to separate page.</p>
<pre><code class="language-rust ignore">#[doc(inline)]
pub use bar::Bar;

/// bar docs
mod bar {
    /// the docs for Bar
    pub struct Bar;
}
</code></pre>
<h3 id="no_inline"><a class="header" href="#no_inline"><code>no_inline</code></a></h3>
<p>Used to prevent linking out to separate page or anywhere.</p>
<pre><code class="language-rust ignore">// Example from libcore/prelude
#[doc(no_inline)]
pub use crate::mem::drop;
</code></pre>
<h3 id="hidden"><a class="header" href="#hidden"><code>hidden</code></a></h3>
<p>Using this tells <code>rustdoc</code> not to include this in documentation:</p>
<pre><code class="language-rust editable ignore">// Example from the futures-rs library
#[doc(hidden)]
pub use self::async_await::*;
</code></pre>
<p>For documentation, <code>rustdoc</code> is widely used by the community. It's what is used to generate the <a href="https://doc.rust-lang.org/std/">std library docs</a>.</p>
<h3 id="see-also-75"><a class="header" href="#see-also-75">See also:</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html#making-useful-documentation-comments">The Rust Book: Making Useful Documentation Comments</a></li>
<li><a href="https://doc.rust-lang.org/rustdoc/index.html">The rustdoc Book</a></li>
<li><a href="https://doc.rust-lang.org/stable/reference/comments.html#doc-comments">The Reference: Doc comments</a></li>
<li><a href="https://rust-lang.github.io/rfcs/1574-more-api-documentation-conventions.html#appendix-a-full-conventions-text">RFC 1574: API Documentation Conventions</a></li>
<li><a href="https://rust-lang.github.io/rfcs/1946-intra-rustdoc-links.html">RFC 1946: Relative links to other items from doc comments (intra-rustdoc links)</a></li>
<li><a href="https://www.reddit.com/r/rust/comments/ahb50s/is_there_any_documentation_style_guide_for/">Is there any documentation style guide for comments? (reddit)</a></li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="playpen"><a class="header" href="#playpen">Playpen</a></h1>
<p>The <a href="https://github.com/rust-lang/rust-playpen">Rust Playpen</a> is a way to experiment with Rust code through a web interface. This project is now commonly referred to as <a href="https://play.rust-lang.org/">Rust Playground</a>.</p>
<h2 id="using-it-with-mdbook"><a class="header" href="#using-it-with-mdbook">Using it with <code>mdbook</code></a></h2>
<p>In <a href="https://github.com/rust-lang/mdBook"><code>mdbook</code></a>, you can make code examples playable and editable.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    println!(&quot;Hello World!&quot;);
}
</code></pre></pre>
<p>This allows the reader to both run your code sample, but also modify and tweak it. The key here is the adding the word <code>editable</code> to your codefence block separated by a comma.</p>
<pre><code class="language-markdown">```rust,editable
//...place your code here
```
</code></pre>
<p>Additionally, you can add <code>ignore</code> if you want <code>mdbook</code> to skip your code when it builds and tests.</p>
<pre><code class="language-markdown">```rust,editable,ignore
//...place your code here
```
</code></pre>
<h2 id="using-it-with-docs"><a class="header" href="#using-it-with-docs">Using it with docs</a></h2>
<p>You may have noticed in some of the <a href="https://doc.rust-lang.org/core/">official Rust docs</a> a button that says &quot;Run&quot;, which opens the code sample up in a new tab in Rust Playground. This feature is enabled if you use the #[doc] attribute called <a href="https://doc.rust-lang.org/rustdoc/the-doc-attribute.html#html_playground_url"><code>html_playground_url</code></a>.</p>
<h3 id="see-also-76"><a class="header" href="#see-also-76">See also:</a></h3>
<ul>
<li><a href="https://play.rust-lang.org/">The Rust Playground</a></li>
<li><a href="https://github.com/integer32llc/rust-playground/">The next-gen playpen</a></li>
<li><a href="https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html">The rustdoc Book</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
